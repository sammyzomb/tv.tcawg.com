<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>統一節目管理系統 - 縮圖功能已更新</title>
  <!-- 版本標記：2024-12-19 更新縮圖功能 -->
  <!-- 時間戳記：2024-12-19 21:45:00 -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f5f5; }

    .container { max-width: 1400px; margin: 0 auto; padding: 20px; }

    .header { background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
    .header h1 { color: #2b71d2; margin-bottom: 10px; }

    .view-controls { background: white; padding: 15px; border-radius: 10px; margin-bottom: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 15px; }

    .view-buttons { display: flex; gap: 10px; }
    .view-btn { background: #f8f9fa; color: #495057; border: 2px solid #e9ecef; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease; }
    .view-btn.active { background: #2b71d2; color: white; border-color: #2b71d2; }
    .view-btn:hover { background: #e3f2fd; border-color: #2b71d2; }
    .view-btn.active:hover { background: #1e5bb8; }

    .nav-controls { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
    .nav-btn { background: #2b71d2; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; }
    .nav-btn:hover { background: #1e5bb8; }
    .current-date { font-size: 1.2rem; font-weight: 600; color: #333; min-width: 200px; text-align: center; }
    .today-btn { background: #28a745; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; }
    .today-btn:hover { background: #218838; }

    .view { display: none; }
    .view.active { display: block; }

    .calendar-grid { background: white; border-radius: 10px; overflow: hidden; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
    .calendar-header { display: grid; grid-template-columns: repeat(7, 1fr); background: #2b71d2; color: white; }
    .calendar-header div { padding: 15px; text-align: center; font-weight: 600; }
    .calendar-body { display: grid; grid-template-columns: repeat(7, 1fr); }
    .calendar-day { min-height: 120px; border: 1px solid #eee; padding: 8px; position: relative; background: white; cursor: pointer; }
    .calendar-day:hover { background: #f8f9fa; }
    .calendar-day.other-month { background: #f8f9fa; color: #999; }
    .calendar-day.today { background: #e3f2fd; border-color: #2b71d2; }

    .day-number { font-weight: 600; margin-bottom: 8px; color: #333; font-size: 0.9rem; }
    .day-events { position: relative; }

    /* Google 日曆風格的節目顯示 */
    .event {
      background: #e8f5e8;
      border: 1px solid #4caf50;
      border-radius: 3px;
      padding: 2px 6px;
      font-size: 0.65rem;
      margin-bottom: 1px;
      cursor: pointer;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      line-height: 1.2;
      max-width: 100%;
      position: relative;
    }
    .event:hover { background: #c8e6c9; }
    .event.prime-time { background: #ffe8e8; border-color: #ff6b6b; }
    .event.first-air { background: #fff3cd; border-color: #ffc107; }

    /* 更多節目指示器 */
    .more-events-indicator {
      background: #f0f0f0;
      border: 1px solid #ddd;
      border-radius: 3px;
      padding: 2px 6px;
      font-size: 0.6rem;
      color: #666;
      cursor: pointer;
      text-align: center;
      margin-top: 2px;
      font-style: italic;
    }
    .more-events-indicator:hover {
      background: #e0e0e0;
    }

    /* 節目工具提示 */
    .event-tooltip {
      position: absolute;
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.8rem;
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
      max-width: 250px;
      word-wrap: break-word;
      white-space: normal;
      top: 100%;
      left: 0;
      margin-top: 5px;
    }

    .event:hover .event-tooltip {
      opacity: 1;
    }

    .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; }
    .modal-content { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 10px; width: 90%; max-width: 600px; max-height: 80vh; overflow-y: auto; z-index: 10001; }
    .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; position: relative; z-index: 10002; }
    
    /* 編輯模態框需要更高的 z-index 和更大的高度 */
    #eventModal { z-index: 10010 !important; }
    #eventModal .modal-content { 
      z-index: 10011 !important; 
      max-height: 90vh !important;
      max-width: 95vw !important;
      width: 95vw !important;
      top: 50% !important;
      left: 50% !important;
      transform: translate(-50%, -50%) !important;
      padding: 40px !important;
      position: fixed !important;
      margin: 0 !important;
    }
    #eventModal .modal-header { z-index: 10012 !important; }
    .modal-close { background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666; }

    .form-group { margin-bottom: 20px; }
    .form-group label { display: block; margin-bottom: 8px; font-weight: 600; color: #333; font-size: 15px; }
    .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; }
    .form-group textarea { height: 120px; resize: vertical; }
    
    /* 編輯模態框專用樣式 */
    #eventModal .form-group { margin-bottom: 25px; }
    #eventModal .form-group label { font-size: 16px; margin-bottom: 10px; }
    #eventModal .form-group input, #eventModal .form-group select, #eventModal .form-group textarea { 
      padding: 14px; 
      font-size: 15px; 
      border: 2px solid #e9ecef; 
      border-radius: 8px;
      transition: border-color 0.3s ease;
    }
    #eventModal .form-group input:focus, #eventModal .form-group select:focus, #eventModal .form-group textarea:focus {
      border-color: #007bff;
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
    }
    #eventModal .form-group textarea { height: 150px; }
    
    /* 響應式設計 - 編輯模態框 */
    @media (max-width: 1200px) {
      #eventModal .modal-content {
        max-width: 90vw !important;
        width: 90vw !important;
        padding: 30px !important;
      }
    }
    
    @media (max-width: 768px) {
      #eventModal .modal-content {
        max-width: 95vw !important;
        width: 95vw !important;
        padding: 20px !important;
        max-height: 95vh !important;
      }
      #eventModal .form-group { margin-bottom: 20px; }
      #eventModal .form-group textarea { height: 120px; }
      #topicsCheckboxes {
        grid-template-columns: 1fr !important;
      }
    }

    .btn { background: #2b71d2; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; margin-right: 10px; }
    .btn:hover { background: #1e5bb8; }
    .btn-secondary { background: #6c757d; }
    .btn-secondary:hover { background: #5a6268; }
    .btn-danger { background: #dc3545; }
    .btn-danger:hover { background: #c82333; }

    .status-bar { position: fixed; bottom: 20px; right: 20px; background: #333; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 1001; display: none; }

    /* 週視圖和日視圖樣式 */
    .week-row, .day-row { transition: background-color 0.2s ease; }
    .week-row:hover, .day-row:hover { background-color: #f8f9fa; }
    .time-cell { user-select: none; }
    .day-cell, .event-cell { transition: background-color 0.2s ease; }
    .day-cell:hover, .event-cell:hover { background-color: #e3f2fd !important; }

    /* 週視圖特殊樣式 */
    #weekView .calendar-header {
      grid-template-columns: 80px repeat(7, 1fr);
      background: #2b71d2;
      color: white;
      position: sticky;
      top: 0;
      z-index: 100;
    }
    #weekView .calendar-body {
      display: block;
      background: white;
      max-height: 70vh;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: #ccc transparent;
    }

    /* 自定義滾動條 */
    #weekView .calendar-body::-webkit-scrollbar {
      width: 8px;
    }

    #weekView .calendar-body::-webkit-scrollbar-track {
      background: transparent;
    }

    #weekView .calendar-body::-webkit-scrollbar-thumb {
      background: #ccc;
      border-radius: 4px;
    }

    #weekView .calendar-body::-webkit-scrollbar-thumb:hover {
      background: #999;
    }

    /* 週視圖行樣式 */
    .week-row {
      display: grid !important;
      grid-template-columns: 80px repeat(7, 1fr) !important;
      border-bottom: 1px solid #eee;
      background: white;
      min-height: 30px;
    }

    /* 週視圖時間列樣式 */
    #weekView .time-cell {
      min-width: 80px;
      max-width: 80px;
      width: 80px;
      box-sizing: border-box;
      font-size: 0.75rem;
      padding: 4px 6px;
    }

    /* 週視圖日期單元格樣式 */
    #weekView .day-cell {
      min-height: 30px;
      max-height: 60px;
      overflow: hidden;
      position: relative;
      padding: 2px;
    }

    /* 週視圖節目樣式 */
    #weekView .event {
      font-size: 0.7rem;
      padding: 2px 4px;
      margin: 1px 0;
      border-radius: 3px;
      cursor: pointer;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 100%;
      position: relative;
      transition: all 0.2s ease;
    }

    /* 週視圖節目懸停效果 */
    #weekView .event:hover {
      transform: scale(1.02);
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      z-index: 10;
    }

    /* 週視圖節目工具提示 */
    #weekView .event-tooltip {
      position: absolute;
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.8rem;
      white-space: nowrap;
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
      max-width: 300px;
      word-wrap: break-word;
      white-space: normal;
    }

    #weekView .event:hover .event-tooltip {
      opacity: 1;
    }

    /* 日視圖特殊樣式 */
    #dayView .calendar-header {
      grid-template-columns: 80px 1fr;
      background: #2b71d2;
      color: white;
    }
    #dayView .calendar-body {
      display: block;
      background: white;
      max-height: 70vh;
      overflow-y: auto;
      padding: 0;
      min-height: 400px;
    }

    /* 日視圖行樣式 */
    .day-row {
      display: grid !important;
      grid-template-columns: 80px 1fr !important;
      border-bottom: 1px solid #eee;
      background: white;
      min-height: 60px;
      width: 100%;
    }

    /* 確保日視圖容器有足夠高度 */
    #dayView .calendar-grid {
      height: auto;
      min-height: 70vh;
      width: 100%;
    }

    /* 日視圖時間列樣式 */
    #dayView .time-cell {
      min-width: 80px;
      max-width: 80px;
      width: 80px;
      box-sizing: border-box;
    }

    /* 日視圖節目列樣式 */
    #dayView .event-cell {
      width: 100%;
      box-sizing: border-box;
      overflow: hidden;
    }

    /* 過去日期樣式 */
    .calendar-day.past-date {
      background-color: #f8f9fa !important;
      color: #999 !important;
    }

    .calendar-day.past-date .day-number {
      color: #999 !important;
    }

    .calendar-day.past-date .event {
      opacity: 0.6;
    }

    /* 月曆視圖的節目計數指示器 */
    .event-count-badge {
      position: absolute;
      top: 5px;
      right: 5px;
      background: #2b71d2;
      color: white;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      font-weight: 600;
      z-index: 5;
    }

    /* 節目時間標籤 */
    .event-time-label {
      font-weight: 600;
      color: #333;
      font-size: 0.6rem;
      margin-right: 3px;
    }

    /* 改善按鈕樣式 */
    .btn {
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.3s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }

    /* 改善日曆網格 */
    .calendar-grid {
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    }

    /* 改善日曆標題 */
    .calendar-header {
      background: linear-gradient(135deg, #2b71d2, #1e5bb8) !important;
    }

    /* 改善容器間距 */
    .container {
      max-width: 1600px;
      margin: 0 auto;
      padding: 20px;
    }

    /* 改善提示框樣式 */
    [title] {
      position: relative;
    }
    
    [title]:hover::after {
      content: attr(title);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.95);
      color: #ffffff;
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 0.9rem;
      font-weight: 500;
      line-height: 1.4;
      z-index: 1000;
      pointer-events: none;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
      margin-bottom: 8px;
      max-width: 320px;
      min-width: 200px;
      word-wrap: break-word;
      white-space: normal;
      text-align: left;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    [title]:hover::before {
      content: '';
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: rgba(0, 0, 0, 0.95);
      z-index: 1000;
      pointer-events: none;
      margin-bottom: -6px;
    }

    /* 響應式設計 */
    @media (max-width: 1200px) {
      .nav-controls {
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
      }
      
      .date-navigation,
      .main-actions,
      .tool-actions {
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>📅 統一節目管理系統</h1>
      <p>整合月曆、週曆、日曆三種視圖，統一管理所有節目安排</p>
      <div class="current-time-display" id="currentTimeDisplay" style="
        background: #2b71d2;
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 0.9rem;
        font-weight: 600;
        display: inline-block;
        margin-top: 10px;
        box-shadow: 0 2px 8px rgba(43, 113, 210, 0.3);
      ">
        🕐 台灣時間：<span id="currentTimeText">載入中...</span>
      </div>
    </div>

    <div class="view-controls">
      <div class="view-buttons">
        <button class="view-btn active" onclick="switchView('month')" title="月曆視圖：查看整月的節目安排，適合長期規劃">📅 月曆視圖</button>
        <button class="view-btn" onclick="switchView('week')" title="週曆視圖：查看一週的節目安排，適合週間規劃">📊 週曆視圖</button>
        <button class="view-btn" onclick="switchView('day')" title="日曆視圖：查看單日的詳細節目安排，適合精確管理">📋 日曆視圖</button>
      </div>

      <div class="nav-controls">
        <!-- 日期導航 -->
        <div class="date-navigation" style="display: flex; align-items: center; gap: 10px; margin-right: 20px;">
          <button class="nav-btn" onclick="previousPeriod()" title="回到上一個月/週/日">◀</button>
          <div class="current-date" id="currentDate" title="當前顯示的日期範圍">2024年8月</div>
          <button class="nav-btn" onclick="nextPeriod()" title="前往下一個月/週/日">▶</button>
          <button class="today-btn" onclick="goToToday()" title="快速回到今天">今天</button>
        </div>
        
        <!-- 主要功能按鈕 -->
        <div class="main-actions" style="display: flex; gap: 8px; flex-wrap: wrap;">
          <button class="btn" style="background: #28a745; padding: 8px 12px; font-size: 0.85rem;" onclick="reloadFromContentful()" title="從 Contentful 重新載入所有節目數據，同步最新內容">📥 重新載入</button>
          <button class="btn" style="background: #dc3545; padding: 8px 12px; font-size: 0.85rem;" onclick="forceReloadFromContentful()" title="強制清空本地數據，完全從 Contentful 重新載入">🔄 強制重新載入</button>
          <button class="btn" style="background: #17a2b8; padding: 8px 12px; font-size: 0.85rem;" onclick="syncAllToContentful()" title="將本地節目數據同步上傳到 Contentful">🔄 同步</button>
          <button class="btn" style="background: #dc3545; padding: 8px 12px; font-size: 0.85rem;" onclick="uploadSelectedPrograms()" title="上架選中的節目到 Contentful">📺 上架</button>
          <button class="btn" style="background: #ffc107; padding: 8px 12px; font-size: 0.85rem;" onclick="showBatchEditDialog()" title="批次修改已上架節目的分類、主題等資訊">✏️ 批次修改</button>
          <button class="btn" style="background: #6f42c1; padding: 8px 12px; font-size: 0.85rem;" onclick="showAllVideos()" title="查看所有影片：顯示 Contentful 中的所有影片資料">🎬 查看所有影片</button>
        </div>
        
        <!-- 工具按鈕 -->
        <div class="tool-actions" style="display: flex; gap: 8px; flex-wrap: wrap;">
          <button class="btn" style="background: #6c757d; padding: 8px 12px; font-size: 0.85rem;" onclick="checkContentfulContentTypes()" title="檢查 Contentful 內容類型和欄位設定">🔍 檢查</button>
        <button class="btn" style="background: #dc3545; padding: 8px 12px; font-size: 0.85rem;" onclick="cleanupOldContentfulData()" title="清理 Contentful 中的舊節目數據（30天前）">🗑️ 清理舊數據</button>
        <button class="btn" style="background: #17a2b8; padding: 8px 12px; font-size: 0.85rem;" onclick="showContentfulStats()" title="查看 Contentful 數據統計和存儲使用情況">📊 數據統計</button>
          <button class="btn" style="background: #6f42c1; padding: 8px 12px; font-size: 0.85rem;" onclick="goToDashboard()" title="前往主控台查看系統狀態">🏠 主控台</button>
          <button class="btn" style="background: #ff6b6b; padding: 8px 12px; font-size: 0.85rem;" onclick="clearAllDialogs()" title="緊急清理：移除所有對話框和遮罩層">🚨 緊急清理</button>
          <button class="btn" style="background: #28a745; padding: 8px 12px; font-size: 0.85rem;" onclick="recoverMissingPrograms()" title="恢復消失的節目：從 Contentful 重新載入數據">🔄 恢復節目</button>
          <button class="btn" style="background: #17a2b8; padding: 8px 12px; font-size: 0.85rem;" onclick="diagnoseToday1730()" title="診斷今日 17:30 的節目">🔍 診斷 17:30</button>
          <button class="btn" style="background: #fd7e14; padding: 8px 12px; font-size: 0.85rem;" onclick="diagnoseToday1630()" title="診斷今日 16:30 的節目">🔍 診斷 16:30</button>
          <button class="btn" style="background: #28a745; padding: 8px 12px; font-size: 0.85rem;" onclick="createMissing1630Program()" title="如果 16:30 節目不存在，創建一個新的">➕ 創建 16:30</button>
        </div>
      </div>
    </div>

    <div class="view active" id="monthView">
      <div class="calendar-grid">
        <div class="calendar-header">
          <div>星期日</div><div>星期一</div><div>星期二</div><div>星期三</div>
          <div>星期四</div><div>星期五</div><div>星期六</div>
        </div>
        <div class="calendar-body" id="monthCalendarBody"></div>
      </div>
    </div>

    <div class="view" id="weekView">
      <div class="calendar-grid">
        <div class="calendar-header" id="weekHeader">
          <div>時間</div><div>星期日</div><div>星期一</div><div>星期二</div>
          <div>星期三</div><div>星期四</div><div>星期五</div><div>星期六</div>
        </div>
        <div class="calendar-body" id="weekCalendarBody"></div>
      </div>
    </div>

    <div class="view" id="dayView">
      <div class="calendar-grid">
        <div class="calendar-header" id="dayHeader">
          <div>時間</div><div>節目安排</div>
        </div>
        <div class="calendar-body" id="dayCalendarBody"></div>
      </div>
    </div>
  </div>

  <!-- 時間槽選擇器模態框 -->
  <div class="modal" id="timeSlotModal">
    <div class="modal-content" style="max-width: 800px;">
      <div class="modal-header">
        <h3>選擇播出時間</h3>
        <button class="modal-close" onclick="closeTimeSlotModal()">&times;</button>
      </div>
      <div class="time-slot-grid" id="timeSlotGrid" style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 10px; padding: 20px;">
        <!-- 時間槽將在這裡動態生成 -->
      </div>
    </div>
  </div>

  <div class="modal" id="eventModal">
    <div class="modal-content">
      <div class="modal-header">
        <div style="display: flex; align-items: center; gap: 15px; flex: 1; position: relative; z-index: 10003;">
          <h3 id="modalTitle" style="color: #333; font-weight: 600; margin: 0;">新增節目</h3>
          <!-- 從歷史複製功能暫時隱藏 -->
          <!-- <button class="btn" style="background: #6f42c1; padding: 6px 12px; font-size: 0.8rem; position: relative; z-index: 10004;" onclick="showCopyFromHistoryDialog()" title="從歷史節目中選擇時間槽進行批量複製">📚 從歷史複製</button> -->
        </div>
        <button class="modal-close" onclick="closeModal()" style="position: relative; z-index: 10005;">&times;</button>
      </div>

      <form id="eventForm">
        <input type="hidden" id="editDate">
        <input type="hidden" id="editTime">

        <div class="form-group">
          <label>播出時間：</label>
          <input type="time" id="airTime" required onchange="checkPastDateTime(); updateTimeSlotInfo()">
          <div id="timeSlotInfo" style="margin-top: 5px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-size: 0.9rem; color: #495057; display: none;">
            <span id="timeSlotName"></span>
            <span id="timeSlotDescription"></span>
          </div>
        </div>

        <div id="pastDateTimeWarning" style="display: none; background: #fff3cd; border: 1px solid #ffeaa7; color: #856404; padding: 10px; border-radius: 5px; margin: 10px 0; font-size: 0.9rem;">
          ⚠️ <strong>警告：</strong>您選擇的是過去的日期或時間，這可能會影響節目排程。請確認是否要繼續編輯。
        </div>

        <div class="form-group">
          <label>影片類型：</label>
          <select id="videoType" required onchange="toggleVideoFields()">
            <option value="">-- 選擇影片類型 --</option>
            <option value="YouTube">YouTube</option>
            <option value="MP4">MP4 檔案</option>
          </select>
        </div>

        <div class="form-group" id="youtubeIdGroup" style="display: none;">
          <label>YouTube ID：</label>
          <input type="text" id="youtubeId" placeholder="例如：dQw4w9WgXcQ" onblur="fetchYouTubeInfo()" oninput="updateThumbnailPreview(this.value.trim())">
        </div>

        <div class="form-group" id="mp4FileGroup" style="display: none;">
          <label>MP4 檔案：</label>
          <input type="file" id="mp4File" accept=".mp4" onchange="handleFileUpload()">
        </div>

        <div class="form-group">
          <label>節目標題：</label>
          <input type="text" id="title" placeholder="例如：早安世界 - 日本東京晨間漫步" required>
        </div>

        <div class="form-group">
          <label>節目時長：</label>
          <select id="duration" required>
            <option value="30" selected>30分鐘</option>
            <option value="60">60分鐘</option>
            <option value="90">90分鐘</option>
          </select>
        </div>

        <div class="form-group">
          <label>節目分類：</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <select id="category" required style="flex: 1;">
            <option value="">-- 選擇分類 --</option>
            <option value="亞洲">亞洲</option>
            <option value="歐洲">歐洲</option>
            <option value="北美洲">北美洲</option>
            <option value="南美洲">南美洲</option>
            <option value="非洲">非洲</option>
            <option value="大洋洲">大洋洲</option>
            <option value="南極洲">南極洲</option>
          </select>
            <button type="button" onclick="autoClassifyFromTitle()" 
                    style="background: #28a745; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; white-space: nowrap;">
              🤖 自動分類
            </button>
          </div>
          <small style="color: #666; margin-top: 5px; display: block;">
            點擊「自動分類」按鈕可根據標題和描述自動判斷所屬洲別
          </small>
        </div>

        <div class="form-group">
          <label>主題探索分類：</label>
          <div id="topicsCheckboxes" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px; margin-top: 12px;">
            <!-- 主題勾選框將由 JavaScript 動態載入 -->
          </div>
          <small style="color: #666; margin-top: 5px; display: block;">可選擇多個主題，節目將出現在對應的主題探索頁面中</small>
        </div>

        <div class="form-group">
          <label>節目描述：</label>
          <div style="display: flex; gap: 10px; align-items: flex-start;">
            <textarea id="description" placeholder="簡短描述節目內容..." style="flex: 1; min-height: 80px;"></textarea>
            <div style="display: flex; flex-direction: column; gap: 5px;">
               <button type="button" onclick="openYouTubePage()" 
                       style="background: #dc3545; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; white-space: nowrap;">
                 🔗 開啟 YouTube 頁面
               </button>
               <button type="button" onclick="autoExtractDescription()" 
                       style="background: #28a745; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; white-space: nowrap;">
                 🤖 自動擷取描述
               </button>
               <button type="button" onclick="pasteFromClipboard()" 
                       style="background: #6f42c1; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; white-space: nowrap;">
                 📋 貼上剪貼簿內容
               </button>
            </div>
          </div>
          <small style="color: #666; margin-top: 5px; display: block;">
            <span style="color: #28a745; font-weight: bold;">🤖 自動擷取：</span>輸入 YouTube ID 後點擊「🤖 自動擷取描述」即可自動獲取描述文字<br>
            <span style="color: #007bff; font-weight: bold;">✨ 智能處理：</span>系統會自動提取觀看次數、日期和標籤信息並添加到描述開頭
          </small>
        </div>


        <div class="form-group" style="background: #f8f9fa; padding: 15px; border-radius: 8px; border: 2px solid #007bff;">
          <label style="color: #007bff; font-weight: bold;">🎬 節目縮圖：</label>
          <div style="display: flex; gap: 15px; align-items: center; margin-top: 10px;">
            <img id="thumbnailPreview" src="https://images.unsplash.com/photo-1485846234645-a62644f84728?w=200&h=112&fit=crop" 
                 style="width: 200px; height: 112px; object-fit: cover; border: 2px solid #007bff; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
            <div style="display: flex; flex-direction: column; gap: 10px;">
              <input type="file" id="thumbnailFile" accept="image/*" onchange="previewThumbnail()" 
                     style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white;">
              <button type="button" onclick="resetThumbnail()" 
                      style="background: #6c757d; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold;">
                🔄 重置為 YouTube 縮圖
              </button>
            </div>
          </div>
          <div style="margin-top: 10px; font-size: 12px; color: #666;">
            💡 提示：輸入 YouTube ID 後會自動顯示縮圖，也可以上傳自訂縮圖
          </div>
        </div>

        <div class="form-group">
          <label>節目狀態：</label>
          <select id="status" required>
            <option value="重播">重播</option>
            <option value="首播">首播</option>
            <option value="特別節目">特別節目</option>
          </select>
        </div>

        <!-- 節目播出歷史 -->
        <div id="broadcastHistory" style="margin-bottom: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; display: none;">
          <h4 style="margin: 0 0 10px 0; color: #333;">📺 播出歷史</h4>
          <div id="broadcastHistoryList" style="color: #666; font-size: 0.9rem;">
            <!-- 播出歷史將在這裡動態載入 -->
          </div>
        </div>

        <!-- 精選狀態顯示 -->
        <div id="featuredStatus" style="margin-bottom: 15px; padding: 10px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; display: none;">
          <div style="display: flex; align-items: center; gap: 10px;">
            <span style="color: #856404; font-weight: bold;">⭐ 此節目已設為精選節目推薦</span>
            <button type="button" class="btn" style="background: #dc3545; color: white; padding: 4px 8px; font-size: 0.8rem;" onclick="toggleFeaturedFromEdit(false)">取消精選</button>
          </div>
        </div>

        <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
          <button type="submit" class="btn">💾 儲存節目</button>
          <button type="button" class="btn" style="background: #17a2b8;" onclick="copyAndPublish()">📋 複製上架</button>
          <button type="button" class="btn" style="background: #ffc107; color: #000;" onclick="checkSystemStatus()">🔍 檢查系統狀態</button>
          <button type="button" class="btn" style="background: #6f42c1; color: white;" onclick="toggleFeaturedFromEdit(true)" id="setFeaturedBtn">⭐ 設為精選</button>
        </div>
        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
          <button type="button" class="btn btn-danger" onclick="deleteEvent()">🗑️ 刪除節目</button>
          <button type="button" class="btn btn-secondary" onclick="closeModal()">❌ 取消</button>
        </div>
      </form>
    </div>
  </div>

  <div class="status-bar" id="statusBar">
    <span id="statusMessage"></span>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/contentful@latest/dist/contentful.browser.min.js"></script>
  <script src="browser-config.js"></script>
  <script>
    // 強力載入 Management SDK
    function loadManagementSDK() {
      return new Promise((resolve, reject) => {
        // 檢查是否已經載入
        if (typeof contentfulManagement !== 'undefined') {
          console.log('✅ Management SDK 已載入');
          window.contentfulManagement = contentfulManagement;
          resolve();
          return;
        }

        // 嘗試多個 CDN 源（使用固定版本號以提高穩定性）
        const cdnSources = [
          'https://cdn.jsdelivr.net/npm/contentful-management@10.0.0/dist/contentful-management.browser.min.js',
          'https://unpkg.com/contentful-management@10.0.0/dist/contentful-management.browser.min.js',
          'https://cdnjs.cloudflare.com/ajax/libs/contentful-management/10.0.0/contentful-management.browser.min.js',
          'https://cdn.jsdelivr.net/npm/contentful-management@9.0.0/dist/contentful-management.browser.min.js',
          'https://unpkg.com/contentful-management@9.0.0/dist/contentful-management.browser.min.js'
        ];

        let currentIndex = 0;

        function tryNextCDN() {
          if (currentIndex >= cdnSources.length) {
            reject(new Error('所有 CDN 源都載入失敗'));
            return;
          }

          const script = document.createElement('script');
          script.src = cdnSources[currentIndex];
          
          script.onload = function() {
            // 等待一下讓腳本執行
            setTimeout(() => {
              if (typeof contentfulManagement !== 'undefined') {
                console.log(`✅ Management SDK 從 CDN ${currentIndex + 1} 載入成功`);
                window.contentfulManagement = contentfulManagement;
                resolve();
              } else {
                console.log(`❌ CDN ${currentIndex + 1} 載入失敗，嘗試下一個...`);
                currentIndex++;
                tryNextCDN();
              }
            }, 100);
          };

          script.onerror = function() {
            console.log(`❌ CDN ${currentIndex + 1} 載入失敗，嘗試下一個...`);
            currentIndex++;
            tryNextCDN();
          };

          document.head.appendChild(script);
        }

        tryNextCDN();
      });
    }

    // 確保 Contentful SDK 載入完成
    if (typeof contentful !== 'undefined') {
      console.log('✅ Contentful SDK 已載入');
    } else {
      console.error('❌ Contentful SDK 載入失敗');
    }
    
    // 載入 Management SDK
    loadManagementSDK()
      .then(() => {
        console.log('✅ Management SDK 載入完成');
      })
      .catch((error) => {
        console.error('❌ Management SDK 載入失敗:', error);
        console.log('❌ 所有 CDN 源都載入失敗，請檢查網路連線');
      });
  </script>
  <script src="contentful-real-only.js"></script>
  <script>
    // 監聽 Management SDK 載入事件
    window.addEventListener('contentfulManagementLoaded', function() {
      console.log('✅ Management SDK 載入完成事件觸發');
    });
    
    window.addEventListener('contentfulManagementFailed', function() {
      console.error('❌ Management SDK 載入失敗事件觸發');
    });
    
    // 確保 ContentfulRealOnly 系統載入完成
    setTimeout(() => {
      if (window.contentfulRealOnly) {
        console.log('✅ ContentfulRealOnly 系統已載入');
      } else {
        console.error('❌ ContentfulRealOnly 系統載入失敗');
      }
    }, 1000);
  </script>
  <script>
    let currentDate = new Date();
    let currentView = 'month';
    let events = {};

    // 實時時間更新功能
    function updateCurrentTime() {
      const now = new Date();
      // 直接使用當前時間，假設系統時間已經是台灣時間
      
      const year = now.getFullYear();
      const month = now.getMonth() + 1;
      const date = now.getDate();
      const dayNames = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
      const dayName = dayNames[now.getDay()];
      const hours = now.getHours().toString().padStart(2, '0');
      const minutes = now.getMinutes().toString().padStart(2, '0');
      const seconds = now.getSeconds().toString().padStart(2, '0');
      
      const timeString = `${year}年${month}月${date}日 ${dayName} ${hours}:${minutes}:${seconds}`;
      
      const currentTimeElement = document.getElementById('currentTimeText');
      if (currentTimeElement) {
        currentTimeElement.textContent = timeString;
      }
    }

    // 啟動實時時間更新
    function startTimeUpdates() {
      updateCurrentTime(); // 立即更新一次
      setInterval(updateCurrentTime, 1000); // 每秒更新
    }

    // 主題探索分類資料
    const TOPICS_DATA = [
      {
        id: 'city-secrets',
        title: '城市秘境',
        description: '深入城市角落、市集、文化景點，用實地體驗呈現城市故事'
      },
      {
        id: 'taste-journal',
        title: '味覺日誌',
        description: '品嘗當地料理與街頭小吃，訪問餐廳老闆或廚師，分享食物背後的故事'
      },
      {
        id: 'travel-talk',
        title: '旅途談',
        description: '邀請旅遊達人、部落客、在地人，分享旅行心得、技巧與趣聞'
      },
      {
        id: 'around-world',
        title: '繞著地球跑',
        description: '走訪小鎮或鄉村，介紹當地文化、手作工藝、市場與特色美食'
      },
      {
        id: 'food-talk',
        title: '食話實說',
        description: '討論特定食材、料理或美食文化，結合討論與實地示範'
      },
      {
        id: 'play-fun',
        title: '玩樂FUN',
        description: '專為家庭設計，探索適合親子活動的景點、遊樂園、動物園'
      },
      {
        id: 'time-walk',
        title: '時光漫遊',
        description: '走訪古蹟、博物館、傳統村落，透過歷史故事呈現深度文化旅程'
      },
      {
        id: 'nature-secrets',
        title: '自然秘境',
        description: '探索自然景觀、野生動植物、生態保育，感受地球之美'
      }
    ];

    // 載入主題探索分類
    function loadTopics() {
      const container = document.getElementById('topicsCheckboxes');
      if (!container) return;

      container.innerHTML = TOPICS_DATA.map(topic => `
        <label style="display: flex; align-items: center; gap: 8px; padding: 8px; border: 1px solid #ddd; border-radius: 6px; cursor: pointer; transition: all 0.2s ease;">
          <input type="checkbox" name="topics" value="${topic.id}" style="margin: 0;">
          <div>
            <div style="font-weight: 600; font-size: 14px;">${topic.title}</div>
            <div style="font-size: 12px; color: #666; margin-top: 2px;">${topic.description}</div>
          </div>
        </label>
      `).join('');
    }

    document.addEventListener('DOMContentLoaded', function() {
      loadEvents();
      renderCurrentView();
      updateCurrentDateDisplay();
      loadTopics();
      startTimeUpdates(); // 啟動實時時間更新
      
      // 每 30 秒自動從 Contentful 刷新數據，確保多人協作時數據同步
      setInterval(() => {
        console.log('🔄 自動刷新 Contentful 數據...');
        loadEvents();
      }, 30000);
      
      // 檢查清理提醒（延遲3秒執行，避免影響主要功能）
      setTimeout(() => {
        checkCleanupReminder();
      }, 3000);
      
      // 檢查重複時間槽（延遲5秒執行）
      setTimeout(() => {
        checkDuplicateTimeSlots();
      }, 5000);
      
      // 添加全局 Escape 鍵處理器用於緊急清理
      document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
          // 檢查是否有對話框存在
          const hasDialogs = document.querySelectorAll('div[style*="position: fixed"][style*="z-index: 10000"], div[style*="background: rgba(0,0,0"]').length > 0;
          if (hasDialogs) {
            console.log('🚨 Escape 鍵觸發緊急清理');
            clearAllDialogs();
            event.preventDefault();
          }
        }
      });
    });

    function switchView(view) {
      currentView = view;

      document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');

      document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
      document.getElementById(view + 'View').classList.add('active');

      renderCurrentView();
    }

    function renderCurrentView() {
      switch(currentView) {
        case 'month': renderMonthView(); break;
        case 'week': renderWeekView(); break;
        case 'day': renderDayView(); break;
      }
    }

    function renderMonthView() {
      const year = currentDate.getFullYear();
      const month = currentDate.getMonth();
      const firstDay = new Date(year, month, 1);
      const startDate = new Date(firstDay);
      startDate.setDate(startDate.getDate() - firstDay.getDay());

      const today = new Date();
      const todayStart = new Date(today);
      todayStart.setHours(0, 0, 0, 0);

      const calendarBody = document.getElementById('monthCalendarBody');
      calendarBody.innerHTML = '';

      for (let week = 0; week < 6; week++) {
        for (let day = 0; day < 7; day++) {
          const currentDay = new Date(startDate);
          currentDay.setDate(startDate.getDate() + week * 7 + day);

          const isCurrentMonth = currentDay.getMonth() === month;
          const isToday = currentDay.toDateString() === today.toDateString();
          const isPastDate = currentDay < todayStart;
          const dateString = currentDay.getFullYear() + '-' +
                           String(currentDay.getMonth() + 1).padStart(2, '0') + '-' +
                           String(currentDay.getDate()).padStart(2, '0');

          const dayElement = document.createElement('div');
          dayElement.className = `calendar-day ${!isCurrentMonth ? 'other-month' : ''} ${isToday ? 'today' : ''} ${isPastDate ? 'past-date' : ''}`;
          dayElement.setAttribute('data-date', dateString);

          const dayEvents = getDayEvents(dateString);
          const eventCount = dayEvents.length;

          dayElement.innerHTML = `
            <div class="day-number">${currentDay.getDate()}</div>
            ${eventCount > 0 ? `<div class="event-count-badge">${eventCount}</div>` : ''}
            <div class="day-events" id="events-${dateString}">
              ${getDayEventsHTML(dateString)}
            </div>
          `;

          // 移除過去日期的限制，所有日期都可以點擊編輯
            dayElement.style.cursor = 'pointer';
            dayElement.addEventListener('click', function() {
              openTimeSlotSelector(dateString);
            });

          calendarBody.appendChild(dayElement);
        }
      }
    }

    function renderWeekView() {
      const today = new Date();
      const currentHour = today.getHours();
      const currentMinute = today.getMinutes();
      const currentTimeSlot = `${currentHour.toString().padStart(2, '0')}:${Math.floor(currentMinute / 30) * 30 === 0 ? '00' : '30'}`;

      const weekStart = new Date(currentDate);
      weekStart.setDate(currentDate.getDate() - currentDate.getDay());

      const weekHeader = document.getElementById('weekHeader');
      const dayNames = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
      weekHeader.innerHTML = '';

      const timeHeader = document.createElement('div');
      timeHeader.textContent = '時間';
      timeHeader.style.display = 'flex';
      timeHeader.style.alignItems = 'center';
      timeHeader.style.justifyContent = 'center';
      weekHeader.appendChild(timeHeader);

      for (let i = 0; i < 7; i++) {
        const currentDay = new Date(weekStart);
        currentDay.setDate(weekStart.getDate() + i);
        const isToday = currentDay.toDateString() === today.toDateString();

        const headerCell = document.createElement('div');
        headerCell.innerHTML = `
          <div style="font-weight: 600; margin-bottom: 2px;">${dayNames[i]}</div>
          <div style="font-size: 0.9rem; opacity: 0.9; ${isToday ? 'color: #ffc107; font-weight: 600;' : ''}">
            ${currentDay.getMonth() + 1}/${currentDay.getDate()}
          </div>
        `;
        weekHeader.appendChild(headerCell);
      }

      const calendarBody = document.getElementById('weekCalendarBody');
      calendarBody.innerHTML = '';

      const timeSlots = [];
      for (let hour = 0; hour < 24; hour++) {
        for (let minute = 0; minute < 60; minute += 30) {
          const timeString = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
          timeSlots.push(timeString);
        }
      }

      timeSlots.forEach(timeSlot => {
        const row = document.createElement('div');
        row.className = 'week-row';

        const timeCell = document.createElement('div');
        timeCell.className = 'time-cell';
        timeCell.style.cssText = `
          padding: 4px 6px;
          border-right: 1px solid #eee;
          background-color: #f8f9fa;
          font-size: 0.75rem;
          font-weight: 600;
          display: flex;
          align-items: center;
          justify-content: center;
          min-width: 80px;
          max-width: 80px;
          box-sizing: border-box;
        `;
        timeCell.textContent = timeSlot;

        const hour = parseInt(timeSlot.split(':')[0]);
        const minute = parseInt(timeSlot.split(':')[1]);
        // 移除過去時間的樣式限制，所有時間都可以編輯

        if (timeSlot === currentTimeSlot && today.toDateString() === currentDate.toDateString()) {
          timeCell.style.color = '#2b71d2';
          timeCell.style.fontWeight = '700';
          timeCell.style.borderLeft = '3px solid #2b71d2';
        }

        row.appendChild(timeCell);

        for (let day = 0; day < 7; day++) {
          const currentDay = new Date(weekStart);
          currentDay.setDate(weekStart.getDate() + day);
          const dateString = currentDay.getFullYear() + '-' +
                           String(currentDay.getMonth() + 1).padStart(2, '0') + '-' +
                           String(currentDay.getDate()).padStart(2, '0');
          const isToday = currentDay.toDateString() === today.toDateString();

          const dayCell = document.createElement('div');
          dayCell.className = 'day-cell';
          dayCell.style.cssText = `
            padding: 2px;
            border-right: 1px solid #eee;
            min-height: 30px;
            max-height: 60px;
            overflow: hidden;
            position: relative;
            background: white;
          `;

          if (timeSlot === '00:00') {
            const dateLabel = document.createElement('div');
            dateLabel.style.cssText = `
              position: absolute;
              top: 2px;
              left: 2px;
              font-size: 0.7rem;
              font-weight: 600;
              color: ${isToday ? '#ffc107' : '#666'};
              background: ${isToday ? 'rgba(255, 193, 7, 0.1)' : 'rgba(0, 0, 0, 0.05)'};
              padding: 1px 4px;
              border-radius: 3px;
              z-index: 1;
            `;
            dateLabel.textContent = `${currentDay.getMonth() + 1}/${currentDay.getDate()}`;
            dayCell.appendChild(dateLabel);
          }

          // 移除過去日期和時間的限制，所有日期和時間都可以點擊編輯
            dayCell.style.cursor = 'pointer';
            dayCell.addEventListener('click', function() {
              openEventModal(dateString, timeSlot);
            });

          const events = getDayEvents(dateString);
          const timeSlotEvents = events.filter(event => event.time === timeSlot);

          timeSlotEvents.forEach(event => {
            const eventDiv = document.createElement('div');
            eventDiv.className = `event ${event.status === '首播' ? 'first-air' : ''} ${isPrimeTime(hour) ? 'prime-time' : ''}`;
            eventDiv.style.cssText = `
              font-size: 0.7rem;
              padding: 2px 4px;
              margin: 1px 0;
              border-radius: 3px;
              overflow: hidden;
              text-overflow: ellipsis;
              white-space: nowrap;
              max-width: 100%;
              position: relative;
              transition: all 0.2s ease;
              cursor: pointer;
            `;

            const maxLength = 25;
            const displayTitle = event.title.length > maxLength ?
              event.title.substring(0, maxLength) + '...' : event.title;
            eventDiv.textContent = displayTitle;

            if (event.title.length > maxLength || event.description) {
              const tooltip = document.createElement('div');
              tooltip.className = 'event-tooltip';
              tooltip.style.cssText = `
                position: absolute;
                background: rgba(0,0,0,0.9);
                color: white;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 0.8rem;
                z-index: 1000;
                pointer-events: none;
                opacity: 0;
                transition: opacity 0.3s ease;
                max-width: 300px;
                word-wrap: break-word;
                white-space: normal;
                top: 100%;
                left: 0;
                margin-top: 5px;
              `;

              let tooltipContent = `<strong>${event.title}</strong>`;
              if (event.description) {
                tooltipContent += `<br><small>${event.description}</small>`;
              }
              tooltipContent += `<br><small>${event.time} | ${event.category} | ${event.duration}分鐘</small>`;
              tooltip.innerHTML = tooltipContent;

              eventDiv.appendChild(tooltip);

              eventDiv.addEventListener('mouseenter', function() {
                tooltip.style.opacity = '1';
              });

              eventDiv.addEventListener('mouseleave', function() {
                tooltip.style.opacity = '0';
              });
            }

            eventDiv.addEventListener('click', function(e) {
              e.stopPropagation();
              openEventModal(dateString, timeSlot);
            });

            dayCell.appendChild(eventDiv);
          });

          if (timeSlotEvents.length === 0) {
            const emptyDiv = document.createElement('div');
            emptyDiv.style.cssText = `
              color: #ccc;
              font-size: 0.6rem;
              font-style: italic;
              text-align: center;
              padding: 2px;
              opacity: 0.7;
            `;
            emptyDiv.textContent = '+';
            dayCell.appendChild(emptyDiv);
          }

          row.appendChild(dayCell);
        }

        calendarBody.appendChild(row);
      });
    }

    function renderDayView() {
      const today = new Date();
      const currentHour = today.getHours();
      const currentMinute = today.getMinutes();
      const currentTimeSlot = `${currentHour.toString().padStart(2, '0')}:${Math.floor(currentMinute / 30) * 30 === 0 ? '00' : '30'}`;
      const dateString = currentDate.getFullYear() + '-' +
                       String(currentDate.getMonth() + 1).padStart(2, '0') + '-' +
                       String(currentDate.getDate()).padStart(2, '0');
      const isToday = currentDate.toDateString() === today.toDateString();

      const dayHeader = document.getElementById('dayHeader');
      const dayNames = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
      const dayOfWeek = currentDate.getDay();

      dayHeader.innerHTML = `
        <div>時間</div>
        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center;">
          <div style="font-weight: 600; margin-bottom: 2px;">節目安排</div>
          <div style="font-size: 0.9rem; opacity: 0.9; ${isToday ? 'color: #ffc107; font-weight: 600;' : ''}">
            ${currentDate.getFullYear()}年${currentDate.getMonth() + 1}月${currentDate.getDate()}日 ${dayNames[dayOfWeek]}
          </div>
        </div>
      `;

      const calendarBody = document.getElementById('dayCalendarBody');
      calendarBody.innerHTML = '';

      const timeSlots = [];
      for (let hour = 0; hour < 24; hour++) {
        for (let minute = 0; minute < 60; minute += 30) {
          const timeString = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
          timeSlots.push(timeString);
        }
      }

      timeSlots.forEach(timeSlot => {
        const row = document.createElement('div');
        row.className = 'day-row';

        const timeCell = document.createElement('div');
        timeCell.className = 'time-cell';
        timeCell.style.cssText = `
          padding: 12px 8px;
          border-right: 1px solid #eee;
          background-color: #f8f9fa;
          font-size: 0.9rem;
          font-weight: 600;
          display: flex;
          align-items: center;
          justify-content: center;
          min-width: 80px;
        `;
        timeCell.textContent = timeSlot;

        const hour = parseInt(timeSlot.split(':')[0]);
        const minute = parseInt(timeSlot.split(':')[1]);
        
        // 標示當前時間
        if (timeSlot === currentTimeSlot && isToday) {
          timeCell.style.color = '#2b71d2';
          timeCell.style.fontWeight = '700';
          timeCell.style.borderLeft = '3px solid #2b71d2';
          timeCell.style.backgroundColor = '#e3f2fd';
        }

        row.appendChild(timeCell);

        const eventCell = document.createElement('div');
        eventCell.className = 'event-cell';
        eventCell.style.cssText = `
          padding: 8px;
          position: relative;
          min-height: 60px;
          display: flex;
          align-items: center;
        `;

        // 標示當前時間的事件單元格
        if (timeSlot === currentTimeSlot && isToday) {
          eventCell.style.backgroundColor = '#e3f2fd';
          eventCell.style.borderLeft = '3px solid #2b71d2';
        }

        // 移除過去時間的樣式限制，所有時間都可以點擊編輯
          eventCell.style.cursor = 'pointer';
          eventCell.addEventListener('click', function() {
            openEventModal(dateString, timeSlot);
          });

        const events = getDayEvents(dateString);
        const timeSlotEvents = events.filter(event => event.time === timeSlot);

        if (timeSlotEvents.length > 0) {
          timeSlotEvents.forEach(event => {
            const eventDiv = document.createElement('div');
            eventDiv.className = `event ${event.status === '首播' ? 'first-air' : ''} ${isPrimeTime(hour) ? 'prime-time' : ''}`;
            eventDiv.style.cssText = `
              padding: 8px;
              margin: 4px 0;
              border-radius: 6px;
              font-size: 0.9rem;
              font-weight: 500;
              background: #e8f5e8;
              border: 1px solid #4caf50;
              width: 100%;
              box-sizing: border-box;
              word-wrap: break-word;
              overflow-wrap: break-word;
            `;

            eventDiv.innerHTML = `
              <div style="font-weight: 600; margin-bottom: 4px; word-break: break-word;">${event.title}</div>
              <div style="font-size: 0.8rem; color: #666;">
                <span style="background: ${event.status === '首播' ? '#ffc107' : '#28a745'}; color: white; padding: 2px 6px; border-radius: 3px; margin-right: 8px;">
                  ${event.status}
                </span>
                <span>${event.category}</span>
                <span style="margin-left: 8px;">${event.duration}分鐘</span>
              </div>
              ${event.description ? `<div style="color: #666; font-size: 0.8rem; color: #666; margin-top: 4px; word-break: break-word;">${event.description}</div>` : ''}
            `;

            eventCell.appendChild(eventDiv);
          });
        } else {
          const emptyDiv = document.createElement('div');
          emptyDiv.style.cssText = `
            color: #999;
            font-size: 0.8rem;
            font-style: italic;
            width: 100%;
            text-align: center;
          `;
          emptyDiv.textContent = '點擊新增節目';
          eventCell.appendChild(emptyDiv);
        }

        row.appendChild(eventCell);
        calendarBody.appendChild(row);
      });
    }

    function getDayEvents(dateString) {
      // 直接從 Contentful 讀取，不使用本地緩存
      return events[dateString] || [];
    }

    // 獲取特定日期和時間的節目
    function getEvent(date, time) {
      const dayEvents = events[date] || [];
      console.log(`🔍 getEvent(${date}, ${time}):`, {
        dayEventsCount: dayEvents.length,
        dayEvents: dayEvents.map(e => ({ time: e.time, title: e.title, topics: e.topics }))
      });
      const foundEvent = dayEvents.find(event => event.time === time);
      console.log(`🔍 找到的節目:`, foundEvent);
      return foundEvent;
    }

    function getDayEventsHTML(dateString) {
      const dayEvents = events[dateString] || [];
      if (dayEvents.length === 0) {
        return '';
      }

      const maxVisibleEvents = 3;
      const visibleEvents = dayEvents.slice(0, maxVisibleEvents);
      const hiddenEventsCount = dayEvents.length - maxVisibleEvents;

      let html = '';

      visibleEvents.forEach(event => {
        const maxTitleLength = 20;
        const displayTitle = event.title.length > maxTitleLength ?
          event.title.substring(0, maxTitleLength) + '...' : event.title;

        html += `
          <div class="event ${event.status === '首播' ? 'first-air' : ''} ${isPrimeTime(parseInt(event.time.split(':')[0])) ? 'prime-time' : ''}"
               onclick="openEventModal('${dateString}', '${event.time}')">
            <span class="event-time-label">${event.time}</span>${displayTitle}
            ${event.title.length > maxTitleLength || event.description ? `
              <div class="event-tooltip">
                <strong>${event.title}</strong>
                ${event.description ? `<br><small>${event.description}</small>` : ''}
                <br><small>${event.time} | ${event.category} | ${event.duration}分鐘</small>
              </div>
            ` : ''}
          </div>
        `;
      });

      if (hiddenEventsCount > 0) {
        html += `
          <div class="more-events-indicator" onclick="showAllEventsForDay('${dateString}')">
            +${hiddenEventsCount} 更多節目
          </div>
        `;
      }

      return html;
    }

    function isPrimeTime(hour) {
      return hour >= 12 && hour < 18;
    }

    function previousPeriod() {
      switch(currentView) {
        case 'month': currentDate.setMonth(currentDate.getMonth() - 1); break;
        case 'week': currentDate.setDate(currentDate.getDate() - 7); break;
        case 'day': currentDate.setDate(currentDate.getDate() - 1); break;
      }
      renderCurrentView();
      updateCurrentDateDisplay();
    }

    function nextPeriod() {
      switch(currentView) {
        case 'month': currentDate.setMonth(currentDate.getMonth() + 1); break;
        case 'week': currentDate.setDate(currentDate.getDate() + 7); break;
        case 'day': currentDate.setDate(currentDate.getDate() + 1); break;
      }
      renderCurrentView();
      updateCurrentDateDisplay();
    }

    function goToToday() {
      currentDate = new Date();
      renderCurrentView();
      updateCurrentDateDisplay();
    }

    function updateCurrentDateDisplay() {
      const dateElement = document.getElementById('currentDate');
      switch(currentView) {
        case 'month':
          dateElement.textContent = `${currentDate.getFullYear()}年${currentDate.getMonth() + 1}月`;
          break;
        case 'week':
          const weekStart = new Date(currentDate);
          weekStart.setDate(currentDate.getDate() - currentDate.getDay());
          const weekEnd = new Date(weekStart);
          weekEnd.setDate(weekStart.getDate() + 6);
          dateElement.textContent = `${weekStart.getFullYear()}年${weekStart.getMonth() + 1}月${weekStart.getDate()}日 - ${weekEnd.getMonth() + 1}月${weekEnd.getDate()}日`;
          break;
        case 'day':
          dateElement.textContent = `${currentDate.getFullYear()}年${currentDate.getMonth() + 1}月${currentDate.getDate()}日`;
          break;
      }
    }

    function openEventModal(date, time = '') {
      // 移除過去日期和時間的編輯限制，允許編輯所有日期和時間

      document.getElementById('editDate').value = date;
      document.getElementById('editTime').value = time;
      document.getElementById('airTime').value = time;
      
      // 檢查是否為過去的時間並顯示警語
      setTimeout(() => {
        checkPastDateTime();
      }, 100);

      const existingEvent = getEvent(date, time);
      if (existingEvent) {
        console.log('🔍 載入現有節目資料:', existingEvent);
        console.log('🔍 節目主題資料詳情:', {
          topics: existingEvent.topics,
          topicsType: typeof existingEvent.topics,
          topicsLength: existingEvent.topics ? existingEvent.topics.length : 'N/A',
          topicsArray: Array.isArray(existingEvent.topics)
        });
        document.getElementById('modalTitle').textContent = '編輯節目';
        
        // 移除修改按鈕相關邏輯
        
        document.getElementById('title').value = existingEvent.title;
        document.getElementById('duration').value = existingEvent.duration;
        document.getElementById('category').value = existingEvent.category;
        document.getElementById('description').value = existingEvent.description;
        document.getElementById('status').value = existingEvent.status;
        document.getElementById('videoType').value = existingEvent.videoType || '';
        document.getElementById('youtubeId').value = existingEvent.youtubeId || '';
        
        // 載入縮圖資料
        const thumbnailPreview = document.getElementById('thumbnailPreview');
        if (existingEvent.thumbnail) {
          thumbnailPreview.src = existingEvent.thumbnail;
          if (existingEvent.youtubeId) {
            thumbnailPreview.setAttribute('data-youtube-url', `https://img.youtube.com/vi/${existingEvent.youtubeId}/maxresdefault.jpg`);
          }
        } else if (existingEvent.youtubeId) {
          // 如果有 YouTube ID 但沒有縮圖，生成縮圖
          const youtubeThumbnail = `https://img.youtube.com/vi/${existingEvent.youtubeId}/maxresdefault.jpg`;
          thumbnailPreview.src = youtubeThumbnail;
          thumbnailPreview.setAttribute('data-youtube-url', youtubeThumbnail);
        } else {
          // 沒有縮圖資料，使用預設
          thumbnailPreview.src = 'https://images.unsplash.com/photo-1485846234645-a62644f84728?w=200&h=112&fit=crop';
          thumbnailPreview.removeAttribute('data-youtube-url');
        }
        
        // 載入主題探索分類
        console.log('🔍 檢查主題資料:', existingEvent.topics);
        console.log('🔍 檢查節目備註內容:', existingEvent.description);
        
        // 檢查備註中是否有主題標記
        const notes = existingEvent.description || '';
        const hasTopicMarkers = notes.includes('[主題:');
        const hasCategoryMarkers = notes.includes('[分類:');
        console.log('🔍 備註標記檢查:', {
          hasTopicMarkers: hasTopicMarkers,
          hasCategoryMarkers: hasCategoryMarkers,
          notesLength: notes.length,
          notesPreview: notes.substring(0, 200)
        });
        
        // 手動從備註中提取主題，檢查是否與 existingEvent.topics 一致
        const extractedTopics = extractTopicsFromNotes(notes);
        console.log('🔍 手動提取的主題:', extractedTopics);
        console.log('🔍 existingEvent.topics:', existingEvent.topics);
        console.log('🔍 主題資料是否一致:', JSON.stringify(extractedTopics) === JSON.stringify(existingEvent.topics));
        console.log('🔍 完整的 existingEvent 物件:', existingEvent);
        console.log('🔍 備註完整內容:', notes);
        
        // 確保主題複選框已經載入
        const topicsContainer = document.getElementById('topicsCheckboxes');
        if (!topicsContainer || topicsContainer.children.length === 0) {
          console.log('⚠️ 主題複選框未載入，重新載入...');
          loadTopics();
        }
        
        // 等待一下讓 DOM 更新
        setTimeout(() => {
          // 決定使用哪個主題資料
          let topicsToLoad = existingEvent.topics;
          
          // 如果 existingEvent.topics 為空，但備註中有主題標記，使用手動提取的主題
          if ((!topicsToLoad || topicsToLoad.length === 0) && extractedTopics.length > 0) {
            console.log('🔄 使用手動提取的主題資料:', extractedTopics);
            topicsToLoad = extractedTopics;
          }
          
          if (topicsToLoad && Array.isArray(topicsToLoad) && topicsToLoad.length > 0) {
            console.log('✅ 找到主題資料，開始載入:', topicsToLoad);
            // 清除所有主題選擇
            document.querySelectorAll('input[name="topics"]').forEach(checkbox => {
              checkbox.checked = false;
            });
            
            // 選中現有的主題
            topicsToLoad.forEach(topicTitle => {
              console.log('🔍 處理主題:', topicTitle);
              // 根據主題標題找到對應的 topicId
              const topicData = TOPICS_DATA.find(topic => topic.title === topicTitle);
              if (topicData) {
                const checkbox = document.querySelector(`input[name="topics"][value="${topicData.id}"]`);
                if (checkbox) {
                  checkbox.checked = true;
                  console.log('✅ 載入主題:', topicTitle, 'ID:', topicData.id);
                } else {
                  console.log('❌ 找不到對應的複選框:', topicData.id);
                  console.log('🔍 可用的複選框:', document.querySelectorAll('input[name="topics"]'));
                }
              } else {
                console.log('⚠️ 找不到主題資料:', topicTitle);
                console.log('🔍 可用的主題資料:', TOPICS_DATA.map(t => t.title));
              }
            });
          } else {
            console.log('⚠️ 沒有主題資料或主題陣列為空');
            // 如果沒有主題資料，清除所有選擇
            document.querySelectorAll('input[name="topics"]').forEach(checkbox => {
              checkbox.checked = false;
            });
          }
        }, 100);
        
        // 清除檔案選擇（因為是編輯現有節目）
        const thumbnailFile = document.getElementById('thumbnailFile');
        if (thumbnailFile) {
          thumbnailFile.value = '';
        }
        
        toggleVideoFields();
      } else {
        document.getElementById('modalTitle').textContent = '新增節目';
        
        // 移除修改按鈕相關邏輯
        
        document.getElementById('eventForm').reset();
        document.getElementById('airTime').value = time;
        
        // 清除所有舊資料
        document.getElementById('title').value = '';
        document.getElementById('duration').value = '30';
        document.getElementById('category').value = '';
        document.getElementById('description').value = '';
        document.getElementById('status').value = '重播';
        document.getElementById('videoType').value = '';
        document.getElementById('youtubeId').value = '';
        
        // 清除縮圖預覽
        const thumbnailPreview = document.getElementById('thumbnailPreview');
        thumbnailPreview.src = 'https://images.unsplash.com/photo-1485846234645-a62644f84728?w=200&h=112&fit=crop';
        thumbnailPreview.removeAttribute('data-youtube-url');
        
        // 清除檔案選擇
        const thumbnailFile = document.getElementById('thumbnailFile');
        if (thumbnailFile) {
          thumbnailFile.value = '';
        }
        
        // 清除主題探索分類選擇
        document.querySelectorAll('input[name="topics"]').forEach(checkbox => {
          checkbox.checked = false;
        });
        
        // 隱藏影片類型相關欄位
        toggleVideoFields();
      }

      document.getElementById('eventModal').style.display = 'block';
    }

    function closeModal() {
      // 清除影片編輯狀態
      window.currentEditingVideoId = null;
      window.currentEditingVideoData = null;
      
      document.getElementById('eventModal').style.display = 'none';
    }

    // 顯示進度條
    function showProgressBar(message, percentage) {
      console.log('🎯 showProgressBar 被調用:', { message, percentage });
      
      // 移除現有的進度條
      hideProgressBar();
      
      // 創建進度條容器
      const progressDialog = document.createElement('div');
      progressDialog.id = 'saveProgressDialog';
      progressDialog.style.cssText = `
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        background: rgba(0, 0, 0, 0.8) !important;
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        z-index: 999999 !important;
        font-family: Arial, sans-serif !important;
        pointer-events: auto !important;
      `;
      
      progressDialog.innerHTML = `
        <div style="
          background: white !important;
          padding: 40px !important;
          border-radius: 20px !important;
          box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5) !important;
          max-width: 450px !important;
          width: 90% !important;
          text-align: center !important;
          border: 3px solid #4CAF50 !important;
        ">
          <h3 style="margin: 0 0 25px 0; color: #333; font-size: 20px; font-weight: bold;">💾 儲存節目</h3>
          <div style="margin-bottom: 25px;">
            <div style="
              width: 100%;
              height: 25px;
              background: #e0e0e0;
              border-radius: 12px;
              overflow: hidden;
              margin-bottom: 15px;
              border: 2px solid #ddd;
            ">
              <div id="saveProgressBar" style="
                width: ${percentage}%;
                height: 100%;
                background: linear-gradient(90deg, #4CAF50, #45a049);
                transition: width 0.5s ease;
                border-radius: 10px;
                box-shadow: 0 2px 10px rgba(76, 175, 80, 0.3);
              "></div>
            </div>
            <div id="saveProgressText" style="color: #555; font-size: 16px; font-weight: 500; margin-bottom: 8px;">${message}</div>
            <div id="saveProgressPercent" style="color: #4CAF50; font-size: 18px; font-weight: bold;">${percentage}%</div>
          </div>
          <div style="color: #888; font-size: 12px;">請稍候，正在處理中...</div>
        </div>
      `;
      
      // 強制添加到 body 並確保顯示
      document.body.appendChild(progressDialog);
      
      // 強制重繪
      progressDialog.offsetHeight;
      
      console.log('🎯 進度條已添加到 DOM，元素:', progressDialog);
      console.log('🎯 進度條樣式:', progressDialog.style.cssText);
      
      // 測試進度條是否可見
      setTimeout(() => {
        const rect = progressDialog.getBoundingClientRect();
        console.log('🎯 進度條位置和大小:', rect);
        console.log('🎯 進度條是否可見:', rect.width > 0 && rect.height > 0);
      }, 100);
    }

    // 隱藏進度條
    function hideProgressBar() {
      const existingDialog = document.getElementById('saveProgressDialog');
      if (existingDialog) {
        document.body.removeChild(existingDialog);
      }
    }

    // 測試進度條函數（可以在控制台調用）
    window.testProgressBar = function() {
      console.log('🧪 測試進度條');
      showProgressBar('測試進度條...', 50);
      
      setTimeout(() => {
        showProgressBar('測試完成！', 100);
      }, 2000);
      
      setTimeout(() => {
        hideProgressBar();
        console.log('🧪 測試完成，進度條已隱藏');
      }, 4000);
    };

    // 更新影片到 Contentful
    async function updateVideoInContentful() {
      try {
        console.log('🎬 updateVideoInContentful 函數開始執行');
        console.log('🔍 當前編輯的影片 ID:', window.currentEditingVideoId);
        
        // 顯示進度條
        console.log('🎯 準備顯示進度條');
        showProgressBar('正在儲存影片變更...', 0);
        console.log('🎯 進度條已調用');
        
        showStatus('正在儲存影片變更...', 'info');
        
        // 檢查 Management SDK
        if (typeof contentfulManagement === 'undefined') {
          console.error('❌ Management SDK 未載入');
          throw new Error('Management SDK 未載入，請先載入 Management SDK');
        }
        
        console.log('✅ Management SDK 已載入');
        
        // 更新進度條
        showProgressBar('正在連接 Contentful...', 20);
        
        // 創建 Management 客戶端
        const managementClient = contentfulManagement.createClient({
          accessToken: 'CFPAT-hNLOfw3XdP5Hf_C3eYjI8294agakAK0Yo5Ew1Mjnsqs'
        });
        
        // 獲取空間和環境
        const space = await managementClient.getSpace('os5wf90ljenp');
        const environment = await space.getEnvironment('master');
        
        // 更新進度條
        showProgressBar('正在載入影片資料...', 40);
        
        // 獲取要編輯的條目
        const entry = await environment.getEntry(window.currentEditingVideoId);
        
        // 調試：顯示現有欄位結構
        console.log('🔍 現有條目欄位結構:', Object.keys(entry.fields));
        console.log('🔍 現有條目完整資料:', entry.fields);
        console.log('🔍 內容類型:', entry.sys.contentType?.sys?.id);
        console.log('🔍 條目 ID:', entry.sys.id);
        
        // 準備更新資料
        const title = document.getElementById('title').value;
        const description = document.getElementById('description').value;
        const youtubeId = document.getElementById('youtubeId').value;
        const category = document.getElementById('category').value;
        const videoType = document.getElementById('videoType').value;
        
        // 獲取選中的主題探索分類
        const selectedTopics = [];
        document.querySelectorAll('input[name="topics"]:checked').forEach(checkbox => {
          selectedTopics.push(checkbox.value);
        });
        
        // 更新條目 - 嘗試多種可能的欄位名稱
        const updateFields = {
          ...entry.fields,
          'title': {
            'en-US': title
          },
          'description': {
            'en-US': description
          },
          'youTubeId': {
            'en-US': youtubeId
          },
          'tags': {
            'en-US': selectedTopics
          }
        };
        
        // 嘗試不同的分類欄位名稱
        console.log('🔍 檢查分類欄位存在性:');
        console.log('  - category:', !!entry.fields['category']);
        console.log('  - 節目分類:', !!entry.fields['節目分類']);
        console.log('  - 分類:', !!entry.fields['分類']);
        console.log('  - Category:', !!entry.fields['Category']);
        
        // 檢查所有可能的欄位名稱
        const allFieldNames = Object.keys(entry.fields);
        console.log('🔍 所有欄位名稱:', allFieldNames);
        
        // 尋找包含 "category" 或 "分類" 的欄位
        const categoryFields = allFieldNames.filter(name => 
          name.toLowerCase().includes('category') || 
          name.includes('分類')
        );
        console.log('🔍 找到的分類相關欄位:', categoryFields);
        
        if (entry.fields['category']) {
          console.log('✅ 使用 category 欄位');
          updateFields['category'] = { 'en-US': category };
        } else if (entry.fields['Category']) {
          console.log('✅ 使用 Category 欄位');
          updateFields['Category'] = { 'en-US': category };
        } else if (entry.fields['節目分類']) {
          console.log('✅ 使用 節目分類 欄位');
          updateFields['節目分類'] = { 'zh-TW': category };
        } else if (entry.fields['分類']) {
          console.log('✅ 使用 分類 欄位');
          updateFields['分類'] = { 'zh-TW': category };
        } else if (categoryFields.length > 0) {
          // 使用找到的第一個分類相關欄位
          const fieldName = categoryFields[0];
          console.log('✅ 使用找到的分類欄位:', fieldName);
          updateFields[fieldName] = { 'en-US': category };
        } else {
          console.log('⚠️ 未找到分類欄位，嘗試強制創建 category');
          // 嘗試強制創建 category 欄位
          updateFields['category'] = { 'en-US': category };
          showStatus('⚠️ 嘗試創建 category 欄位，如果失敗請檢查內容模型', 'warning');
        }
        
        entry.fields = updateFields;
        
        // 更新進度條
        showProgressBar('正在更新影片資料...', 70);
        
        // 如果有 MP4 檔案，也更新
        if (videoType === 'MP4') {
          const mp4File = document.getElementById('mp4File').files[0];
          if (mp4File) {
            // 這裡可以添加 MP4 檔案上傳邏輯
            entry.fields['MP4 影片網址'] = {
              'zh-TW': mp4File.name
            };
          }
        }
        
        // 更新進度條
        showProgressBar('正在儲存到 Contentful...', 85);
        
        // 儲存變更
        const updatedEntry = await entry.update();
        
        // 更新進度條
        showProgressBar('正在發布變更...', 95);
        
        await updatedEntry.publish();
        
        // 清除編輯狀態
        window.currentEditingVideoId = null;
        window.currentEditingVideoData = null;
        
        // 更新進度條
        showProgressBar('儲存完成！', 100);
        
        // 關閉模態框
        closeModal();
        
        // 重新載入影片列表
        showStatus('✅ 影片已成功更新，正在重新載入...', 'success');
        
        // 隱藏進度條
        setTimeout(() => {
          hideProgressBar();
          showAllVideos();
        }, 1000);
        
      } catch (error) {
        console.error('更新影片失敗:', error);
        hideProgressBar(); // 隱藏進度條
        showStatus(`❌ 更新影片失敗: ${error.message}`, 'error');
      }
    }

    function openTimeSlotSelector(date) {
      const today = new Date();
      const currentHour = today.getHours();
      const currentMinute = today.getMinutes();
      const todayString = today.getFullYear() + '-' +
                         String(today.getMonth() + 1).padStart(2, '0') + '-' +
                         String(today.getDate()).padStart(2, '0');
      const isToday = date === todayString;

      const timeSlotGrid = document.getElementById('timeSlotGrid');
      timeSlotGrid.innerHTML = '';

      for (let hour = 0; hour < 24; hour++) {
        for (let minute = 0; minute < 60; minute += 30) {
          const timeString = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;

          // 移除過去時間的限制，所有時間都可以選擇

          const timeSlot = document.createElement('div');
          timeSlot.className = 'time-slot-btn';
          timeSlot.style.cssText = `
            padding: 15px 10px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            background: #fff;
            color: #333;
            font-weight: 600;
            transition: all 0.3s ease;
          `;

            timeSlot.addEventListener('mouseenter', function() {
              this.style.borderColor = '#2b71d2';
              this.style.backgroundColor = '#e3f2fd';
            });

            timeSlot.addEventListener('mouseleave', function() {
              this.style.borderColor = '#e9ecef';
              this.style.backgroundColor = '#fff';
            });

            timeSlot.addEventListener('click', function() {
              openEventModal(date, timeString);
              closeTimeSlotModal();
            });

          timeSlot.textContent = timeString;
          timeSlotGrid.appendChild(timeSlot);
        }
      }

      document.getElementById('timeSlotModal').style.display = 'block';
    }

    function closeTimeSlotModal() {
      document.getElementById('timeSlotModal').style.display = 'none';
    }

    function toggleVideoFields() {
      const videoType = document.getElementById('videoType').value;
      const youtubeIdGroup = document.getElementById('youtubeIdGroup');
      const mp4FileGroup = document.getElementById('mp4FileGroup');

      youtubeIdGroup.style.display = videoType === 'YouTube' ? 'block' : 'none';
      mp4FileGroup.style.display = videoType === 'MP4' ? 'block' : 'none';
    }

    // 國家/地區到洲的對應表
    const countryToContinent = {
      // 亞洲
      '台灣': '亞洲', '中國': '亞洲', '日本': '亞洲', '韓國': '亞洲', '香港': '亞洲', '澳門': '亞洲',
      '新加坡': '亞洲', '馬來西亞': '亞洲', '泰國': '亞洲', '越南': '亞洲', '菲律賓': '亞洲',
      '印尼': '亞洲', '印度': '亞洲', '巴基斯坦': '亞洲', '孟加拉': '亞洲', '斯里蘭卡': '亞洲',
      '尼泊爾': '亞洲', '不丹': '亞洲', '緬甸': '亞洲', '柬埔寨': '亞洲', '寮國': '亞洲',
      '蒙古': '亞洲', '哈薩克': '亞洲', '烏茲別克': '亞洲', '吉爾吉斯': '亞洲', '塔吉克': '亞洲',
      '土庫曼': '亞洲', '阿富汗': '亞洲', '伊朗': '亞洲', '伊拉克': '亞洲', '以色列': '亞洲',
      '約旦': '亞洲', '黎巴嫩': '亞洲', '敘利亞': '亞洲', '土耳其': '亞洲', '沙烏地阿拉伯': '亞洲',
      '阿聯酋': '亞洲', '卡達': '亞洲', '科威特': '亞洲', '巴林': '亞洲', '阿曼': '亞洲',
      '葉門': '亞洲', '亞美尼亞': '亞洲', '亞塞拜然': '亞洲', '喬治亞': '亞洲',
      
      // 亞洲英文名稱
      'China': '亞洲', 'Japan': '亞洲', 'Korea': '亞洲', 'South Korea': '亞洲', 'North Korea': '亞洲',
      'Taiwan': '亞洲', 'Hong Kong': '亞洲', 'Macau': '亞洲', 'Mongolia': '亞洲', 'India': '亞洲',
      'Pakistan': '亞洲', 'Bangladesh': '亞洲', 'Sri Lanka': '亞洲', 'Nepal': '亞洲', 'Bhutan': '亞洲',
      'Maldives': '亞洲', 'Myanmar': '亞洲', 'Thailand': '亞洲', 'Laos': '亞洲', 'Cambodia': '亞洲',
      'Vietnam': '亞洲', 'Malaysia': '亞洲', 'Singapore': '亞洲', 'Indonesia': '亞洲', 'Philippines': '亞洲',
      'Brunei': '亞洲', 'East Timor': '亞洲', 'Kazakhstan': '亞洲', 'Uzbekistan': '亞洲', 'Turkmenistan': '亞洲',
      'Afghanistan': '亞洲', 'Iran': '亞洲', 'Iraq': '亞洲', 'Israel': '亞洲', 'Jordan': '亞洲',
      'Lebanon': '亞洲', 'Syria': '亞洲', 'Turkey': '亞洲', 'Saudi Arabia': '亞洲', 'UAE': '亞洲',
      'Qatar': '亞洲', 'Kuwait': '亞洲', 'Bahrain': '亞洲', 'Oman': '亞洲', 'Yemen': '亞洲',
      'Armenia': '亞洲', 'Azerbaijan': '亞洲', 'Georgia': '亞洲',
      
      // 歐洲
      '英國': '歐洲', 'France': '歐洲', '德國': '歐洲', '義大利': '歐洲', 'Italy': '歐洲', '西班牙': '歐洲',
      '荷蘭': '歐洲', '比利時': '歐洲', '瑞士': '歐洲', '奧地利': '歐洲', '瑞典': '歐洲',
      '挪威': '歐洲', '丹麥': '歐洲', '芬蘭': '歐洲', '冰島': '歐洲', '愛爾蘭': '歐洲',
      '葡萄牙': '歐洲', '希臘': '歐洲', '波蘭': '歐洲', '捷克': '歐洲', '匈牙利': '歐洲',
      '羅馬尼亞': '歐洲', '保加利亞': '歐洲', '克羅埃西亞': '歐洲', '塞爾維亞': '歐洲',
      '斯洛維尼亞': '歐洲', '斯洛伐克': '歐洲', '立陶宛': '歐洲', '拉脫維亞': '歐洲',
      '愛沙尼亞': '歐洲', '烏克蘭': '歐洲', '白俄羅斯': '歐洲', '俄羅斯': '歐洲',
      
      // 歐洲英文名稱
      'United Kingdom': '歐洲', 'UK': '歐洲', 'England': '歐洲', 'Scotland': '歐洲', 'Wales': '歐洲',
      'Germany': '歐洲', 'Spain': '歐洲', 'Netherlands': '歐洲', 'Belgium': '歐洲', 'Switzerland': '歐洲',
      'Austria': '歐洲', 'Sweden': '歐洲', 'Norway': '歐洲', 'Denmark': '歐洲', 'Finland': '歐洲',
      'Iceland': '歐洲', 'Ireland': '歐洲', 'Portugal': '歐洲', 'Greece': '歐洲', 'Poland': '歐洲',
      'Czech Republic': '歐洲', 'Czech': '歐洲', 'Hungary': '歐洲', 'Romania': '歐洲', 'Bulgaria': '歐洲',
      'Croatia': '歐洲', 'Serbia': '歐洲', 'Slovenia': '歐洲', 'Slovakia': '歐洲', 'Lithuania': '歐洲',
      'Latvia': '歐洲', 'Estonia': '歐洲', 'Ukraine': '歐洲', 'Belarus': '歐洲', 'Russia': '歐洲',
      
      // 北美洲
      '美國': '北美洲', 'Canada': '北美洲', '墨西哥': '北美洲', '古巴': '北美洲',
      '牙買加': '北美洲', '巴哈馬': '北美洲', '多明尼加': '北美洲', '海地': '北美洲',
      '瓜地馬拉': '北美洲', '貝里斯': '北美洲', '薩爾瓦多': '北美洲', '宏都拉斯': '北美洲',
      '尼加拉瓜': '北美洲', '哥斯大黎加': '北美洲', '巴拿馬': '北美洲',
      
      // 北美洲英文名稱
      'United States': '北美洲', 'USA': '北美洲', 'US': '北美洲', 'America': '北美洲',
      'Mexico': '北美洲', 'Cuba': '北美洲', 'Jamaica': '北美洲', 'Bahamas': '北美洲',
      'Dominican Republic': '北美洲', 'Haiti': '北美洲', 'Guatemala': '北美洲', 'Belize': '北美洲',
      'El Salvador': '北美洲', 'Honduras': '北美洲', 'Nicaragua': '北美洲', 'Costa Rica': '北美洲',
      'Panama': '北美洲',
      
      // 南美洲
      '巴西': '南美洲', '阿根廷': '南美洲', '智利': '南美洲', '秘魯': '南美洲',
      '哥倫比亞': '南美洲', '委內瑞拉': '南美洲', '厄瓜多': '南美洲', '玻利維亞': '南美洲',
      '巴拉圭': '南美洲', '烏拉圭': '南美洲', '蓋亞那': '南美洲', '蘇利南': '南美洲',
      
      // 南美洲英文名稱
      'Brazil': '南美洲', 'Argentina': '南美洲', 'Chile': '南美洲', 'Peru': '南美洲',
      'Colombia': '南美洲', 'Venezuela': '南美洲', 'Ecuador': '南美洲', 'Bolivia': '南美洲',
      'Paraguay': '南美洲', 'Uruguay': '南美洲', 'Guyana': '南美洲', 'Suriname': '南美洲',
      
      // 非洲
      '埃及': '非洲', '南非': '非洲', '摩洛哥': '非洲', '阿爾及利亞': '非洲',
      '突尼西亞': '非洲', '利比亞': '非洲', '蘇丹': '非洲', '衣索比亞': '非洲',
      '肯亞': '非洲', '坦尚尼亞': '非洲', '烏干達': '非洲', '盧安達': '非洲',
      '迦納': '非洲', '奈及利亞': '非洲', '塞內加爾': '非洲', '馬利': '非洲',
      '布吉納法索': '非洲', '尼日': '非洲', '查德': '非洲', '中非': '非洲',
      '喀麥隆': '非洲', '剛果': '非洲', '剛果民主共和國': '非洲', '加彭': '非洲',
      '赤道幾內亞': '非洲', '聖多美普林西比': '非洲', '安哥拉': '非洲', '尚比亞': '非洲',
      '辛巴威': '非洲', '波札那': '非洲', '納米比亞': '非洲', '馬達加斯加': '非洲',
      '模里西斯': '非洲', '塞席爾': '非洲', '葛摩': '非洲', '吉布地': '非洲',
      '索馬利亞': '非洲', '厄利垂亞': '非洲', '馬拉威': '非洲', '莫三比克': '非洲',
      '賴索托': '非洲', '史瓦帝尼': '非洲',
      
      // 大洋洲
      '澳洲': '大洋洲', '紐西蘭': '大洋洲', '斐濟': '大洋洲', '巴布亞紐幾內亞': '大洋洲',
      '索羅門群島': '大洋洲', '萬那杜': '大洋洲', '新喀里多尼亞': '大洋洲',
      '薩摩亞': '大洋洲', '東加': '大洋洲', '吉里巴斯': '大洋洲', '吐瓦魯': '大洋洲',
      '諾魯': '大洋洲', '帛琉': '大洋洲', '密克羅尼西亞': '大洋洲', '馬紹爾群島': '大洋洲',
      
      // 大洋洲英文名稱
      'Australia': '大洋洲', 'New Zealand': '大洋洲', 'Fiji': '大洋洲', 'Papua New Guinea': '大洋洲',
      'Solomon Islands': '大洋洲', 'Vanuatu': '大洋洲', 'New Caledonia': '大洋洲',
      'Samoa': '大洋洲', 'Tonga': '大洋洲', 'Kiribati': '大洋洲', 'Tuvalu': '大洋洲',
      'Nauru': '大洋洲', 'Palau': '大洋洲', 'Micronesia': '大洋洲', 'Marshall Islands': '大洋洲'
    };

    // 從文字中提取國家/地區名稱
    function extractCountryFromText(text) {
      if (!text) return null;
      
      const lowerText = text.toLowerCase();
      const countries = Object.keys(countryToContinent);
      
      for (const country of countries) {
        if (lowerText.includes(country.toLowerCase())) {
          return country;
        }
      }
      return null;
    }

    // 自動分類到洲
    function autoClassifyContinent(title, description) {
      const text = (title + ' ' + description).toLowerCase();
      const country = extractCountryFromText(text);
      
      if (country) {
        return countryToContinent[country];
      }
      
      // 如果沒有找到具體國家，使用關鍵字判斷
      if (text.includes('亞洲') || text.includes('東亞') || text.includes('東南亞') || 
          text.includes('東北亞') || text.includes('中亞') || text.includes('西亞')) {
        return '亞洲';
      }
      if (text.includes('歐洲') || text.includes('歐盟') || text.includes('歐陸')) {
        return '歐洲';
      }
      if (text.includes('美洲') || text.includes('北美') || text.includes('美國') || 
          text.includes('加拿大') || text.includes('墨西哥')) {
        return '北美洲';
      }
      if (text.includes('南美') || text.includes('拉丁美洲') || text.includes('巴西') || 
          text.includes('阿根廷') || text.includes('智利')) {
        return '南美洲';
      }
      if (text.includes('非洲') || text.includes('黑非洲')) {
        return '非洲';
      }
      if (text.includes('大洋洲') || text.includes('澳洲') || text.includes('紐西蘭') || 
          text.includes('太平洋')) {
        return '大洋洲';
      }
      
      return '亞洲'; // 預設為亞洲
    }

    // 清理 YouTube 描述
    function cleanYouTubeDescription(description) {
      if (!description) return '';
      
      let cleaned = description;
      
      // 移除常見的 YouTube 自動生成的內容
      const patternsToRemove = [
        // 移除觀看次數和日期
        /觀看次數:\d+次\s*\d{4}年\d{1,2}月\d{1,2}日/g,
        // 移除時間戳記
        /\d{1,2}:\d{2}(?::\d{2})?\s*[-\u2013\u2014]\s*/g,
        // 移除常見的 YouTube 標籤
        /#\w+/g,
        // 移除過多的換行符號
        /\n{3,}/g,
        // 移除常見的社交媒體連結
        /(?:Facebook|Twitter|Instagram|TikTok|微博|微信):\s*https?:\/\/[^\s]+/gi,
        // 移除常見的訂閱提醒
        /(?:訂閱|Subscribe|按讚|Like|分享|Share|通知|Notification)[\s\S]*?(?=\n\n|\n$|$)/gi,
        // 移除常見的版權聲明
        /(?:版權|Copyright|All rights reserved)[\s\S]*?(?=\n\n|\n$|$)/gi,
        // 移除常見的免責聲明
        /(?:免責聲明|Disclaimer)[\s\S]*?(?=\n\n|\n$|$)/gi,
        // 移除 URL 連結
        /https?:\/\/[^\s]+/g,
        // 移除航向世界旅遊台等品牌資訊
        /航向世界旅遊台[\s\S]*?(?=\n\n|\n$|$)/gi
      ];
      
      patternsToRemove.forEach(pattern => {
        cleaned = cleaned.replace(pattern, '');
      });
      
      // 清理多餘的空白和換行
      cleaned = cleaned
        .replace(/\n\s*\n/g, '\n\n')  // 將多個換行合併為最多兩個
        .replace(/^\s+|\s+$/g, '')    // 移除首尾空白
        .replace(/[ \t]+/g, ' ')      // 將多個空格合併為一個
        .trim();
      
      // 如果清理後太短，返回原始描述
      if (cleaned.length < 20) {
        return description;
      }
      
      return cleaned;
    }


    // 從 HTML 中提取 YouTube 描述
    function extractDescriptionFromHTML(html) {
      try {
        console.log('開始解析 HTML 內容...');
        console.log('HTML 內容長度:', html.length);
        console.log('HTML 內容預覽:', html.substring(0, 500));
        
        // 創建一個臨時的 DOM 元素來解析 HTML
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        // 方法1：嘗試從 meta 標籤提取
        const metaSelectors = [
          'meta[name="description"]',
          'meta[property="og:description"]',
          'meta[name="twitter:description"]'
        ];
        
        for (const selector of metaSelectors) {
          const element = doc.querySelector(selector);
          if (element) {
            const content = element.getAttribute('content');
            if (content && content.length > 50) {
              console.log('從 meta 標籤找到描述:', content.substring(0, 100) + '...');
              return content.trim();
            }
          }
        }
        
        // 方法2：嘗試從 JSON-LD 結構化數據中提取
        const jsonLdScripts = doc.querySelectorAll('script[type="application/ld+json"]');
        for (const script of jsonLdScripts) {
          try {
            const jsonData = JSON.parse(script.textContent);
            if (jsonData.description && jsonData.description.length > 50) {
              console.log('從 JSON-LD 找到描述:', jsonData.description.substring(0, 100) + '...');
              return jsonData.description.trim();
            }
          } catch (e) {
            // 忽略 JSON 解析錯誤
          }
        }
        
        // 方法3：嘗試從 YouTube 特定的元素中提取
        const youtubeSelectors = [
          '#description',
          '.content-description',
          '[data-description]',
          '.ytd-video-secondary-info-renderer',
          '#description-text',
          '.ytd-expander'
        ];
        
        for (const selector of youtubeSelectors) {
          const element = doc.querySelector(selector);
          if (element) {
            const content = element.textContent || element.innerText;
            if (content && content.length > 50) {
              console.log('從 YouTube 元素找到描述:', content.substring(0, 100) + '...');
              return content.trim();
            }
          }
        }
        
        // 方法4：從頁面文本中智能提取
        const bodyText = doc.body ? doc.body.textContent : '';
        if (bodyText) {
          console.log('開始從頁面文本中提取...');
          
          // 尋找包含「觀看次數」的段落，然後提取後續的描述
          const lines = bodyText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
          
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            // 尋找「觀看次數」標題（支援中英文）
            if (line.includes('觀看次數') || line.includes('Views') || line.includes('次') || 
                line.includes('views') || line.includes('view')) {
              console.log('找到觀看次數行:', line);
              
              // 提取後續的內容
              let description = '';
              let foundContent = false;
              let paragraphCount = 0;
              
              for (let j = i + 1; j < Math.min(i + 50, lines.length); j++) {
                const contentLine = lines[j];
                
                // 如果遇到下一個標題或按鈕，停止提取
                if (contentLine.includes('訂閱') || contentLine.includes('分享') || 
                    contentLine.includes('儲存') || contentLine.includes('Subscribe') ||
                    contentLine.includes('Share') || contentLine.includes('Save') ||
                    contentLine.includes('縮圖') || contentLine.includes('播放清單') || 
                    contentLine.includes('資訊卡') || contentLine.includes('Thumbnail') ||
                    contentLine.includes('Playlist') || contentLine.includes('Info Cards') ||
                    contentLine.includes('Watch more') || contentLine.includes('Question for you') ||
                    contentLine.includes('Welcome to') || contentLine.includes('✨')) {
                  break;
                }
                
                // 如果這行有實質內容，加入描述
                if (contentLine.length > 20 && !contentLine.match(/^[#@\s]*$/)) {
                  // 檢查是否為有效的描述段落
                  if (isValidDescriptionParagraph(contentLine)) {
                    description += contentLine + '\n';
                    foundContent = true;
                    paragraphCount++;
                    console.log('找到有效段落:', contentLine.substring(0, 50) + '...');
                  }
                }
              }
              
              if (foundContent && description.length > 50) {
                console.log('成功提取描述:', description.substring(0, 100) + '...');
                return description.trim();
              }
            }
          }
          
          // 如果沒有找到「觀看次數」，嘗試尋找其他標識
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            // 尋找包含「在加拿大的壯麗北國」的段落
            if (line.includes('在加拿大的壯麗北國') || line.includes('在') && line.includes('的') && line.includes('，')) {
              console.log('找到描述開始行:', line);
              
              // 提取後續的內容
              let description = '';
              let foundContent = false;
              let paragraphCount = 0;
              
              for (let j = i; j < Math.min(i + 20, lines.length); j++) {
                const contentLine = lines[j];
                
                // 如果遇到下一個標題或按鈕，停止提取
                if (contentLine.includes('訂閱') || contentLine.includes('分享') || 
                    contentLine.includes('儲存') || contentLine.includes('Subscribe') ||
                    contentLine.includes('Share') || contentLine.includes('Save')) {
                  break;
                }
                
                // 如果這行有實質內容，加入描述
                if (contentLine.length > 20 && !contentLine.match(/^[#@\s]*$/)) {
                  if (isValidDescriptionParagraph(contentLine)) {
                    description += contentLine + '\n';
                    foundContent = true;
                    paragraphCount++;
                  }
                }
              }
              
              if (foundContent && description.length > 100 && paragraphCount >= 2) {
                console.log('成功提取描述:', description.substring(0, 100) + '...');
                return description.trim();
              }
            }
          }
        }
        
        // 方法5：嘗試從 YouTube 的內嵌數據中提取
        const scripts = doc.querySelectorAll('script');
        for (const script of scripts) {
          const scriptContent = script.textContent;
          if (scriptContent && scriptContent.includes('description')) {
            // 尋找 JSON 格式的描述數據
            const descriptionMatch = scriptContent.match(/"description":\s*"([^"]+)"/);
            if (descriptionMatch && descriptionMatch[1].length > 50) {
              console.log('從腳本中找到描述:', descriptionMatch[1].substring(0, 100) + '...');
              return descriptionMatch[1].trim();
            }
          }
        }
        
        // 方法6：嘗試從 YouTube 的 ytInitialData 中提取
        for (const script of scripts) {
          const scriptContent = script.textContent;
          if (scriptContent && scriptContent.includes('ytInitialData')) {
            try {
              // 尋找 ytInitialData 變數
              const ytDataMatch = scriptContent.match(/var ytInitialData = ({.+?});/);
              if (ytDataMatch) {
                const ytData = JSON.parse(ytDataMatch[1]);
                console.log('找到 ytInitialData，開始解析...');
                
                // 遞歸搜索描述
                const description = findDescriptionInYtData(ytData);
                if (description && description.length > 50) {
                  console.log('從 ytInitialData 中找到描述:', description.substring(0, 100) + '...');
                  return description.trim();
                }
              }
            } catch (e) {
              console.log('解析 ytInitialData 失敗:', e);
            }
          }
        }
        
        // 方法7：直接從 HTML 文本中尋找描述模式
        console.log('嘗試直接從 HTML 文本中提取...');
        
        // 尋找包含 "Join us" 或類似開頭的段落
        const descriptionPatterns = [
          /Join us on a scenic road trip[^<]*/gi,
          /Join us[^<]*/gi,
          /Welcome to[^<]*/gi,
          /In this video[^<]*/gi,
          /This journey[^<]*/gi,
          /Experience[^<]*/gi,
          /Discover[^<]*/gi,
          /Explore[^<]*/gi
        ];
        
        for (const pattern of descriptionPatterns) {
          const match = html.match(pattern);
          if (match && match[0].length > 50) {
            let description = match[0];
            // 清理 HTML 標籤
            description = description.replace(/<[^>]*>/g, '');
            // 清理多餘的空白
            description = description.replace(/\s+/g, ' ').trim();
            
            if (description.length > 50) {
              console.log('從 HTML 文本模式找到描述:', description.substring(0, 100) + '...');
              return description;
            }
          }
        }
        
        // 方法8：尋找包含旅遊關鍵詞的長段落
        const travelPatterns = [
          /Switzerland[^<]{50,500}/gi,
          /Italy[^<]{50,500}/gi,
          /travel[^<]{50,500}/gi,
          /journey[^<]{50,500}/gi,
          /adventure[^<]{50,500}/gi,
          /scenic[^<]{50,500}/gi,
          /beautiful[^<]{50,500}/gi,
          /breathtaking[^<]{50,500}/gi
        ];
        
        for (const pattern of travelPatterns) {
          const match = html.match(pattern);
          if (match && match[0].length > 100) {
            let description = match[0];
            // 清理 HTML 標籤
            description = description.replace(/<[^>]*>/g, '');
            // 清理多餘的空白
            description = description.replace(/\s+/g, ' ').trim();
            
            if (description.length > 100) {
              console.log('從旅遊關鍵詞模式找到描述:', description.substring(0, 100) + '...');
              return description;
            }
          }
        }
        
        console.log('未能找到有效的描述內容');
        return null;
        
      } catch (error) {
        console.error('HTML 解析錯誤:', error);
        return null;
      }
    }

    // 遞歸搜索 YouTube 數據中的描述
    function findDescriptionInYtData(obj, depth = 0) {
      if (depth > 10) return null; // 防止無限遞歸
      
      if (typeof obj === 'string' && obj.length > 100) {
        // 檢查是否包含中文描述內容 - 更精確的匹配
        if (isChineseDescription(obj)) {
          return obj;
        }
      }
      
      if (typeof obj === 'object' && obj !== null) {
        // 檢查是否有 description 屬性
        if (obj.description && typeof obj.description === 'string' && obj.description.length > 100) {
          if (isChineseDescription(obj.description)) {
            return obj.description;
          }
        }
        
        // 遞歸搜索所有屬性
        for (const key in obj) {
          if (obj.hasOwnProperty(key)) {
            const result = findDescriptionInYtData(obj[key], depth + 1);
            if (result) return result;
          }
        }
      }
      
      return null;
    }

    // 檢查是否為有效的描述段落
    function isValidDescriptionParagraph(text) {
      if (!text || text.length < 20) return false;
      
      // 檢查是否包含旅遊相關的關鍵詞（中文）
      const chineseTravelKeywords = [
        '壯麗', '北國', '夢幻', '之旅', '河面', '銀白', '極光', '雪地', '探險',
        '清澈', '奔騰', '倒映', '天空', '原始', '森林', '大自然', '純粹', '力量', '靜謐',
        '山脈', '小鎮', '風情', '童話', '雪景', '環抱', '購物', '美食', '天堂',
        '工藝品', '楓糖漿', '服飾', '驚喜', '鏡頭', '感受', '靜謐', '磅礴', '熱鬧', '繽紛', '迷人', '面貌',
        '加拿大', '黃刀鎮', '弓河', '洛磯山脈', '班夫', '冬季', '夏季', '探險', '欣賞'
      ];
      
      // 檢查是否包含旅遊相關的關鍵詞（英文）
      const englishTravelKeywords = [
        'travel', 'journey', 'trip', 'adventure', 'explore', 'visit', 'destination',
        'scenic', 'beautiful', 'amazing', 'stunning', 'breathtaking', 'landscape',
        'countryside', 'mountain', 'lake', 'river', 'city', 'town', 'village',
        'culture', 'history', 'nature', 'wildlife', 'experience', 'discover',
        'road trip', 'hiking', 'sightseeing', 'photography', 'video', 'vlog',
        'Switzerland', 'Zurich', 'Thun', 'Alps', 'Swiss', 'Europe', 'Italy',
        'France', 'Germany', 'Spain', 'Japan', 'Korea', 'Thailand', 'Vietnam'
      ];
      
      // 檢查是否包含中文標點符號
      const hasChinesePunctuation = /[，。；：！？]/.test(text);
      
      // 檢查是否包含英文標點符號
      const hasEnglishPunctuation = /[.,;:!?]/.test(text);
      
      // 計算匹配的中文關鍵詞數量
      let chineseKeywordCount = 0;
      for (const keyword of chineseTravelKeywords) {
        if (text.includes(keyword)) {
          chineseKeywordCount++;
        }
      }
      
      // 計算匹配的英文關鍵詞數量
      let englishKeywordCount = 0;
      for (const keyword of englishTravelKeywords) {
        if (text.toLowerCase().includes(keyword.toLowerCase())) {
          englishKeywordCount++;
        }
      }
      
      // 檢查是否為英文內容
      const isEnglishContent = /[a-zA-Z]/.test(text) && englishKeywordCount >= 2;
      
      // 檢查是否為中文內容
      const isChineseContent = /[\u4e00-\u9fff]/.test(text) && chineseKeywordCount >= 2 && hasChinesePunctuation;
      
      // 如果包含足夠的關鍵詞和標點符號，認為是有效的描述段落
      return isEnglishContent || isChineseContent;
    }

    // 檢查是否為中文描述內容
    function isChineseDescription(text) {
      if (!text || text.length < 50) return false;
      
      // 檢查是否包含中文標點符號和常見詞彙
      const chinesePatterns = [
        /在.*的.*，/,  // "在...的...，"
        /這裡.*是/,    // "這裡...是"
        /而.*您將/,    // "而...您將"
        /從.*到/,      // "從...到"
        /跟隨.*一起/,  // "跟隨...一起"
        /發現.*的/,    // "發現...的"
        /，.*，.*。/   // 中文標點符號模式
      ];
      
      // 檢查是否包含旅遊相關詞彙
      const travelKeywords = [
        '壯麗', '北國', '夢幻', '之旅', '河面', '銀白', '極光', '雪地', '探險',
        '清澈', '奔騰', '倒映', '天空', '原始', '森林', '大自然', '純粹', '力量', '靜謐',
        '山脈', '小鎮', '風情', '童話', '雪景', '環抱', '購物', '美食', '天堂',
        '工藝品', '楓糖漿', '服飾', '驚喜', '鏡頭', '感受', '靜謐', '磅礴', '熱鬧', '繽紛', '迷人', '面貌'
      ];
      
      // 計算匹配的關鍵詞數量
      let keywordCount = 0;
      for (const keyword of travelKeywords) {
        if (text.includes(keyword)) {
          keywordCount++;
        }
      }
      
      // 檢查中文標點符號模式
      let patternCount = 0;
      for (const pattern of chinesePatterns) {
        if (pattern.test(text)) {
          patternCount++;
        }
      }
      
      // 如果包含足夠的關鍵詞和模式，認為是有效的中文描述
      return keywordCount >= 3 && patternCount >= 1;
    }

    // 開啟 YouTube 頁面
    function openYouTubePage() {
      const youtubeId = document.getElementById('youtubeId').value.trim();
      if (!youtubeId) {
        showStatus('請先輸入 YouTube ID', 'warning');
        return;
      }
      
      const youtubeUrl = `https://www.youtube.com/watch?v=${youtubeId}`;
      window.open(youtubeUrl, '_blank');
      
      showStatus('已開啟 YouTube 頁面，請複製「說明」區塊的內容，然後點擊「📋 貼上剪貼簿內容」', 'info');
    }

    // 自動擷取 YouTube 描述
    async function autoExtractDescription() {
      try {
        const youtubeId = document.getElementById('youtubeId').value.trim();
        
        if (!youtubeId) {
          showStatus('請先輸入 YouTube ID', 'warning');
          return;
        }
        
        showStatus('🤖 正在自動擷取 YouTube 描述...', 'info');
        
        // 使用更可靠的代理服務嘗試擷取
        const proxies = [
          `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(`https://www.youtube.com/watch?v=${youtubeId}`)}`,
          `https://thingproxy.freeboard.io/fetch/https://www.youtube.com/watch?v=${youtubeId}`,
          `https://corsproxy.io/?${encodeURIComponent(`https://www.youtube.com/watch?v=${youtubeId}`)}`
        ];
        
        let description = null;
        
        for (let i = 0; i < proxies.length; i++) {
          try {
            console.log(`🔄 嘗試代理服務 ${i + 1}/${proxies.length}...`);
            showStatus(`🤖 正在嘗試擷取... (${i + 1}/${proxies.length})`, 'info');
            
            const response = await fetch(proxies[i]);
            const data = await response.text();
            
            // 嘗試從 HTML 中提取描述
            const descriptionMatch = data.match(/<meta name="description" content="([^"]+)"/);
            if (descriptionMatch) {
              description = descriptionMatch[1];
              console.log('✅ 成功擷取描述:', description);
              break;
            }
            
            // 嘗試其他可能的描述位置
            const altDescriptionMatch = data.match(/"description":"([^"]+)"/);
            if (altDescriptionMatch) {
              description = altDescriptionMatch[1];
              console.log('✅ 成功擷取描述 (備用方法):', description);
              break;
            }
            
          } catch (error) {
            console.log(`❌ 代理服務 ${i + 1} 失敗:`, error.message);
            continue;
          }
        }
        
        if (description) {
          // 處理描述文字
          let processedDescription = description
            .replace(/&quot;/g, '"')
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&nbsp;/g, ' ')
            .trim();
          
          // 自動提取觀看次數信息
          const viewCountInfo = extractViewCountInfo(processedDescription);
          if (viewCountInfo) {
            const tagInfo = viewCountInfo.tag ? ` #${viewCountInfo.tag}` : '';
            showStatus(`✅ 自動擷取成功！觀看次數: ${viewCountInfo.viewCount} (${viewCountInfo.date})${tagInfo}`, 'success');
            
            // 在開頭添加觀看次數信息
            const tagPrefix = viewCountInfo.tag ? ` #${viewCountInfo.tag}` : '';
            processedDescription = `📊 ${viewCountInfo.viewCount} (${viewCountInfo.date})${tagPrefix}\n\n${processedDescription}`;
          } else {
            showStatus('✅ 自動擷取成功！', 'success');
          }
          
          // 填入描述框
          document.getElementById('description').value = processedDescription;
          
          // 自動分類
          const title = document.getElementById('title').value;
          const continent = autoClassifyContinent(title, processedDescription);
          document.getElementById('category').value = continent;
          
        } else {
          showStatus('❌ 無法自動擷取描述，請手動複製貼上', 'error');
          console.log('❌ 所有代理服務都失敗了');
        }
        
      } catch (error) {
        console.error('自動擷取失敗:', error);
        showStatus('❌ 自動擷取失敗，請手動複製貼上', 'error');
      }
    }

    // 測試觀看次數提取功能
    function testViewCountExtraction() {
      const testText = "觀看次數:22次 2025年9月22日\n\n這是一個測試描述...";
      console.log('🧪 測試觀看次數提取功能');
      console.log('🧪 測試文本:', testText);
      const result = extractViewCountInfo(testText);
      console.log('🧪 提取結果:', result);
      return result;
    }

    // 提取觀看次數信息
    function extractViewCountInfo(text) {
      try {
        console.log('🔍 開始提取觀看次數，輸入文本:', text.substring(0, 100) + '...');
        
        // 匹配中文格式：觀看次數:22次 2025年9月22日（可能包含標籤）
        const chinesePattern = /觀看次數:(\d+)次\s*(\d{4})年(\d{1,2})月(\d{1,2})日(?:\s*#\S+)?/;
        const chineseMatch = text.match(chinesePattern);
        console.log('🔍 中文格式匹配結果:', chineseMatch);
        
        if (chineseMatch) {
          const [, viewCount, year, month, day] = chineseMatch;
          
          // 提取標籤（如果存在）
          const tagMatch = chineseMatch[0].match(/#(\S+)/);
          const tag = tagMatch ? tagMatch[1] : null;
          
          return {
            viewCount: `${viewCount}次`,
            date: `${year}年${month}月${day}日`,
            tag: tag,
            fullText: chineseMatch[0],
            type: 'chinese'
          };
        }
        
        // 匹配英文格式：Views: 22 September 22, 2025
        const englishPattern = /Views:\s*(\d+)\s*(\w+)\s*(\d{1,2}),\s*(\d{4})/i;
        const englishMatch = text.match(englishPattern);
        console.log('🔍 英文格式匹配結果:', englishMatch);
        
        if (englishMatch) {
          const [, viewCount, month, day, year] = englishMatch;
          return {
            viewCount: `${viewCount} views`,
            date: `${month} ${day}, ${year}`,
            fullText: englishMatch[0],
            type: 'english'
          };
        }
        
        // 匹配簡化格式：觀看次數:22次
        const simplePattern = /觀看次數:(\d+)次/;
        const simpleMatch = text.match(simplePattern);
        console.log('🔍 簡化格式匹配結果:', simpleMatch);
        
        if (simpleMatch) {
          return {
            viewCount: `${simpleMatch[1]}次`,
            date: '日期未找到',
            fullText: simpleMatch[0],
            type: 'simple'
          };
        }
        
        console.log('❌ 沒有找到任何觀看次數格式');
        return null;
      } catch (error) {
        console.error('提取觀看次數失敗:', error);
        return null;
      }
    }

    // 從剪貼簿貼上內容
    async function pasteFromClipboard() {
      try {
        console.log('📋 開始從剪貼簿讀取內容...');
        const text = await navigator.clipboard.readText();
        console.log('📋 剪貼簿內容長度:', text ? text.length : 0);
        console.log('📋 剪貼簿內容預覽:', text ? text.substring(0, 200) + '...' : '空');
        
        if (text && text.trim()) {
          // 清理剪貼簿內容
          let cleanedText = text.trim();
          
          // 自動提取觀看次數
          console.log('🔍 開始提取觀看次數...');
          const viewCountInfo = extractViewCountInfo(cleanedText);
          if (viewCountInfo) {
            console.log('📊 提取到觀看次數信息:', viewCountInfo);
            const tagInfo = viewCountInfo.tag ? ` #${viewCountInfo.tag}` : '';
            showStatus(`✅ 自動提取觀看次數: ${viewCountInfo.viewCount} (${viewCountInfo.date})${tagInfo}`, 'success');
          } else {
            console.log('❌ 沒有提取到觀看次數信息');
          }
          
          // 移除常見的無關內容，但保留觀看次數信息在開頭
          let viewCountPrefix = '';
          if (viewCountInfo) {
            const tagInfo = viewCountInfo.tag ? ` #${viewCountInfo.tag}` : '';
            viewCountPrefix = `📊 ${viewCountInfo.viewCount} (${viewCountInfo.date})${tagInfo}\n\n`;
          }
          
          // 移除觀看次數行，因為我們已經提取了
          cleanedText = cleanedText.replace(/觀看次數:\d+次\s*\d{4}年\d{1,2}月\d{1,2}日(?:\s*#\S+)?/g, '');
          cleanedText = cleanedText.replace(/Views:\d+\s*\d{4}-\d{1,2}-\d{1,2}/g, '');
          cleanedText = cleanedText.replace(/Subscribe|分享|儲存|縮圖|播放清單|資訊卡/g, '');
          
          // 在開頭添加觀看次數信息
          cleanedText = viewCountPrefix + cleanedText;
          cleanedText = cleanedText.replace(/Watch more|Question for you|Welcome to/g, '');
          
          // 如果內容太短，可能是無效內容
          if (cleanedText.length < 20) {
            showStatus('剪貼簿內容太短，請確認已複製完整的 YouTube 描述', 'warning');
            return;
          }
          
          document.getElementById('description').value = cleanedText;
          
          // 自動分類
          const title = document.getElementById('title').value;
          const continent = autoClassifyContinent(title, cleanedText);
          document.getElementById('category').value = continent;
          
          showStatus(`已貼上剪貼簿內容並分類到：${continent}`, 'success');
        } else {
          showStatus('剪貼簿為空，請先複製 YouTube 描述內容', 'warning');
        }
      } catch (error) {
        console.error('讀取剪貼簿失敗:', error);
        showStatus('無法讀取剪貼簿，請手動輸入描述', 'error');
      }
    }

    // 單獨獲取 YouTube 描述（使用無需 API Key 的方法）
    async function fetchYouTubeDescription() {
      const youtubeId = document.getElementById('youtubeId').value.trim();
      if (!youtubeId) {
        showStatus('請先輸入 YouTube ID', 'warning');
        return;
      }
      
      console.log('🔍 開始獲取 YouTube 描述，ID:', youtubeId);

      try {
        showStatus('正在從 YouTube 獲取描述...', 'info');
        
        // 使用 YouTube oEmbed API 驗證影片存在
        const oembedResponse = await fetch(`https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${youtubeId}&format=json`);
        if (oembedResponse.ok) {
          const oembedData = await oembedResponse.json();
          
          // 嘗試使用多個代理服務獲取 YouTube 描述
          const proxyServices = [
            `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(`https://www.youtube.com/watch?v=${youtubeId}`)}`,
            `https://thingproxy.freeboard.io/fetch/https://www.youtube.com/watch?v=${youtubeId}`,
            `https://corsproxy.io/?${encodeURIComponent(`https://www.youtube.com/watch?v=${youtubeId}`)}`,
            `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(`https://youtu.be/${youtubeId}`)}`
          ];
          
          for (let i = 0; i < proxyServices.length; i++) {
            try {
              showStatus(`正在嘗試獲取影片描述... (方法 ${i + 1}/${proxyServices.length})`, 'info');
              
              const proxyResponse = await fetch(proxyServices[i]);
              if (proxyResponse.ok) {
                let htmlContent = '';
                
                if (proxyServices[i].includes('allorigins.win')) {
                  const proxyData = await proxyResponse.json();
                  htmlContent = proxyData.contents;
                } else {
                  htmlContent = await proxyResponse.text();
                }
                
                console.log(`代理服務 ${i + 1} 獲取到 HTML 內容長度:`, htmlContent.length);
                
                // 從 HTML 中提取描述
                const description = extractDescriptionFromHTML(htmlContent);
                
                if (description && description.length > 50) {
                  // 清理描述
                  const cleanedDescription = cleanYouTubeDescription(description);
                  document.getElementById('description').value = cleanedDescription;
                  
                  // 自動分類
                  const continent = autoClassifyContinent(oembedData.title, cleanedDescription);
                  document.getElementById('category').value = continent;
                  
                  showStatus(`✅ 已成功獲取 YouTube 描述並分類到：${continent}`, 'success');
                  return;
                } else {
                  console.log(`代理服務 ${i + 1} 未能提取到有效描述`);
                }
              } else {
                console.log(`代理服務 ${i + 1} 請求失敗:`, proxyResponse.status);
              }
            } catch (proxyError) {
              console.log(`代理服務 ${i + 1} 失敗:`, proxyError);
            }
          }
          
          // 如果所有代理服務都失敗，嘗試使用 YouTube 的公開 API
          try {
            showStatus('正在嘗試使用 YouTube 公開 API...', 'info');
            
            // 使用 YouTube 的公開 oEmbed API 獲取更多資訊
            const oembedResponse = await fetch(`https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${youtubeId}&format=json&maxwidth=800&maxheight=600`);
            if (oembedResponse.ok) {
              const oembedData = await oembedResponse.json();
              
              // oEmbed API 不提供描述，但我們可以嘗試其他方法
              console.log('oEmbed API 成功，但無法獲取描述');
            }
          } catch (oembedError) {
            console.log('oEmbed API 失敗:', oembedError);
          }
          
          // 如果無法獲取描述，提供手動輸入的指導
          showStatus('代理服務被 YouTube 阻擋，請手動輸入描述', 'warning');
          
          // 同時自動分類
          const continent = autoClassifyContinent(oembedData.title, '');
          document.getElementById('category').value = continent;
          
          // 提供手動輸入的選項
          const manualDescription = prompt(`影片標題：${oembedData.title}\n\n請手動輸入 YouTube 影片描述（或按取消跳過）：`);
          if (manualDescription && manualDescription.trim()) {
            document.getElementById('description').value = manualDescription.trim();
            showStatus(`已手動輸入描述並分類到：${continent}`, 'success');
          } else {
            // 在描述欄位中提供建議
            const suggestions = [
              `📺 影片標題：${oembedData.title}`,
              '',
              '💡 手動獲取描述的方法：',
              '1. 前往 YouTube 影片頁面：https://www.youtube.com/watch?v=' + youtubeId,
              '2. 找到「說明」或「Description」區塊',
              '3. 複製完整的描述文字',
              '4. 貼到此欄位中',
              '',
              '💡 建議描述格式：',
              '• 影片主題和內容概述',
              '• 主要景點或特色',
              '• 適合的觀眾群體',
              '• 影片亮點或推薦原因',
              '',
              '📝 請手動輸入描述...'
            ].join('\n');
            
            document.getElementById('description').value = suggestions;
            showStatus(`已根據標題自動分類到：${continent}，請手動輸入描述`, 'info');
          }
          
        } else {
          showStatus('無法獲取 YouTube 資訊，請檢查 ID 是否正確', 'warning');
        }
        
      } catch (error) {
        showStatus('獲取 YouTube 描述時發生錯誤', 'error');
        console.error('YouTube 描述獲取錯誤:', error);
      }
    }

    // 手動觸發自動分類
    function autoClassifyFromTitle() {
      const title = document.getElementById('title').value;
      const description = document.getElementById('description').value;
      
      if (!title && !description) {
        showStatus('請先填入節目標題或描述', 'warning');
        return;
      }
      
      const continent = autoClassifyContinent(title, description);
      document.getElementById('category').value = continent;
      
      // 顯示分類結果
      const country = extractCountryFromText(title + ' ' + description);
      if (country) {
        showStatus(`已自動分類到：${continent}（檢測到：${country}）`, 'success');
      } else {
        showStatus(`已自動分類到：${continent}（基於關鍵字判斷）`, 'success');
      }
    }

    async function fetchYouTubeInfo() {
      const youtubeId = document.getElementById('youtubeId').value.trim();
      if (!youtubeId) return;

      try {
        showStatus('正在獲取 YouTube 資訊...', 'info');
        
        // 使用 YouTube oEmbed API 獲取基本資訊
        const response = await fetch(`https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${youtubeId}&format=json`);
        if (response.ok) {
          const data = await response.json();
          
          // 填入標題
          document.getElementById('title').value = data.title;
          
          // 自動更新縮圖預覽
          updateThumbnailPreview(youtubeId);
          
          // 自動分類到洲（基於標題）
          const continent = autoClassifyContinent(data.title, '');
          document.getElementById('category').value = continent;
          
          showStatus(`YouTube 資訊已自動填入，已分類到：${continent}。如需描述，請手動輸入或使用「📝 從 YouTube 獲取」按鈕`, 'success');
        } else {
          showStatus('無法獲取 YouTube 資訊，請檢查 ID 是否正確', 'warning');
        }
      } catch (error) {
        showStatus('獲取 YouTube 資訊時發生錯誤', 'error');
        console.error('YouTube 資訊獲取錯誤:', error);
      }
    }

    // 更新縮圖預覽
    function updateThumbnailPreview(youtubeId) {
      const thumbnailPreview = document.getElementById('thumbnailPreview');
      if (youtubeId) {
        // 使用更可靠的 YouTube 縮圖 URL
        const thumbnailUrl = `https://i.ytimg.com/vi/${youtubeId}/maxresdefault.jpg`;
        thumbnailPreview.src = thumbnailUrl;
        thumbnailPreview.setAttribute('data-youtube-url', thumbnailUrl);
        
        // 如果 maxresdefault 失敗，回退到 hqdefault
        thumbnailPreview.onerror = function() {
          this.src = `https://i.ytimg.com/vi/${youtubeId}/hqdefault.jpg`;
          this.onerror = null; // 防止無限循環
        };
      } else {
        thumbnailPreview.src = 'https://images.unsplash.com/photo-1485846234645-a62644f84728?w=200&h=112&fit=crop';
        thumbnailPreview.removeAttribute('data-youtube-url');
        thumbnailPreview.onerror = null;
      }
    }

    // 預覽上傳的縮圖
    function previewThumbnail() {
      const fileInput = document.getElementById('thumbnailFile');
      const thumbnailPreview = document.getElementById('thumbnailPreview');
      
      if (fileInput.files && fileInput.files[0]) {
        const reader = new FileReader();
        reader.onload = function(e) {
          thumbnailPreview.src = e.target.result;
        };
        reader.readAsDataURL(fileInput.files[0]);
      }
    }

    // 重置為 YouTube 縮圖
    function resetThumbnail() {
      const youtubeId = document.getElementById('youtubeId').value.trim();
      const thumbnailFile = document.getElementById('thumbnailFile');
      
      // 清除檔案選擇
      thumbnailFile.value = '';
      
      // 更新縮圖預覽
      updateThumbnailPreview(youtubeId);
      
      showStatus('已重置為 YouTube 縮圖', 'info');
    }

    function handleFileUpload() {
      const fileInput = document.getElementById('mp4File');
      const file = fileInput.files[0];

      if (file) {
        const fileName = file.name.replace('.mp4', '');
        document.getElementById('title').value = fileName;
        showStatus('檔案名稱已自動填入為標題', 'success');
      }
    }

    function getEvent(date, time) {
      const dayEvents = events[date] || [];
      return dayEvents.find(event => event.time === time);
    }

    // 檢查是否為過去的日期時間並顯示警語
    function checkPastDateTime() {
      const date = document.getElementById('editDate').value;
      const time = document.getElementById('airTime').value;
      const warningDiv = document.getElementById('pastDateTimeWarning');
      
      if (!date || !time) {
        warningDiv.style.display = 'none';
        return;
      }

      const now = new Date();
      const currentHour = now.getHours();
      const currentMinute = now.getMinutes();
      const todayString = now.getFullYear() + '-' +
                         String(now.getMonth() + 1).padStart(2, '0') + '-' +
                         String(now.getDate()).padStart(2, '0');
      
      const isPastDate = date < todayString;
      const isPastTime = date === todayString &&
                        (parseInt(time.split(':')[0]) < currentHour ||
                         (parseInt(time.split(':')[0]) === currentHour && parseInt(time.split(':')[1]) <= currentMinute));

      if (isPastDate || isPastTime) {
        warningDiv.style.display = 'block';
        warningDiv.innerHTML = isPastDate 
          ? `⚠️ <strong>警告：</strong>您選擇的是過去的日期 (${date})，這可能會影響節目排程。請確認是否要繼續編輯。`
          : `⚠️ <strong>警告：</strong>您選擇的是過去的時間 (${date} ${time})，這可能會影響節目排程。請確認是否要繼續編輯。`;
      } else {
        warningDiv.style.display = 'none';
      }
    }

    function updateTimeSlotInfo() {
      const time = document.getElementById('airTime').value;
      const timeSlotInfo = document.getElementById('timeSlotInfo');
      const timeSlotName = document.getElementById('timeSlotName');
      const timeSlotDescription = document.getElementById('timeSlotDescription');
      
      if (!time) {
        timeSlotInfo.style.display = 'none';
        return;
      }
      
      const timeSlot = getTimeSlot(time);
      if (timeSlot) {
        const slotIndex = timeSlot.slot.slots.indexOf(time);
        const otherSlots = getSameTimeSlotInOtherPeriods(time);
        
        timeSlotName.textContent = `🎯 ${timeSlot.slot.name} (第${slotIndex + 1}個時間槽)`;
        timeSlotDescription.innerHTML = `
          <br>📅 可複製到：${otherSlots.map(slot => `${slot.periodName} ${slot.time}`).join('、')}
          <br>🔄 此時間槽可批量複製到整個月的相同時段
        `;
        timeSlotInfo.style.display = 'block';
      } else {
        timeSlotInfo.style.display = 'none';
      }
    }

    document.getElementById('eventForm').addEventListener('submit', function(e) {
      e.preventDefault();
      console.log('📝 表單提交事件觸發');
      console.log('🔍 檢查編輯模式:', {
        currentEditingVideoId: window.currentEditingVideoId,
        hasVideoId: !!window.currentEditingVideoId
      });

      // 檢查是否為影片編輯模式
      if (window.currentEditingVideoId) {
        console.log('✅ 進入影片編輯模式，調用 updateVideoInContentful');
        // 在編輯影片模式下，直接調用 updateVideoInContentful
        updateVideoInContentful();
        return;
      }
      
      console.log('📅 進入節目排程模式，直接上架到 Contentful');
      // 所有儲存操作都直接同步到 Contentful
      createNewProgram();
    });

    async function deleteEvent() {
      console.log('🗑️ deleteEvent 函數被調用');
      console.log('window.currentEditingVideoId:', window.currentEditingVideoId);
      console.log('window.deleteVideo 是否存在:', typeof window.deleteVideo);
      
      // 檢查是否為影片編輯模式
      if (window.currentEditingVideoId) {
        console.log('🗑️ 刪除影片模式，調用影片刪除功能');
        const videoTitle = document.getElementById('title').value || '未命名影片';
        
        if (typeof window.deleteVideo === 'function') {
          console.log('✅ window.deleteVideo 函數存在，開始調用');
          await window.deleteVideo(window.currentEditingVideoId, videoTitle);
        } else {
          console.error('❌ window.deleteVideo 函數不存在');
          showStatus('❌ 刪除功能未載入，請重新載入頁面', 'error');
        }
        return;
      }

      const date = document.getElementById('editDate').value;
      const time = document.getElementById('editTime').value;
      const title = document.getElementById('title').value;

      console.log('🗑️ 開始刪除節目:', { date, time, title });

      try {
        // 找到要刪除的節目
        console.log('🔍 尋找要刪除的節目...');
        const eventToDelete = events[date]?.find(event => event.time === time);
        
        if (!eventToDelete) {
          console.error('❌ 找不到要刪除的節目');
          showStatus('找不到要刪除的節目', 'error');
          return;
        }

        console.log('✅ 找到要刪除的節目:', eventToDelete);

        // 檢查是否有相同時間槽和相同 YouTube ID 的節目
        const duplicateEvents = findDuplicateEvents(eventToDelete, date, time);
        
        if (duplicateEvents.length > 0) {
          // 顯示選擇刪除方式的對話框
          console.log('📋 顯示選擇刪除方式對話框...');
          try {
            const choice = await showDeleteChoiceDialog(eventToDelete, duplicateEvents, date, time, title);
            console.log('📋 用戶選擇:', choice);
            
            if (choice === 'single') {
              console.log('✅ 用戶選擇只刪除這一個節目');
              await deleteSingleEvent(eventToDelete, date, time);
            } else if (choice === 'batch') {
              console.log('✅ 用戶選擇批量刪除');
              await batchDeleteEvents(duplicateEvents);
            } else {
              console.log('❌ 用戶取消刪除');
              showStatus('已取消刪除', 'info');
              return;
            }
          } catch (error) {
            console.error('❌ 顯示選擇對話框失敗:', error);
            showStatus('顯示選擇對話框失敗: ' + error.message, 'error');
            return;
          }
        } else {
          // 單個節目刪除確認
          const confirmMessage = `確定要刪除以下節目嗎？\n\n日期：${date}\n時間：${time}\n標題：${title}\n\n⚠️ 此操作將同時從 Contentful 中刪除節目，無法復原！`;
          
          if (!confirm(confirmMessage)) {
            console.log('❌ 用戶取消刪除');
            showStatus('已取消刪除', 'info');
            return;
          }

          console.log('✅ 用戶確認刪除');
          await deleteSingleEvent(eventToDelete, date, time);
        }

        // 不調用 saveEvents()，因為我們已經移除了 localStorage 依賴
        renderCurrentView();
        closeModal();
        
        // 顯示最終狀態（在 deleteSingleEvent 或 batchDeleteEvents 中已經顯示了）
        
      } catch (error) {
        console.error('❌ 刪除節目失敗:', error);
        showStatus('刪除節目失敗: ' + error.message, 'error');
      }
    }

    // 顯示刪除選擇對話框
    function showDeleteChoiceDialog(eventToDelete, duplicateEvents, date, time, title) {
      console.log('📋 開始創建選擇對話框...');
      
      const dialog = document.createElement('div');
      dialog.id = 'deleteChoiceDialog';
      dialog.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        font-family: Arial, sans-serif;
      `;
      
      console.log('📋 對話框樣式已設置');
      
      dialog.innerHTML = `
        <div style="
          background: white;
          padding: 30px;
          border-radius: 10px;
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
          max-width: 600px;
          width: 90%;
          text-align: center;
        ">
          <h3 style="margin: 0 0 20px 0; color: #333;">選擇刪除方式</h3>
          <div style="margin-bottom: 20px; text-align: left;">
            <p style="margin: 0 0 15px 0; color: #666;">
              <strong>節目：</strong>${title}<br>
              <strong>時間：</strong>${time}<br>
              <strong>YouTube ID：</strong>${eventToDelete.youtubeId || '無'}
            </p>
            <p style="margin: 0 0 15px 0; color: #666;">
              發現 <strong>${duplicateEvents.length}</strong> 個今天之後相同時間槽的相同節目：
            </p>
            <p style="margin: 0 0 15px 0; color: #999; font-size: 12px;">
              ℹ️ 批量刪除只會刪除今天及之後的節目，過去的節目不會被刪除
            </p>
            <div style="
              background: #f8f9fa;
              padding: 15px;
              border-radius: 5px;
              margin-bottom: 20px;
              max-height: 200px;
              overflow-y: auto;
              font-size: 12px;
            ">
              ${duplicateEvents.slice(0, 10).map(e => `• ${e.date} ${e.time}`).join('<br>')}
              ${duplicateEvents.length > 10 ? `<br>... 還有 ${duplicateEvents.length - 10} 個節目` : ''}
            </div>
          </div>
          <div style="display: flex; gap: 15px; justify-content: center;">
            <button id="singleDeleteBtn" style="
              background: #dc3545;
              color: white;
              border: none;
              padding: 12px 24px;
              border-radius: 5px;
              cursor: pointer;
              font-size: 14px;
              font-weight: bold;
            ">只刪除這一個節目</button>
            <button id="batchDeleteBtn" style="
              background: #fd7e14;
              color: white;
              border: none;
              padding: 12px 24px;
              border-radius: 5px;
              cursor: pointer;
              font-size: 14px;
              font-weight: bold;
            ">批量刪除所有相同節目 (${duplicateEvents.length} 個)</button>
            <button id="cancelBtn" style="
              background: #6c757d;
              color: white;
              border: none;
              padding: 12px 24px;
              border-radius: 5px;
              cursor: pointer;
              font-size: 14px;
            ">取消</button>
          </div>
          <div style="margin-top: 15px; font-size: 12px; color: #666;">
            ⚠️ 此操作將同時從 Contentful 中刪除節目，無法復原！
          </div>
        </div>
      `;
      
      console.log('📋 將對話框添加到頁面...');
      document.body.appendChild(dialog);
      console.log('📋 對話框已添加到頁面');
      
      return new Promise((resolve) => {
        console.log('📋 設置按鈕事件監聽器...');
        
        const singleBtn = dialog.querySelector('#singleDeleteBtn');
        const batchBtn = dialog.querySelector('#batchDeleteBtn');
        const cancelBtn = dialog.querySelector('#cancelBtn');
        
        if (singleBtn) {
          singleBtn.onclick = () => {
            console.log('📋 用戶點擊：只刪除這一個節目');
            document.body.removeChild(dialog);
            resolve('single');
          };
        } else {
          console.error('❌ 找不到單個刪除按鈕');
        }
        
        if (batchBtn) {
          batchBtn.onclick = () => {
            console.log('📋 用戶點擊：批量刪除');
            document.body.removeChild(dialog);
            resolve('batch');
          };
        } else {
          console.error('❌ 找不到批量刪除按鈕');
        }
        
        if (cancelBtn) {
          cancelBtn.onclick = () => {
            console.log('📋 用戶點擊：取消');
            document.body.removeChild(dialog);
            resolve('cancel');
          };
        } else {
          console.error('❌ 找不到取消按鈕');
        }
        
        // 點擊背景關閉
        dialog.onclick = (e) => {
          if (e.target === dialog) {
            console.log('📋 用戶點擊背景：取消');
            document.body.removeChild(dialog);
            resolve('cancel');
          }
        };
        
        console.log('📋 對話框已準備就緒，等待用戶選擇...');
      });
    }

    // 查找相同時間槽和相同 YouTube ID 的節目
    function findDuplicateEvents(eventToDelete, currentDate, currentTime) {
      const duplicates = [];
      const targetYouTubeId = eventToDelete.youtubeId;
      const targetTime = currentTime;
      
      if (!targetYouTubeId) {
        console.log('ℹ️ 節目沒有 YouTube ID，不進行批量刪除');
        return duplicates;
      }

      console.log('🔍 查找相同時間槽和 YouTube ID 的節目...');
      
      // 獲取今天的日期
      const today = new Date().toISOString().split('T')[0];
      console.log('今天日期:', today);
      
      // 遍歷所有日期
      Object.keys(events).forEach(date => {
      if (events[date]) {
          events[date].forEach(event => {
            // 檢查是否是相同時間槽和相同 YouTube ID
            if (event.time === targetTime && 
                event.youtubeId === targetYouTubeId && 
                event.title === eventToDelete.title &&
                !(date === currentDate && event.time === currentTime)) { // 排除當前要刪除的節目
              
              // 只包含今天之後的節目（包括今天）
              if (date >= today) {
                duplicates.push({
                  date: date,
                  time: event.time,
                  event: event
                });
              } else {
                console.log(`⏰ 跳過過去的節目: ${date} ${event.time}`);
              }
            }
          });
        }
      });

      console.log(`✅ 找到 ${duplicates.length} 個今天之後的重複節目:`, duplicates);
      return duplicates;
    }

    // 批量刪除節目
    async function batchDeleteEvents(duplicateEvents) {
      console.log('🗑️ 開始批量刪除節目...');
      
      // 創建進度條對話框
      const progressDialog = createProgressDialog(duplicateEvents.length);
      document.body.appendChild(progressDialog);
      
      let successCount = 0;
      let failCount = 0;
      let currentIndex = 0;

      try {
        for (const duplicate of duplicateEvents) {
          currentIndex++;
          
          // 更新進度條
          updateProgress(progressDialog, currentIndex, duplicateEvents.length, duplicate);
          
          try {
            console.log(`🗑️ 刪除節目 ${currentIndex}/${duplicateEvents.length}: ${duplicate.date} ${duplicate.time}`);
            
            // 從 Contentful 刪除
            if (duplicate.event.contentfulId) {
              try {
                await deleteFromContentful(duplicate.event.contentfulId);
                console.log(`✅ 成功從 Contentful 刪除: ${duplicate.date} ${duplicate.time}`);
              } catch (error) {
                console.error(`❌ 從 Contentful 刪除失敗: ${duplicate.date} ${duplicate.time}`, error);
                failCount++;
                continue; // 跳過本地刪除
              }
            }

            // 從本地刪除
            if (events[duplicate.date]) {
              events[duplicate.date] = events[duplicate.date].filter(event => 
                !(event.time === duplicate.time && event.youtubeId === duplicate.event.youtubeId)
              );
              
              if (events[duplicate.date].length === 0) {
                delete events[duplicate.date];
              }
            }

            successCount++;
            
            // 添加小延遲，讓用戶看到進度
            await new Promise(resolve => setTimeout(resolve, 100));
            
          } catch (error) {
            console.error(`❌ 刪除失敗: ${duplicate.date} ${duplicate.time}`, error);
            failCount++;
          }
        }

        // 完成後更新進度條
        updateProgressComplete(progressDialog, successCount, failCount);
        
        // 等待 2 秒後關閉進度條
        setTimeout(() => {
          document.body.removeChild(progressDialog);
          showStatus(`批量刪除完成: 成功 ${successCount} 個，失敗 ${failCount} 個`, successCount > 0 ? 'success' : 'error');
        }, 2000);

      } catch (error) {
        console.error('❌ 批量刪除過程中發生錯誤:', error);
        document.body.removeChild(progressDialog);
        showStatus('批量刪除過程中發生錯誤: ' + error.message, 'error');
      }
    }

    // 創建進度條對話框
    function createProgressDialog(totalCount) {
      const dialog = document.createElement('div');
      dialog.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        font-family: Arial, sans-serif;
      `;
      
      dialog.innerHTML = `
        <div style="
          background: white;
          padding: 30px;
          border-radius: 10px;
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
          max-width: 500px;
          width: 90%;
          text-align: center;
        ">
          <h3 style="margin: 0 0 20px 0; color: #333;">正在批量刪除節目</h3>
          <div style="margin-bottom: 20px;">
            <div style="
              width: 100%;
              height: 20px;
              background: #f0f0f0;
              border-radius: 10px;
              overflow: hidden;
              margin-bottom: 10px;
            ">
              <div id="progressBar" style="
                width: 0%;
                height: 100%;
                background: linear-gradient(90deg, #4CAF50, #45a049);
                transition: width 0.3s ease;
                border-radius: 10px;
              "></div>
            </div>
            <div id="progressText" style="color: #666; font-size: 14px;">準備中...</div>
          </div>
          <div id="currentItem" style="
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 12px;
            color: #666;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
          ">等待開始...</div>
          <div id="statusText" style="color: #333; font-weight: bold;">正在刪除節目...</div>
        </div>
      `;
      
      return dialog;
    }

    // 更新進度條
    function updateProgress(dialog, current, total, duplicate) {
      const progressBar = dialog.querySelector('#progressBar');
      const progressText = dialog.querySelector('#progressText');
      const currentItem = dialog.querySelector('#currentItem');
      const statusText = dialog.querySelector('#statusText');
      
      const percentage = Math.round((current / total) * 100);
      
      progressBar.style.width = percentage + '%';
      progressText.textContent = `${current} / ${total} (${percentage}%)`;
      currentItem.textContent = `正在刪除: ${duplicate.date} ${duplicate.time} - ${duplicate.event.title}`;
      statusText.textContent = `正在刪除節目...`;
    }

    // 更新完成狀態
    function updateProgressComplete(dialog, successCount, failCount) {
      const progressBar = dialog.querySelector('#progressBar');
      const progressText = dialog.querySelector('#progressText');
      const currentItem = dialog.querySelector('#currentItem');
      const statusText = dialog.querySelector('#statusText');
      
      progressBar.style.width = '100%';
      progressBar.style.background = failCount > 0 ? 'linear-gradient(90deg, #ff9800, #f57c00)' : 'linear-gradient(90deg, #4CAF50, #45a049)';
      progressText.textContent = `完成 (${successCount + failCount} / ${successCount + failCount})`;
      currentItem.textContent = `批量刪除完成！`;
      statusText.textContent = `成功: ${successCount} 個，失敗: ${failCount} 個`;
    }

    // 刪除單個節目
    async function deleteSingleEvent(eventToDelete, date, time) {
      console.log('🗑️ 刪除單個節目...');
      console.log('要刪除的節目詳情:', eventToDelete);

      let contentfulDeleteSuccess = false;

      // 如果有 Contentful ID，從 Contentful 中刪除
      if (eventToDelete.contentfulId) {
        console.log('🗑️ 從 Contentful 刪除節目:', eventToDelete.contentfulId);
        showStatus('正在從 Contentful 刪除節目...', 'info');
        
        try {
          await deleteFromContentful(eventToDelete.contentfulId);
          console.log('✅ 成功從 Contentful 刪除節目');
          showStatus('已從 Contentful 刪除節目', 'success');
          contentfulDeleteSuccess = true;
        } catch (error) {
          console.error('❌ 從 Contentful 刪除失敗:', error);
          showStatus('從 Contentful 刪除失敗: ' + error.message, 'error');
          contentfulDeleteSuccess = false;
        }
      } else {
        console.log('ℹ️ 節目沒有 Contentful ID，只從本地刪除');
        contentfulDeleteSuccess = true; // 沒有 Contentful ID 視為成功
      }

      // 從本地事件中刪除
      console.log('🗑️ 從本地刪除節目...');
      console.log('刪除前 events[date]:', events[date]);
      
      if (events[date]) {
        const beforeCount = events[date].length;
        
        // 更精確的刪除邏輯：根據時間和 YouTube ID 匹配
        events[date] = events[date].filter(event => {
          const timeMatch = event.time === time;
          const youtubeMatch = event.youtubeId === eventToDelete.youtubeId;
          const titleMatch = event.title === eventToDelete.title;
          
          // 如果時間、YouTube ID 和標題都匹配，則刪除
          const shouldDelete = timeMatch && youtubeMatch && titleMatch;
          
          if (shouldDelete) {
            console.log('🗑️ 刪除本地節目:', event);
          }
          
          return !shouldDelete;
        });
        
        const afterCount = events[date].length;
        console.log(`刪除前後數量: ${beforeCount} → ${afterCount}`);
        
        if (events[date].length === 0) {
          console.log('🗑️ 刪除空的日期');
          delete events[date];
        }
      }

      console.log('刪除後 events:', events);
      
      if (contentfulDeleteSuccess) {
        showStatus('節目已成功刪除', 'success');
      } else {
        showStatus('本地刪除成功，但 Contentful 刪除失敗', 'warning');
      }
    }

    // 從 Contentful 刪除節目
    async function deleteFromContentful(entryId) {
      try {
        console.log('🗑️ 開始從 Contentful 刪除節目:', entryId);
        
        // 檢查 Management SDK
        if (typeof contentfulManagement === 'undefined') {
          throw new Error('Management SDK 未載入');
        }

        // 檢查 API Token
        const managementToken = window.CONTENTFUL_CONFIG?.MANAGEMENT_TOKEN || window.CONTENTFUL_MANAGEMENT_TOKEN;
        if (!managementToken) {
          throw new Error('Management Token 未設定');
        }

        console.log('✅ Management SDK 和 Token 檢查通過');

        // 創建 Management 客戶端
        const managementClient = contentfulManagement.createClient({
          accessToken: managementToken
        });

        // 獲取 Space
        const spaceId = window.CONTENTFUL_CONFIG?.SPACE_ID || 'os5wf90ljenp';
        console.log('📡 連接到 Space:', spaceId);
        const space = await managementClient.getSpace(spaceId);
        
        // 獲取 Environment
        console.log('📡 連接到 Environment: master');
        const environment = await space.getEnvironment('master');
        
        // 獲取 Entry
        console.log('📡 獲取 Entry:', entryId);
        const entry = await environment.getEntry(entryId);
        console.log('✅ Entry 獲取成功:', entry.sys.id);
        
        // 取消發布 Entry（如果已發布）
        if (entry.isPublished()) {
          console.log('📡 取消發布 Entry...');
          await entry.unpublish();
          console.log('✅ Entry 取消發布成功');
        } else {
          console.log('ℹ️ Entry 未發布，跳過取消發布步驟');
        }
        
        // 刪除 Entry
        console.log('📡 刪除 Entry...');
        await entry.delete();
        console.log('✅ Entry 刪除成功');
        
        console.log('✅ 成功從 Contentful 刪除節目:', entryId);
        return true;
        
      } catch (error) {
        console.error('❌ 從 Contentful 刪除節目失敗:', error);
        console.error('錯誤詳情:', {
          message: error.message,
          status: error.status,
          statusText: error.statusText,
          details: error.details
        });
        throw error;
      }
    }

    function saveEvents() {
      // 不再使用 localStorage，直接使用 Contentful 作為唯一數據源
      console.log('✅ 節目資料已同步到 Contentful');
    }

    function loadEvents() {
      // 完全從 Contentful 載入，清空本地數據
      console.log('🔄 清空本地數據，完全從 Contentful 載入...');
      events = {}; // 清空本地事件數據
      
      loadEventsFromContentful().then(() => {
        console.log('✅ 從 Contentful 載入節目資料成功');
        showStatus('✅ 已從 Contentful 重新載入所有節目數據', 'success');
      }).catch((error) => {
        console.error('❌ 從 Contentful 載入節目資料失敗:', error);
        showStatus('載入節目資料失敗，請檢查 Contentful 連線', 'error');
      });
    }

    // 從備註中提取分類
    function extractCategoryFromNotes(notes) {
      if (!notes) return '';
      const match = notes.match(/\[分類:(.*?)\]/);
      return match ? match[1] : '';
    }

    // 從備註中提取主題
    function extractTopicsFromNotes(notes) {
      if (!notes) return [];
      const matches = notes.match(/\[主題:(.*?)\]/g);
      if (!matches) return [];
      
      // 提取所有主題標記的內容
      const topics = matches.map(m => m.replace(/\[主題:(.*?)\]/, '$1'));
      
      // 如果主題包含逗號分隔的多個主題，則分割它們
      const allTopics = [];
      topics.forEach(topic => {
        if (topic.includes(',')) {
          // 分割逗號分隔的主題
          const splitTopics = topic.split(',').map(t => t.trim()).filter(t => t);
          allTopics.push(...splitTopics);
        } else {
          allTopics.push(topic.trim());
        }
      });
      
      return allTopics;
    }

    // 從 Contentful 載入節目
    async function loadEventsFromContentful() {
      try {
        console.log('正在從 Contentful 載入節目...');
        
        // 檢查 Contentful 是否可用
        if (typeof contentful === 'undefined') {
          throw new Error('Contentful SDK 未載入');
        }

        // 創建 Contentful 客戶端 (使用 Delivery Token 讀取資料)
        const client = contentful.createClient({
          space: 'os5wf90ljenp',
          accessToken: 'lODH-WLwHwVZv7O4rFdBWjSnrzaQWGD4koeOZ1Dypj0'
        });

        // 獲取所有節目（使用分頁載入以確保載入到 10/31）
        let allItems = [];
        let skip = 0;
        const limit = 1000; // Contentful API 最大限制為 1000
        let hasMore = true;
        
        while (hasMore) {
        const response = await client.getEntries({
          content_type: 'scheduleItem',
            order: 'fields.airDate',
            limit: limit,
            skip: skip
          });
          
          allItems = allItems.concat(response.items);
          console.log(`📥 載入第 ${Math.floor(skip/limit) + 1} 頁: ${response.items.length} 個節目 (總計: ${allItems.length})`);
          
          // 檢查是否還有更多資料
          hasMore = response.items.length === limit;
          skip += limit;
          
          // 如果已經載入到 10/31 之後的節目，可以停止載入
          const hasOct31OrLater = response.items.some(item => {
            const airDate = item.fields.airDate;
            return airDate && airDate >= '2025-10-31';
          });
          
          if (hasOct31OrLater) {
            console.log('✅ 已載入到 10/31 及之後的節目，停止分頁載入');
            break;
          }
        }

        console.log(`📊 總共從 Contentful 載入 ${allItems.length} 個節目`);
        
        // 檢查主題標記統計
        let programsWithTopics = 0;
        let programsWithCategory = 0;
        let programsWithNoTags = 0;
        
        allItems.forEach(item => {
          const notes = String(item.fields.notes || '');
          const hasTopics = notes.includes('[主題:');
          const hasCategory = notes.includes('[分類:');
          
          if (hasTopics) programsWithTopics++;
          if (hasCategory) programsWithCategory++;
          if (!hasTopics && !hasCategory) programsWithNoTags++;
        });
        
        console.log('📊 節目標記統計:');
        console.log(`  - 有主題標記的節目: ${programsWithTopics} 個`);
        console.log(`  - 有分類標記的節目: ${programsWithCategory} 個`);
        console.log(`  - 沒有任何標記的節目: ${programsWithNoTags} 個`);
        
        // 調試：檢查所有節目的日期
        console.log('🔍 所有節目的日期分佈:');
        const dateCounts = {};
        allItems.forEach(item => {
          const airDate = item.fields.airDate;
          if (airDate) {
            dateCounts[airDate] = (dateCounts[airDate] || 0) + 1;
          }
        });
        
        // 顯示所有日期
        Object.keys(dateCounts).sort().forEach(date => {
          console.log(`📅 ${date}: ${dateCounts[date]} 個節目`);
        });
        
        // 檢查是否有超過 10/11 的節目
        const laterDates = Object.keys(dateCounts).filter(date => date > '2025-10-11');
        console.log('🔍 超過 10/11 的日期:', laterDates);
        if (laterDates.length > 0) {
          laterDates.forEach(date => {
            console.log(`📅 ${date}: ${dateCounts[date]} 個節目`);
          });
        } else {
          console.log('❌ 沒有找到超過 10/11 的節目');
        }
        
        // 特別檢查 10/2 和 10/31 - 檢查所有可能的日期格式
        const oct2Items = allItems.filter(item => {
          const airDate = item.fields.airDate;
          if (!airDate) return false;
          
          // 檢查多種日期格式
          const dateStr = String(airDate);
          return dateStr.includes('2025-10-02') || 
                 dateStr.includes('2025-10-2') ||
                 dateStr.includes('10-02') ||
                 dateStr.includes('10/02');
        });
        
        const oct31Items = allItems.filter(item => {
          const airDate = item.fields.airDate;
          if (!airDate) return false;
          
          // 檢查多種日期格式
          const dateStr = String(airDate);
          return dateStr.includes('2025-10-31') || 
                 dateStr.includes('2025-10-31') ||
                 dateStr.includes('10-31') ||
                 dateStr.includes('10/31');
        });
        
        console.log('🔍 Contentful 中 10/2 的節目數量:', oct2Items.length);
        if (oct2Items.length > 0) {
          oct2Items.forEach((item, index) => {
            console.log(`10/2 節目 ${index + 1}:`, {
          id: item.sys.id,
          title: item.fields.title,
          airDate: item.fields.airDate,
              notes: item.fields.notes,
              block: item.fields.block,
              slotIndex: item.fields.slotIndex
            });
          });
        } else {
          console.log('❌ 沒有找到 10/2 的節目');
        }
        
        console.log('🔍 Contentful 中 10/31 的節目數量:', oct31Items.length);
        if (oct31Items.length > 0) {
          oct31Items.forEach((item, index) => {
            console.log(`10/31 節目 ${index + 1}:`, {
              id: item.sys.id,
              title: item.fields.title,
              airDate: item.fields.airDate,
              notes: item.fields.notes,
              block: item.fields.block,
              slotIndex: item.fields.slotIndex
            });
          });
        } else {
          console.log('❌ 沒有找到 10/31 的節目');
          
          // 檢查所有節目的日期格式
          console.log('🔍 檢查所有節目的日期格式:');
          response.items.slice(0, 5).forEach((item, index) => {
            console.log(`節目 ${index + 1}:`, {
              title: item.fields.title,
              airDate: item.fields.airDate,
              airDateType: typeof item.fields.airDate
            });
          });
        }
        
        console.log('載入的節目詳情:', allItems.map(item => ({
          id: item.sys.id,
          title: item.fields.title,
          airDate: item.fields.airDate,
          notes: item.fields.notes,
          isPremiere: item.fields.isPremiere,
          status: item.fields.status
        })));

        // 清空現有事件
        events = {};

        // 轉換 Contentful 資料為本地格式
        allItems.forEach(item => {
          const fields = item.fields;
          const airDate = fields.airDate || new Date().toISOString().split('T')[0];
          
          // 從備註中提取具體時間，格式為 [時間:XX:XX]
          const notes = String(fields.notes || '');
          const timeMatch = notes.match(/\[時間:(\d{2}:\d{2})\]/);
          let airTime;
          
          if (timeMatch) {
            airTime = timeMatch[1];
            console.log(`✅ 從備註提取時間: ${airTime} for ${fields.title}`);
          } else {
            // 如果沒有時間標記，嘗試從其他方式推斷時間
            airTime = convertBlockToTime(fields.block || '12-18');
            console.log(`⚠️ 沒有時間標記，使用時段轉換: ${fields.block} -> ${airTime} for ${fields.title}`);
          }
          
          // 使用具體時間，如果沒有則轉換時段
          const time = airTime;
          
          if (!events[airDate]) {
            events[airDate] = [];
          }

          // 從備註中提取 YouTube ID
          const youtubeMatch = notes.match(/\[YouTube:([^\]]+)\]/);
          const youtubeId = youtubeMatch ? youtubeMatch[1] : '';
          
          // 從備註中提取時長
          const durationMatch = notes.match(/\[時長:(\d+)分鐘\]/);
          const duration = durationMatch ? parseInt(durationMatch[1]) : 30;
          
          // 從備註中提取狀態
          const statusMatch = notes.match(/\[狀態:(.*?)\]/);
          const status = statusMatch ? statusMatch[1] : '重播';
          
          // 從備註中提取縮圖
          const thumbnailMatch = notes.match(/\[縮圖:([^\]]+)\]/);
          const thumbnail = thumbnailMatch ? thumbnailMatch[1] : (youtubeId ? `https://img.youtube.com/vi/${youtubeId}/maxresdefault.jpg` : '');
          
          // 調試資訊
          if (youtubeId) {
            console.log('✅ 從 Contentful 提取到 YouTube ID:', youtubeId, 'for', fields.title);
          } else if (notes.includes('[YouTube:')) {
            console.log('⚠️ 備註中有 YouTube 標記但提取失敗:', notes);
          }
          
          // 從備註中提取分類和主題
          const category = extractCategoryFromNotes(notes);
          const topics = extractTopicsFromNotes(notes);
          
          // 調試主題提取
          if (topics && topics.length > 0) {
            console.log('✅ 提取到主題:', fields.title, '主題:', topics);
          } else if (notes.includes('[主題:')) {
            console.log('⚠️ 備註中有主題標記但提取失敗:', fields.title, '備註:', notes);
          } else {
            console.log('❌ 沒有主題標記:', fields.title, '備註長度:', notes.length, '備註預覽:', notes.substring(0, 100));
          }
          
          // 清理描述，移除時間標記、YouTube 標記、分類標記和主題標記
          const cleanDescription = notes
            .replace(/\[時間:\d{2}:\d{2}\]/, '')
            .replace(/\[YouTube:[^\]]+\]/, '')
            .replace(/\[分類:[^\]]+\]/, '')
            .replace(/\[主題:[^\]]+\]/g, '')
            .trim();
          
          // 檢查是否已存在相同的節目（避免重複載入）
          // 1. 首先檢查是否有相同的 Contentful ID
          const existingEventIndex = events[airDate].findIndex(event => event.contentfulId === item.sys.id);
          if (existingEventIndex !== -1) {
            console.log('⚠️ 發現重複 ID 節目，更新現有節目:', time, fields.title);
            // 更新現有節目
            events[airDate][existingEventIndex] = {
              id: item.sys.id,
              title: fields.title || '未命名節目',
              time: time,
              duration: duration,
              category: category,
              description: cleanDescription,
              videoType: youtubeId ? 'YouTube' : (fields.videoType || 'YouTube'),
              youtubeId: youtubeId,
              thumbnail: thumbnail,
              status: status,
              topics: topics,
              published: true,
              publishedAt: item.sys.createdAt,
              contentfulId: item.sys.id
            };
          } else {
            // 2. 檢查是否有完全相同的節目（相同時間、標題、YouTube ID）
            // 這會處理編輯後重新上架造成的重複問題
            const duplicateEventIndex = events[airDate].findIndex(event => 
              event.time === time && 
              event.title === (fields.title || '未命名節目') && 
              event.youtubeId === youtubeId &&
              event.description === cleanDescription
            );
            
            if (duplicateEventIndex !== -1) {
              console.log('⚠️ 發現完全相同節目（可能是編輯後重新上架），跳過重複:', time, fields.title, youtubeId);
              // 跳過重複的節目，但保留最新的 Contentful ID 以便後續更新
              events[airDate][duplicateEventIndex].contentfulId = item.sys.id;
              events[airDate][duplicateEventIndex].publishedAt = item.sys.createdAt;
            } else {
              // 添加新節目（允許相同時間有不同的節目）
              console.log('✅ 添加新節目:', time, fields.title);
          events[airDate].push({
            id: item.sys.id,
            title: fields.title || '未命名節目',
            time: time,
            duration: duration,
            category: category,
            description: cleanDescription,
            videoType: youtubeId ? 'YouTube' : (fields.videoType || 'YouTube'),
            youtubeId: youtubeId,
            thumbnail: thumbnail,
            status: status,
            topics: topics,
            published: true,
            publishedAt: item.sys.createdAt,
            contentfulId: item.sys.id
          });
            }
          }
        });

        // 按時間排序（不移除重複節目，允許相同時間有多個節目）
        Object.keys(events).forEach(date => {
          events[date].sort((a, b) => a.time.localeCompare(b.time));
          console.log(`📅 ${date}: 載入 ${events[date].length} 個節目`);
        });

        // 重新渲染日曆視圖（直接使用 Contentful 數據）
        renderCurrentView();
        
        console.log('✅ 從 Contentful 載入節目成功');
        showStatus('✅ 已從 Contentful 載入節目', 'success');
        
        return true;
      } catch (error) {
        console.error('❌ 從 Contentful 載入節目失敗:', error);
        console.error('錯誤詳情:', {
          message: error.message,
          status: error.status,
          statusText: error.statusText,
          details: error.details
        });
        showStatus('⚠️ 從 Contentful 載入失敗，使用本地資料', 'warning');
        throw error;
      }
    }

    // 轉換時段為具體時間
    function convertBlockToTime(block) {
      switch (block) {
        case '00-06': return '02:00';
        case '06-12': return '11:30';
        case '12-18': return '14:00'; // 預設值，但實際時間應該從 notes 中提取
        case '18-24': return '22:00';
        default: return '14:00';
      }
    }

    function debugEvents() {
      console.log('=== 節目資料調試 ===');
      console.log('所有節目資料:', events);

      const eventDates = Object.keys(events);
      console.log('有節目的日期:', eventDates);

      eventDates.forEach(date => {
        const dayEvents = events[date];
        console.log(`日期 ${date} (${new Date(date).toLocaleDateString('zh-TW')}):`, dayEvents);
        
        // 檢查每個節目的 YouTube ID
        dayEvents.forEach(event => {
          if (event.youtubeId) {
            console.log(`✅ 節目 "${event.title}" 有 YouTube ID: ${event.youtubeId}`);
          } else {
            console.log(`❌ 節目 "${event.title}" 沒有 YouTube ID`);
          }
        });
        
        // 檢查重複時間槽
        const timeGroups = {};
        dayEvents.forEach(event => {
          if (!timeGroups[event.time]) {
            timeGroups[event.time] = [];
          }
          timeGroups[event.time].push(event);
        });
        
        Object.keys(timeGroups).forEach(time => {
          if (timeGroups[time].length > 1) {
            console.log(`⚠️ 發現重複時間槽 ${time}:`, timeGroups[time].map(e => e.title));
          }
        });
      });

      const today = new Date();
      const todayString = today.getFullYear() + '-' +
                         String(today.getMonth() + 1).padStart(2, '0') + '-' +
                         String(today.getDate()).padStart(2, '0');
      const currentDateString = currentDate.getFullYear() + '-' +
                               String(currentDate.getMonth() + 1).padStart(2, '0') + '-' +
                               String(currentDate.getDate()).padStart(2, '0');
      console.log('今天日期:', todayString);
      console.log('當前顯示日期:', currentDateString);

      showStatus('調試資訊已輸出到控制台', 'info');
    }

    async function syncAllToContentful() {
      try {
        showStatus('正在檢查 Contentful 真實連線...', 'info');
        
        // 先清理測試資料
        const removedCount = clearOldTestData();
        if (removedCount > 0) {
          showStatus(`已清理 ${removedCount} 個測試節目，繼續同步...`, 'info');
        }

        // 檢查 Management SDK 是否載入
        if (typeof contentfulManagement === 'undefined') {
          throw new Error('Management SDK 未載入，請先載入 Management SDK');
        }

        if (typeof window.contentfulManagement === 'undefined') {
          throw new Error('window.contentfulManagement 不可用');
        }

        showStatus('✅ Contentful 真實連線成功，開始同步...', 'success');

        const calendarEvents = JSON.parse(localStorage.getItem('calendar_events') || '{}');
        const allPrograms = [];

        Object.keys(calendarEvents).forEach(date => {
          calendarEvents[date].forEach(event => {
            allPrograms.push({
              title: event.title,
              airDate: date,
              airTime: event.time,
              duration: event.duration,
              category: event.category,
              description: event.description || '',
              status: event.status,
              videoType: event.videoType || '',
              youtubeId: event.youtubeId || '',
              mp4File: event.mp4File || ''
            });
          });
        });

        if (allPrograms.length === 0) {
          showStatus('沒有節目需要同步', 'warning');
          return;
        }

        showStatus(`開始同步 ${allPrograms.length} 個節目到 Contentful...`, 'info');

        let successCount = 0;
        let failCount = 0;

        let skipCount = 0;
        
        for (const program of allPrograms) {
          try {
            console.log('正在上架節目:', program);
            const result = await uploadProgramSimple(program);
            if (result.success) {
              if (result.skipped) {
                skipCount++;
                console.log('⏭️ 節目已存在，跳過:', program.title, result.entryId);
              } else {
                successCount++;
                console.log('✅ 節目上架成功:', program.title, result.entryId);
              }
            } else {
              failCount++;
              console.error('❌ 同步節目失敗:', program.title, result.error);
            }
          } catch (error) {
            console.error('❌ 同步節目異常:', program.title, error);
            failCount++;
          }
        }

        if (failCount === 0) {
          if (skipCount > 0) {
            showStatus(`✅ 同步完成：${successCount} 個新節目上架成功，${skipCount} 個重複節目已跳過`, 'success');
          } else {
            showStatus(`✅ 所有 ${successCount} 個節目同步成功到 Contentful！`, 'success');
          }
        } else {
          showStatus(`⚠️ 同步完成：${successCount} 成功，${skipCount} 跳過，${failCount} 失敗`, 'warning');
        }

        console.log('同步結果:', { successCount, skipCount, failCount });

      } catch (error) {
        console.error('批量同步失敗:', error);
        showStatus('❌ 批量同步失敗：' + error.message, 'error');
      }
    }

    async function showAllVideos() {
      try {
        showStatus('正在載入所有影片資料...', 'info');
        
        // 創建 Contentful 客戶端
        const client = contentful.createClient({
          space: 'os5wf90ljenp',
          accessToken: 'lODH-WLwHwVZv7O4rFdBWjSnrzaQWGD4koeOZ1Dypj0'
        });

        // 獲取所有影片
        const response = await client.getEntries({
          content_type: 'video',
          order: '-sys.updatedAt',
          limit: 1000
        });

        const videos = response.items || [];
        
        if (videos.length === 0) {
          showStatus('沒有找到任何影片', 'warning');
          return;
        }

        showStatus(`找到 ${videos.length} 個影片`, 'success');

        // 創建模態框
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.id = 'videoManagementModal';
        modal.style.display = 'block';
        modal.style.zIndex = '10000';
        modal.style.position = 'fixed';
        modal.style.top = '0';
        modal.style.left = '0';
        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
        modal.style.display = 'flex';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';
        modal.style.padding = '10px';
        modal.style.overflowY = 'auto';

        // 處理影片資料
        const processedVideos = videos.map(video => {
          const fields = video.fields || {};
          const pick = (obj, keys) => {
            for (const k of keys) {
              if (obj && obj[k] != null && obj[k] !== '') return obj[k];
            }
            return '';
          };

          const title = pick(fields, ['title']);
          const description = pick(fields, ['description']);
          const youtubeId = pick(fields, ['youTubeId']);
          const mp4Url = pick(fields, ['mp4Url']);
          const tags = Array.isArray(fields.tags) ? fields.tags : [];
          // 檢查 HERO 影片標記（使用 isHero 欄位）
          const isHero = fields.isHero === true || 
                        fields.isHero === 'true' || 
                        fields.isHero === 1 || 
                        fields.isHero === '1' ||
                        fields['isHero'] === true ||
                        fields['isHero'] === 'true' ||
                        fields['isHero'] === 1 ||
                        fields['isHero'] === '1' ||
                        false;
          
          // 檢查精選節目推薦標記（使用 isFeatured 欄位）
          const isFeatured = fields.isFeatured === true || 
                            fields.isFeatured === 'true' || 
                            fields.isFeatured === 1 || 
                            fields.isFeatured === '1' ||
                            fields['isFeatured'] === true ||
                            fields['isFeatured'] === 'true' ||
                            fields['isFeatured'] === 1 ||
                            fields['isFeatured'] === '1' ||
                            false;
          
          // 調試信息：檢查兩個欄位
          if (fields.isHero !== undefined || fields.isFeatured !== undefined) {
            console.log('🔍 影片狀態檢查:', {
              title: title,
              isHero: fields.isHero,
              isHeroType: typeof fields.isHero,
              isFeatured: fields.isFeatured,
              isFeaturedType: typeof fields.isFeatured,
              isHeroResult: isHero,
              isFeaturedResult: isFeatured
            });
          }
          
          const category = pick(fields, ['category', '分類']);
          
          let thumbnail = fields.thumbnail?.fields?.file?.url || '';
          if (thumbnail && !thumbnail.startsWith('http')) {
            thumbnail = 'https:' + thumbnail;
          }
          if (!thumbnail && youtubeId) {
            thumbnail = `https://i.ytimg.com/vi/${youtubeId}/hqdefault.jpg`;
          }

          return {
            id: video.sys.id,
            title: title || '未命名影片',
            description: description || '',
            youtubeId: youtubeId || '',
            mp4Url: mp4Url || '',
            tags: tags,
            isHero: isHero,
            isFeatured: isFeatured,
            category: category || '未分類',
            thumbnail: thumbnail || 'https://images.unsplash.com/photo-1485846234645-a62644f84728?w=400&h=225&fit=crop',
            createdAt: video.sys.createdAt,
            updatedAt: video.sys.updatedAt
          };
        });

        // 創建搜索和篩選界面
        const searchHtml = `
          <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <div style="display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap;">
              <input type="text" id="videoSearch" placeholder="搜索影片標題..." 
                     style="flex: 1; min-width: 200px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
              <select id="categoryFilter" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                <option value="">所有分類</option>
                <option value="亞洲">亞洲</option>
                <option value="歐洲">歐洲</option>
                <option value="北美洲">北美洲</option>
                <option value="南美洲">南美洲</option>
                <option value="非洲">非洲</option>
                <option value="大洋洲">大洋洲</option>
                <option value="南極洲">南極洲</option>
                <option value="其他">其他</option>
              </select>
              <select id="heroFilter" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                <option value="">所有影片</option>
                <option value="hero">🏆 HERO 影片</option>
                <option value="normal">一般影片</option>
              </select>
              <select id="featuredFilter" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                <option value="">所有影片</option>
                <option value="featured">⭐ 精選節目推薦</option>
                <option value="normal">一般影片</option>
              </select>
              <button onclick="filterVideos()" style="background: #007bff; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
                🔍 篩選
              </button>
              <button onclick="clearFilters()" style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
                🔄 清除
              </button>
            </div>
            <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
              <span style="color: #666;">共 <strong id="videoCount">${processedVideos.length}</strong> 個影片</span>
              <span style="color: #666;">🏆 HERO 影片: <strong id="heroCount" style="color: #ff6b6b;">${processedVideos.filter(v => v.isHero).length}</strong></span>
              <span style="color: #666;">⭐ 精選節目推薦: <strong id="featuredCount" style="color: #ffc107;">${processedVideos.filter(v => v.isFeatured).length}</strong></span>
              <span style="color: #666;">一般影片: <strong id="normalCount">${processedVideos.filter(v => !v.isHero && !v.isFeatured).length}</strong></span>
            </div>
          </div>
        `;

        // 創建影片列表
        const videosHtml = processedVideos.map(video => `
          <div class="video-item" data-video-id="${video.id}" data-title="${video.title.toLowerCase()}" data-category="${video.category}" data-hero="${video.isHero ? 'hero' : 'normal'}" data-featured="${video.isFeatured ? 'featured' : 'normal'}" 
               style="border: ${video.isHero ? '2px solid #ffd93d' : '1px solid #eee'}; border-radius: 8px; padding: 15px; margin-bottom: 15px; background: ${video.isHero ? 'linear-gradient(135deg, #fff9e6 0%, #ffffff 100%)' : 'white'}; display: flex; gap: 15px; box-shadow: ${video.isHero ? '0 4px 12px rgba(255, 215, 0, 0.3)' : 'none'};">
            <div style="flex-shrink: 0;">
              <img src="${video.thumbnail}" alt="${video.title}" 
                   style="width: 120px; height: 68px; object-fit: cover; border-radius: 4px; cursor: pointer;"
                   onclick="window.open('${video.youtubeId ? `https://www.youtube.com/watch?v=${video.youtubeId}` : video.mp4Url || '#'}', '_blank')">
            </div>
            <div style="flex: 1; min-width: 0;">
              <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                <h4 style="margin: 0; color: #333; font-size: 1.1rem; line-height: 1.3;">
                  ${video.isHero ? '<span style="background: linear-gradient(45deg, #ff6b6b, #ffd93d); color: #000; padding: 2px 8px; border-radius: 4px; font-size: 0.7rem; font-weight: bold; margin-right: 8px; text-shadow: 1px 1px 2px rgba(0,0,0,0.1);">🏆 HERO</span>' : ''}${video.title}
                </h4>
                <div style="display: flex; gap: 5px; flex-shrink: 0;">
                  ${video.isFeatured ? '<span style="background: #ffc107; color: #000; padding: 2px 6px; border-radius: 12px; font-size: 0.7rem; font-weight: bold;">⭐ 精選</span>' : ''}
                  <span style="background: #007bff; color: white; padding: 2px 6px; border-radius: 12px; font-size: 0.7rem;">${video.category}</span>
                </div>
              </div>
              <div style="color: #666; font-size: 0.9rem; margin-bottom: 8px; line-height: 1.4;">
                ${video.description ? video.description : '<span style="color: #999; font-style: italic;">📝 點擊「編輯」按鈕添加影片描述</span>'}
              </div>
              <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 8px;">
                ${video.youtubeId ? `<span style="background: #dc3545; color: white; padding: 2px 6px; border-radius: 12px; font-size: 0.7rem;">📺 YouTube</span>` : ''}
                ${video.mp4Url ? `<span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 12px; font-size: 0.7rem;">🎬 MP4</span>` : ''}
                ${video.tags.length > 0 ? `<span style="background: #6f42c1; color: white; padding: 2px 6px; border-radius: 12px; font-size: 0.7rem;">🏷️ ${video.tags.length} 標籤</span>` : ''}
              </div>
              <div style="color: #999; font-size: 0.8rem;">
                建立: ${new Date(video.createdAt).toLocaleDateString('zh-TW')} | 
                更新: ${new Date(video.updatedAt).toLocaleDateString('zh-TW')}
              </div>
            </div>
            <div style="flex-shrink: 0; display: flex; flex-direction: column; gap: 5px;">
              <button onclick="toggleFeatured('${video.id}', ${!video.isFeatured})" 
                      style="background: ${video.isFeatured ? '#dc3545' : '#28a745'}; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                ${video.isFeatured ? '❌ 取消精選' : '⭐ 設為精選'}
              </button>
              <button onclick="editVideo('${video.id}')" 
                      style="background: #ffc107; color: #000; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                ✏️ 編輯
              </button>
              <button onclick="deleteVideo('${video.id}', '${video.title}')" 
                      style="background: #dc3545; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                🗑️ 刪除
              </button>
            </div>
          </div>
        `).join('');

        modal.innerHTML = `
          <div class="modal-content" id="videoModalContent" style="width: 98vw; max-width: 1400px; height: 95vh; max-height: 95vh; background: white; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); position: relative; margin: auto; display: flex; flex-direction: column;">
            <div class="modal-header" id="videoModalHeader" style="padding: 20px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; background: #f8f9fa; border-radius: 8px 8px 0 0;">
              <h3 style="margin: 0; color: #333;">🎬 所有影片管理 (${processedVideos.length} 個)</h3>
              <div style="display: flex; gap: 10px; align-items: center;">
                <button class="modal-close" onclick="this.closest('.modal').remove()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #999;">&times;</button>
              </div>
            </div>
            <div id="videoScrollContainer" style="flex: 1; overflow-y: auto; overflow-x: hidden; padding: 0 20px 20px; min-height: 0;">
              <style>
                #videoScrollContainer::-webkit-scrollbar {
                  width: 8px;
                }
                #videoScrollContainer::-webkit-scrollbar-track {
                  background: #f1f1f1;
                  border-radius: 4px;
                }
                #videoScrollContainer::-webkit-scrollbar-thumb {
                  background: #c1c1c1;
                  border-radius: 4px;
                }
                #videoScrollContainer::-webkit-scrollbar-thumb:hover {
                  background: #a8a8a8;
                }
              </style>
              ${searchHtml}
              <div id="videoList">
                ${videosHtml}
              </div>
            </div>
          </div>
        `;

        document.body.appendChild(modal);

        // 移除拖拽和調整大小功能，保持模態框固定置中

        // 添加篩選功能
        window.filterVideos = function() {
          const searchTerm = document.getElementById('videoSearch').value.toLowerCase();
          const categoryFilter = document.getElementById('categoryFilter').value;
          const heroFilter = document.getElementById('heroFilter').value;
          const featuredFilter = document.getElementById('featuredFilter').value;
          
          const videoItems = document.querySelectorAll('.video-item');
          let visibleCount = 0;
          let heroCount = 0;
          let featuredCount = 0;
          let normalCount = 0;
          
          videoItems.forEach(item => {
            const title = item.dataset.title;
            const category = item.dataset.category;
            const hero = item.dataset.hero;
            const featured = item.dataset.featured;
            
            const matchesSearch = !searchTerm || title.includes(searchTerm);
            const matchesCategory = !categoryFilter || category === categoryFilter;
            const matchesHero = !heroFilter || hero === heroFilter;
            const matchesFeatured = !featuredFilter || featured === featuredFilter;
            
            if (matchesSearch && matchesCategory && matchesHero && matchesFeatured) {
              item.style.display = 'flex';
              visibleCount++;
              if (hero === 'hero') heroCount++;
              if (featured === 'featured') featuredCount++;
              if (hero === 'normal' && featured === 'normal') normalCount++;
            } else {
              item.style.display = 'none';
            }
          });
          
          document.getElementById('videoCount').textContent = visibleCount;
          document.getElementById('heroCount').textContent = heroCount;
          document.getElementById('featuredCount').textContent = featuredCount;
          document.getElementById('normalCount').textContent = normalCount;
        };

        window.clearFilters = function() {
          document.getElementById('videoSearch').value = '';
          document.getElementById('categoryFilter').value = '';
          document.getElementById('heroFilter').value = '';
          document.getElementById('featuredFilter').value = '';
          window.filterVideos();
        };

        // 添加精選節目推薦切換功能
        window.toggleFeatured = async function(videoId, newFeaturedStatus) {
          try {
            console.log('🎯 toggleFeatured 函數被調用:', { videoId, newFeaturedStatus });
            showStatus('正在更新精選節目推薦狀態...', 'info');
            
            // 檢查 Management SDK
            console.log('🔍 檢查 Management SDK:', typeof contentfulManagement);
            if (typeof contentfulManagement === 'undefined') {
              console.log('📥 載入 Management SDK...');
              await loadManagementSDK();
            }
            
            if (typeof contentfulManagement === 'undefined') {
              console.error('❌ Management SDK 載入失敗');
              throw new Error('Management SDK 載入失敗');
            }
            
            // 獲取 Management Token
            const managementToken = window.CONTENTFUL_CONFIG?.MANAGEMENT_TOKEN || window.CONTENTFUL_MANAGEMENT_TOKEN;
            console.log('🔑 Management Token 狀態:', managementToken ? '已設定' : '未設定');
            
            if (!managementToken) {
              console.error('❌ Management Token 未設定');
              throw new Error('Management Token 未設定');
            }
            
            // 創建 Management 客戶端
            const client = contentfulManagement.createClient({
              accessToken: managementToken
            });
            
            const space = await client.getSpace('os5wf90ljenp');
            const environment = await space.getEnvironment('master');
            const entry = await environment.getEntry(videoId);
            
            // 更新 isFeatured 欄位
            entry.fields.isFeatured = { 'en-US': newFeaturedStatus };
            
            // 調試：檢查所有可用欄位
            console.log('🔍 檢查條目所有欄位:', Object.keys(entry.fields));
            console.log('🔍 條目完整資料:', entry.fields);
            
            // 如果設為精選，檢查是否有精選說明文字欄位
            if (newFeaturedStatus) {
              // 檢查可能的精選說明文字欄位名稱
              const possibleFeaturedDescFields = [
                '精選推薦影片說明文字',
                'featuredDescription', 
                'featuredText',
                '精選說明',
                '精選描述'
              ];
              
              let featuredDescField = null;
              for (const fieldName of possibleFeaturedDescFields) {
                if (entry.fields[fieldName]) {
                  featuredDescField = fieldName;
                  console.log(`✅ 找到精選說明欄位: ${fieldName}`);
                  break;
                }
              }
              
              if (featuredDescField) {
                const currentFeaturedDesc = entry.fields[featuredDescField];
                const currentDesc = entry.fields.description;
                
                if (!currentFeaturedDesc && currentDesc) {
                  entry.fields[featuredDescField] = { 'en-US': currentDesc['en-US'] || currentDesc };
                  console.log(`✅ 已設定精選說明文字到欄位: ${featuredDescField}`);
                }
              } else {
                console.log('⚠️ 未找到精選說明文字欄位，跳過設定');
              }
            }
            
            // 發布更新
            const updatedEntry = await entry.update();
            await updatedEntry.publish();
            
            // 更新 UI - 通過 videoId 找到對應的按鈕
            const videoItem = document.querySelector(`[data-video-id="${videoId}"]`);
            console.log('🔍 找到的 videoItem:', videoItem);
            
            const button = videoItem ? videoItem.querySelector('button[onclick*="toggleFeatured"]') : null;
            console.log('🔍 找到的 button:', button);
            
            if (button) {
              if (newFeaturedStatus) {
                button.textContent = '❌ 取消精選';
                button.style.background = '#dc3545';
              
                // 添加精選標記
                const badgeContainer = videoItem.querySelector('div[style*="flex-shrink: 0"]');
                if (badgeContainer && !badgeContainer.innerHTML.includes('⭐ 精選')) {
                  badgeContainer.insertAdjacentHTML('afterbegin', '<span style="background: #ffc107; color: #000; padding: 2px 6px; border-radius: 12px; font-size: 0.7rem; font-weight: bold;">⭐ 精選</span>');
                }
              } else {
                button.textContent = '⭐ 設為精選';
                button.style.background = '#28a745';
                
                // 移除精選標記
                const featuredBadge = videoItem.querySelector('span[style*="ffc107"]');
                if (featuredBadge) {
                  featuredBadge.remove();
                }
              }
            } else {
              console.warn('⚠️ 找不到按鈕元素，跳過 UI 更新');
            }
            
            // 更新統計數字
            const featuredCount = document.querySelectorAll('.video-item[data-featured="featured"]').length;
            document.getElementById('featuredCount').textContent = featuredCount;
            
            // 顯示成功通知
            let statusMessage;
            if (newFeaturedStatus) {
              statusMessage = '✅ 影片已設為精選節目推薦';
            } else {
              statusMessage = '✅ 已取消精選節目推薦';
            }
            showStatus(statusMessage, 'success');
            
            // 額外的視覺反饋
            const originalText = button.textContent;
            button.textContent = '✅ 完成';
            button.style.background = '#28a745';
            setTimeout(() => {
              button.textContent = originalText;
              button.style.background = newFeaturedStatus ? '#dc3545' : '#28a745';
            }, 2000);
          } catch (error) {
            console.error('❌ 更新精選節目推薦狀態失敗:', error);
            console.error('錯誤詳情:', {
              message: error.message,
              stack: error.stack,
              name: error.name
            });
            showStatus('更新精選節目推薦狀態失敗: ' + error.message, 'error');
          }
        };

        // 從編輯頁面設為精選的功能
        window.toggleFeaturedFromEdit = async function(newFeaturedStatus) {
          try {
            const videoId = window.currentEditingVideoId;
            if (!videoId) {
              showStatus('❌ 無法獲取影片 ID', 'error');
              return;
            }

            showStatus('正在更新精選節目推薦狀態...', 'info');
            
            // 檢查 Management SDK
            if (typeof contentfulManagement === 'undefined') {
              await loadManagementSDK();
            }
            
            if (typeof contentfulManagement === 'undefined') {
              throw new Error('Management SDK 載入失敗');
            }
            
            // 獲取 Management Token
            const managementToken = window.CONTENTFUL_CONFIG?.MANAGEMENT_TOKEN || window.CONTENTFUL_MANAGEMENT_TOKEN;
            
            if (!managementToken) {
              throw new Error('Management Token 未設定');
            }
            
            // 創建 Management 客戶端
            const client = contentfulManagement.createClient({
              accessToken: managementToken
            });
            
            const space = await client.getSpace('os5wf90ljenp');
            const environment = await space.getEnvironment('master');
            const entry = await environment.getEntry(videoId);
            
            // 更新 isFeatured 欄位
            entry.fields.isFeatured = { 'en-US': newFeaturedStatus };
            
            // 調試：檢查所有可用欄位
            console.log('🔍 檢查條目所有欄位:', Object.keys(entry.fields));
            console.log('🔍 條目完整資料:', entry.fields);
            
            // 如果設為精選，檢查是否有精選說明文字欄位
            if (newFeaturedStatus) {
              // 檢查可能的精選說明文字欄位名稱
              const possibleFeaturedDescFields = [
                '精選推薦影片說明文字',
                'featuredDescription', 
                'featuredText',
                '精選說明',
                '精選描述'
              ];
              
              let featuredDescField = null;
              for (const fieldName of possibleFeaturedDescFields) {
                if (entry.fields[fieldName]) {
                  featuredDescField = fieldName;
                  console.log(`✅ 找到精選說明欄位: ${fieldName}`);
                  break;
                }
              }
              
              if (featuredDescField) {
                const currentFeaturedDesc = entry.fields[featuredDescField];
                const currentDesc = entry.fields.description;
                
                if (!currentFeaturedDesc && currentDesc) {
                  entry.fields[featuredDescField] = { 'en-US': currentDesc['en-US'] || currentDesc };
                  console.log(`✅ 已設定精選說明文字到欄位: ${featuredDescField}`);
                }
              } else {
                console.log('⚠️ 未找到精選說明文字欄位，跳過設定');
              }
            }
            
            // 發布更新
            const updatedEntry = await entry.update();
            await updatedEntry.publish();
            
            // 更新編輯頁面的 UI
            const featuredStatusDiv = document.getElementById('featuredStatus');
            const setFeaturedBtn = document.getElementById('setFeaturedBtn');
            
            if (newFeaturedStatus) {
              featuredStatusDiv.style.display = 'block';
              setFeaturedBtn.style.display = 'none';
            } else {
              featuredStatusDiv.style.display = 'none';
              setFeaturedBtn.style.display = 'inline-block';
            }
            
            // 顯示成功通知
            const statusMessage = newFeaturedStatus ? 
              '✅ 影片已設為精選節目推薦，說明文字已擷取' : 
              '✅ 已取消精選節目推薦';
            showStatus(statusMessage, 'success');
            
          } catch (error) {
            console.error('❌ 更新精選節目推薦狀態失敗:', error);
            showStatus('更新精選節目推薦狀態失敗: ' + error.message, 'error');
          }
        };

        // 載入節目播出歷史
        window.loadBroadcastHistory = function(videoId) {
          try {
            const broadcastHistoryDiv = document.getElementById('broadcastHistory');
            const broadcastHistoryList = document.getElementById('broadcastHistoryList');
            
            if (!videoId) {
              broadcastHistoryDiv.style.display = 'none';
              return;
            }
            
            // 從本地存儲的節目表中查找該影片的播出記錄
            const calendarEvents = JSON.parse(localStorage.getItem('calendar_events') || '{}');
            const broadcastRecords = [];
            
            Object.keys(calendarEvents).forEach(date => {
              calendarEvents[date].forEach(event => {
                if (event.youtubeId && event.youtubeId === videoId) {
                  broadcastRecords.push({
                    date: date,
                    time: event.time,
                    title: event.title,
                    status: event.status
                  });
                }
              });
            });
            
            if (broadcastRecords.length > 0) {
              broadcastHistoryList.innerHTML = broadcastRecords.map(record => `
                <div style="padding: 5px 0; border-bottom: 1px solid #dee2e6;">
                  <strong>${record.date}</strong> ${record.time} - ${record.title}
                  <span style="background: ${record.status === '首播' ? '#ffc107' : '#28a745'}; color: ${record.status === '首播' ? '#000' : '#fff'}; padding: 2px 6px; border-radius: 12px; font-size: 0.7rem; margin-left: 8px;">${record.status}</span>
                </div>
              `).join('');
              broadcastHistoryDiv.style.display = 'block';
            } else {
              broadcastHistoryDiv.style.display = 'none';
            }
            
          } catch (error) {
            console.error('載入播出歷史失敗:', error);
            document.getElementById('broadcastHistory').style.display = 'none';
          }
        };


        // 添加編輯功能 - 使用統一的編輯模態框
        window.editVideo = async function(videoId) {
          try {
            showStatus('正在載入影片資料...', 'info');
            
            // 創建 Contentful 客戶端
            const client = contentful.createClient({
              space: 'os5wf90ljenp',
              accessToken: 'lODH-WLwHwVZv7O4rFdBWjSnrzaQWGD4koeOZ1Dypj0'
            });

            // 獲取影片資料
            const video = await client.getEntry(videoId);
            const fields = video.fields || {};
            
            const pick = (obj, keys) => {
              for (const k of keys) {
                if (obj && obj[k] != null && obj[k] !== '') return obj[k];
              }
              return '';
            };

            const currentData = {
              id: video.sys.id,
              title: pick(fields, ['title']) || '',
              description: pick(fields, ['description']) || '',
              youtubeId: pick(fields, ['youTubeId']) || '',
              mp4Url: pick(fields, ['mp4Url']) || '',
              tags: Array.isArray(fields.tags) ? fields.tags : [],
              isFeatured: fields.isFeatured || false,
              category: pick(fields, ['category', '分類']) || '未分類'
            };

            // 使用統一的編輯模態框
            document.getElementById('modalTitle').textContent = '編輯影片';
            
            // 移除修改按鈕相關邏輯
            
            // 填入影片資料到表單
            document.getElementById('title').value = currentData.title;
            document.getElementById('description').value = currentData.description;
            document.getElementById('category').value = currentData.category;
            document.getElementById('youtubeId').value = currentData.youtubeId;
            document.getElementById('videoType').value = currentData.youtubeId ? 'YouTube' : (currentData.mp4Url ? 'MP4' : '');
            
            // 設定縮圖
            const thumbnailPreview = document.getElementById('thumbnailPreview');
            if (currentData.youtubeId) {
              const youtubeThumbnail = `https://img.youtube.com/vi/${currentData.youtubeId}/maxresdefault.jpg`;
              thumbnailPreview.src = youtubeThumbnail;
              thumbnailPreview.setAttribute('data-youtube-url', youtubeThumbnail);
            } else {
              thumbnailPreview.src = 'https://images.unsplash.com/photo-1485846234645-a62644f84728?w=400&h=225&fit=crop';
            }
            
            // 設定日期和時間（使用當前日期和時間）
            const now = new Date();
            const todayString = now.getFullYear() + '-' + 
                               String(now.getMonth() + 1).padStart(2, '0') + '-' + 
                               String(now.getDate()).padStart(2, '0');
            const currentTime = String(now.getHours()).padStart(2, '0') + ':' + 
                               String(now.getMinutes()).padStart(2, '0');
            
            document.getElementById('editDate').value = todayString;
            document.getElementById('editTime').value = currentTime;
            document.getElementById('airTime').value = currentTime;
            
            // 設定其他欄位
            document.getElementById('duration').value = '30'; // 預設30分鐘
            document.getElementById('status').value = '首播';
            
            // 切換影片欄位顯示
            toggleVideoFields();
            
            // 儲存影片ID到全域變數，供儲存時使用
            window.currentEditingVideoId = videoId;
            window.currentEditingVideoData = currentData;
            
            // 載入播出歷史
            loadBroadcastHistory(videoId);
            
            // 檢查並顯示精選狀態
            const isFeatured = currentData.isFeatured;
            const featuredStatusDiv = document.getElementById('featuredStatus');
            const setFeaturedBtn = document.getElementById('setFeaturedBtn');
            
            if (isFeatured) {
              featuredStatusDiv.style.display = 'block';
              setFeaturedBtn.style.display = 'none';
            } else {
              featuredStatusDiv.style.display = 'none';
              setFeaturedBtn.style.display = 'inline-block';
            }
            
            // 顯示模態框
            document.getElementById('eventModal').style.display = 'block';
            
            showStatus('影片資料已載入，可以開始編輯', 'success');
            
          } catch (error) {
            console.error('載入影片資料失敗:', error);
            showStatus('載入影片資料失敗: ' + error.message, 'error');
          }
        };

        // 檢查影片使用情況（移到全域範圍）
        window.checkVideoUsage = async function(videoId, videoTitle) {
          try {
            const usage = {
              inSchedule: [],
              inFeatured: false,
              inContentful: false,
              totalUsage: 0
            };

            // 檢查節目表中的使用情況
            const calendarEvents = JSON.parse(localStorage.getItem('calendar_events') || '{}');
            Object.keys(calendarEvents).forEach(date => {
              calendarEvents[date].forEach(event => {
                if (event.youtubeId && event.youtubeId === videoId) {
                  usage.inSchedule.push({
                    date: date,
                    time: event.time,
                    title: event.title,
                    status: event.status
                  });
                }
              });
            });

            // 檢查是否為精選影片
            const client = contentful.createClient({
              space: 'os5wf90ljenp',
              accessToken: 'lODH-WLwHwVZv7O4rFdBWjSnrzaQWGD4koeOZ1Dypj0'
            });

            try {
              const video = await client.getEntry(videoId);
              usage.inContentful = true;
              usage.inFeatured = video.fields.isHero || false;
            } catch (error) {
              console.log('影片在 Contentful 中不存在或無法訪問');
            }

            usage.totalUsage = usage.inSchedule.length + (usage.inFeatured ? 1 : 0);
            return usage;

          } catch (error) {
            console.error('檢查影片使用情況失敗:', error);
            return {
              inSchedule: [],
              inFeatured: false,
              inContentful: false,
              totalUsage: 0,
              error: error.message
            };
          }
        }

        // 添加刪除功能（移到全域範圍）
        window.deleteVideo = async function(videoId, videoTitle) {
          console.log('🎬 window.deleteVideo 函數開始執行');
          console.log('videoId:', videoId);
          console.log('videoTitle:', videoTitle);
          
          try {
            // 先檢查影片使用情況
            showStatus('正在檢查影片使用情況...', 'info');
            console.log('正在調用 window.checkVideoUsage...');
            
            const usage = await window.checkVideoUsage(videoId, videoTitle);
            console.log('✅ window.checkVideoUsage 完成，結果:', usage);
            
            // 創建更詳細的確認對話框
            console.log('開始創建確認對話框...');
            const confirmModal = document.createElement('div');
            console.log('✅ confirmModal 元素已創建');
            confirmModal.className = 'modal';
            confirmModal.style.display = 'block';
            confirmModal.style.zIndex = '10020';
            console.log('✅ confirmModal 樣式已設置');
          
            // 生成使用情況報告
            console.log('開始生成使用情況報告...');
            let usageReport = '';
            if (usage.totalUsage === 0) {
              console.log('✅ 影片未被使用，生成安全刪除報告');
              usageReport = `
                <div style="background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                  <p style="margin: 0; color: #155724; font-weight: bold;">✅ 此影片目前未被使用</p>
                  <p style="margin: 5px 0 0 0; color: #155724; font-size: 0.9rem;">可以安全刪除，不會影響任何節目安排。</p>
                </div>
              `;
            } else {
            usageReport = `
              <div style="background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                <p style="margin: 0; color: #721c24; font-weight: bold;">⚠️ 此影片正在被使用中！</p>
                <p style="margin: 5px 0 0 0; color: #721c24; font-size: 0.9rem;">刪除前請確認是否要移除所有相關的節目安排。</p>
              </div>
              
              <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                <h4 style="margin: 0 0 10px 0; color: #856404;">📊 使用情況詳情：</h4>
                ${usage.inFeatured ? '<p style="margin: 5px 0; color: #856404;">⭐ <strong>精選影片</strong>：此影片設為精選推薦</p>' : ''}
                ${usage.inSchedule.length > 0 ? `
                  <p style="margin: 5px 0; color: #856404;">📅 <strong>節目表安排</strong>：共 ${usage.inSchedule.length} 個時段</p>
                  <div style="max-height: 150px; overflow-y: auto; background: #f8f9fa; padding: 10px; border-radius: 4px; margin-top: 10px;">
                    ${usage.inSchedule.map(item => `
                      <div style="padding: 5px 0; border-bottom: 1px solid #dee2e6;">
                        <strong>${item.date}</strong> ${item.time} - ${item.title}
                        <span style="background: ${item.status === '首播' ? '#ffc107' : '#28a745'}; color: ${item.status === '首播' ? '#000' : '#fff'}; padding: 2px 6px; border-radius: 12px; font-size: 0.7rem; margin-left: 8px;">${item.status}</span>
                      </div>
                    `).join('')}
                  </div>
                ` : ''}
                <p style="margin: 10px 0 0 0; color: #856404; font-weight: bold;">總計：${usage.totalUsage} 個使用位置</p>
              </div>
            `;
          }
          
          confirmModal.innerHTML = `
            <div class="modal-content" style="max-width: 600px; max-height: 80vh; overflow-y: auto; z-index: 10021 !important;">
              <div class="modal-header" style="z-index: 10022 !important;">
                <h3>⚠️ 確認刪除影片</h3>
                <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
              </div>
              <div style="padding: 20px;">
                <div style="margin-bottom: 20px;">
                  <p style="color: #dc3545; font-weight: bold; margin-bottom: 10px;">您即將刪除以下影片：</p>
                  <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #dc3545;">
                    <strong>${videoTitle}</strong>
                  </div>
                </div>
                
                ${usageReport}
                
                <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                  <p style="margin: 0; color: #856404;">
                    <strong>⚠️ 警告：</strong>此操作將永久刪除影片，無法復原！
                    ${usage.totalUsage > 0 ? '同時會移除所有相關的節目安排。' : ''}
                  </p>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                  <button onclick="this.closest('.modal').remove()" 
                          style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">
                    ❌ 取消
                  </button>
                  <button id="confirmDeleteBtn" 
                          style="background: #dc3545; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">
                    🗑️ 確認刪除
                  </button>
                </div>
              </div>
            </div>
          `;
          
          document.body.appendChild(confirmModal);
          console.log('✅ 確認對話框已添加到 DOM');
          console.log('✅ confirmModal 元素:', confirmModal);
          console.log('✅ confirmModal 樣式:', confirmModal.style.cssText);
          console.log('✅ confirmModal 是否可見:', confirmModal.offsetParent !== null);
          
          // 添加確認刪除事件
          document.getElementById('confirmDeleteBtn').addEventListener('click', async function() {
            try {
              // 創建刪除進度條
              const progressDialog = createDeleteProgressDialog();
              document.body.appendChild(progressDialog);
              
              // 更新進度：檢查 SDK
              updateDeleteProgress(progressDialog, 1, 5, '檢查 Management SDK...');
              
              // 檢查 Management SDK 是否載入
              if (typeof contentfulManagement === 'undefined') {
                updateDeleteProgress(progressDialog, 2, 5, '正在載入 Management SDK...');
                try {
                  await loadManagementSDK();
                } catch (loadError) {
                  console.error('載入 Management SDK 失敗:', loadError);
                  progressDialog.remove();
                  showStatus('❌ Management SDK 載入失敗，請重新載入頁面', 'error');
                  return;
                }
              }
              
              // 再次檢查
              if (typeof contentfulManagement === 'undefined') {
                progressDialog.remove();
                throw new Error('Management SDK 載入失敗，請重新載入頁面');
              }
              
              console.log('✅ Management SDK 已載入，開始刪除操作');
              updateDeleteProgress(progressDialog, 3, 5, '正在連接 Contentful...');
              
              // 創建 Management 客戶端
              const managementClient = contentfulManagement.createClient({
                accessToken: 'CFPAT-hNLOfw3XdP5Hf_C3eYjI8294agakAK0Yo5Ew1Mjnsqs'
              });
              
              // 獲取空間
              updateDeleteProgress(progressDialog, 4, 5, '正在獲取影片資料...');
              const space = await managementClient.getSpace('os5wf90ljenp');
              
              // 獲取環境
              const environment = await space.getEnvironment('master');
              
              // 獲取並刪除影片
              const entry = await environment.getEntry(videoId);
              updateDeleteProgress(progressDialog, 5, 5, '正在刪除影片...');
              await entry.unpublish(); // 先取消發布
              await entry.delete(); // 再刪除
              
              // 清理相關的節目安排
              if (usage.totalUsage > 0) {
                updateDeleteProgress(progressDialog, 5, 5, '正在清理相關節目安排...');
                
                // 從節目表中移除使用此影片的節目
                const calendarEvents = JSON.parse(localStorage.getItem('calendar_events') || '{}');
                let removedCount = 0;
                
                Object.keys(calendarEvents).forEach(date => {
                  calendarEvents[date] = calendarEvents[date].filter(event => {
                    if (event.youtubeId === videoId) {
                      removedCount++;
                      return false; // 移除這個節目
                    }
                    return true; // 保留其他節目
                  });
                });
                
                // 儲存更新後的節目表
                localStorage.setItem('calendar_events', JSON.stringify(calendarEvents));
                
                if (removedCount > 0) {
                  updateDeleteProgress(progressDialog, 5, 5, `已清理 ${removedCount} 個相關節目安排`);
                }
              }
              
              // 從 UI 中移除影片項目
              const videoItem = document.querySelector(`[onclick*="deleteVideo('${videoId}'"]`).closest('.video-item');
              if (videoItem) {
                videoItem.style.transition = 'opacity 0.3s ease';
                videoItem.style.opacity = '0';
                setTimeout(() => {
                  videoItem.remove();
                  
                  // 更新統計數字
                  const videoCount = document.querySelectorAll('.video-item').length;
                  document.getElementById('videoCount').textContent = videoCount;
                  
                  // 重新計算精選和一般影片數量
                  const featuredCount = document.querySelectorAll('.video-item[data-featured="featured"]').length;
                  const normalCount = document.querySelectorAll('.video-item[data-featured="normal"]').length;
                  document.getElementById('featuredCount').textContent = featuredCount;
                  document.getElementById('normalCount').textContent = normalCount;
                  
                  // 更新標題中的總數
                  const modalHeader = document.getElementById('videoModalHeader');
                  if (modalHeader) {
                    const titleElement = modalHeader.querySelector('h3');
                    if (titleElement) {
                      titleElement.textContent = `🎬 所有影片管理 (${videoCount} 個)`;
                    }
                  }
                }, 300);
              }
              
              // 關閉確認對話框
              confirmModal.remove();
              
              // 關閉編輯視窗（如果存在）
              const eventModal = document.getElementById('eventModal');
              if (eventModal) {
                eventModal.style.display = 'none';
                console.log('✅ 已關閉編輯視窗');
              }
              
              // 顯示完成狀態
              updateDeleteProgressComplete(progressDialog, true, `✅ 影片「${videoTitle}」已成功刪除`);
              
              // 延遲關閉進度條
              setTimeout(() => {
                progressDialog.remove();
                showStatus(`✅ 影片「${videoTitle}」已成功刪除`, 'success');
              }, 2000);
              
            } catch (error) {
              console.error('刪除影片失敗:', error);
              confirmModal.remove();
              
              // 顯示錯誤狀態
              updateDeleteProgressComplete(progressDialog, false, `❌ 刪除影片失敗: ${error.message}`);
              
              // 延遲關閉進度條
              setTimeout(() => {
                progressDialog.remove();
                showStatus(`❌ 刪除影片失敗: ${error.message}`, 'error');
              }, 3000);
            }
          });
          
          // 點擊模態框外部關閉
          confirmModal.addEventListener('click', function(e) {
            if (e.target === confirmModal) {
              confirmModal.remove();
            }
          });
          
          } catch (error) {
            console.error('❌ window.deleteVideo 函數執行失敗:', error);
            showStatus('❌ 刪除功能執行失敗: ' + error.message, 'error');
          }
        };

      } catch (error) {
        console.error('載入影片失敗:', error);
        showStatus('載入影片失敗: ' + error.message, 'error');
      }
    }

    // 創建刪除進度條對話框
    function createDeleteProgressDialog() {
      const dialog = document.createElement('div');
      dialog.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10020;
      `;
      
      dialog.innerHTML = `
        <div style="
          background: white;
          padding: 30px;
          border-radius: 10px;
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
          max-width: 500px;
          width: 90%;
          text-align: center;
        ">
          <h3 style="margin: 0 0 20px 0; color: #333;">🗑️ 正在刪除影片</h3>
          <div style="margin-bottom: 20px;">
            <div style="
              width: 100%;
              height: 20px;
              background: #f0f0f0;
              border-radius: 10px;
              overflow: hidden;
            ">
              <div id="deleteProgressBar" style="
                width: 0%;
                height: 100%;
                background: linear-gradient(90deg, #dc3545, #ff6b6b);
                transition: width 0.3s ease;
                border-radius: 10px;
              "></div>
            </div>
            <div id="deleteProgressText" style="
              margin-top: 10px;
              color: #666;
              font-size: 14px;
            ">準備中...</div>
          </div>
          <div id="deleteCurrentItem" style="
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
          ">等待開始...</div>
          <div id="deleteStatusText" style="color: #333; font-weight: bold;">正在刪除影片...</div>
        </div>
      `;
      
      return dialog;
    }

    // 更新刪除進度
    function updateDeleteProgress(dialog, current, total, message) {
      const progressBar = dialog.querySelector('#deleteProgressBar');
      const progressText = dialog.querySelector('#deleteProgressText');
      const currentItem = dialog.querySelector('#deleteCurrentItem');
      const statusText = dialog.querySelector('#deleteStatusText');
      
      const percentage = Math.round((current / total) * 100);
      
      progressBar.style.width = percentage + '%';
      progressText.textContent = `${current} / ${total} (${percentage}%)`;
      currentItem.textContent = message;
      statusText.textContent = '正在刪除影片...';
    }

    // 更新刪除完成狀態
    function updateDeleteProgressComplete(dialog, success, message) {
      const progressBar = dialog.querySelector('#deleteProgressBar');
      const progressText = dialog.querySelector('#deleteProgressText');
      const currentItem = dialog.querySelector('#deleteCurrentItem');
      const statusText = dialog.querySelector('#deleteStatusText');
      
      progressBar.style.width = '100%';
      progressBar.style.background = success ? 'linear-gradient(90deg, #28a745, #20c997)' : 'linear-gradient(90deg, #dc3545, #ff6b6b)';
      progressText.textContent = '100% (完成)';
      currentItem.textContent = message;
      statusText.textContent = success ? '✅ 刪除完成' : '❌ 刪除失敗';
      statusText.style.color = success ? '#28a745' : '#dc3545';
    }

    function showAllEventsForDay(dateString) {
      const dayEvents = events[dateString] || [];
      if (dayEvents.length === 0) {
        showStatus('該日期沒有節目', 'info');
        return;
      }

      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.display = 'block';

      const date = new Date(dateString);
      const dateDisplay = `${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日`;

      modal.innerHTML = `
        <div class="modal-content" style="max-width: 600px;">
          <div class="modal-header">
            <h3>${dateDisplay} 的所有節目</h3>
            <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
          </div>
          <div style="max-height: 400px; overflow-y: auto;">
            ${dayEvents.map(event => `
              <div style="border: 1px solid #eee; border-radius: 8px; padding: 15px; margin-bottom: 10px; background: white;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                  <span style="font-weight: 600; color: #2b71d2;">${event.time}</span>
                  <span style="background: ${event.status === '首播' ? '#ffc107' : '#28a745'}; color: white; padding: 2px 8px; border-radius: 12px; font-size: 0.8rem;">
                    ${event.status}
                  </span>
                </div>
                <div style="font-weight: 600; margin-bottom: 5px;">${event.title}</div>
                <div style="color: #666; font-size: 0.9rem; margin-bottom: 5px;">
                  <span>${event.category}</span> • <span>${event.duration}分鐘</span>
                  ${event.videoType ? ` • <span>${event.videoType}</span>` : ''}
                </div>
                ${event.description ? `<div style="color: #666; font-size: 0.9rem; margin-bottom: 8px;">${event.description}</div>` : ''}
                <button class="btn" style="padding: 5px 12px; font-size: 0.8rem;" onclick="openEventModal('${dateString}', '${event.time}')">
                  編輯節目
                </button>
              </div>
            `).join('')}
          </div>
        </div>
      `;

      document.body.appendChild(modal);

      modal.addEventListener('click', function(e) {
        if (e.target === modal) {
          modal.remove();
        }
      });
    }

    function showStatus(message, type) {
      const statusBar = document.getElementById('statusBar');
      const statusMessage = document.getElementById('statusMessage');

      statusMessage.textContent = message;
      statusBar.style.display = 'block';

      statusBar.style.backgroundColor = type === 'success' ? '#4caf50' :
                                      type === 'error' ? '#f44336' :
                                      type === 'warning' ? '#ff9800' : '#333';

      setTimeout(() => {
        statusBar.style.display = 'none';
      }, 3000);
    }

    // 更新今日節目表顯示
    function updateCurrentScheduleForToday(programData) {
      const today = new Date();
      const todayString = today.getFullYear() + '-' +
                         String(today.getMonth() + 1).padStart(2, '0') + '-' +
                         String(today.getDate()).padStart(2, '0');
      
      // 獲取現有的今日節目表
      let currentSchedule = JSON.parse(localStorage.getItem('currentSchedule') || '{}');
      
      if (!currentSchedule.today) {
        currentSchedule.today = {
          date: todayString,
          dayOfWeek: getDayOfWeek(today),
          month: `${today.getMonth() + 1}月`,
          day: `${today.getDate()}日`,
          schedule: []
        };
      }
      
      // 轉換節目資料格式
      let thumbnail = 'https://images.unsplash.com/photo-1485846234645-a62644f84728?w=400&h=225&fit=crop';
      
      // 優先使用 programData.thumbnail，然後是 YouTube 縮圖
      if (programData.thumbnail) {
        thumbnail = programData.thumbnail;
      } else if (programData.youtubeId) {
        thumbnail = `https://img.youtube.com/vi/${programData.youtubeId}/maxresdefault.jpg`;
      }
      
      const scheduleItem = {
        time: programData.airTime,
        title: programData.title,
        duration: programData.duration.toString(),
        category: programData.category,
        description: programData.description,
        thumbnail: thumbnail,
        youtubeId: programData.youtubeId || '',
        status: programData.status,
        tags: []
      };
      
      // 移除同時間的舊節目（如果有的話）
      currentSchedule.today.schedule = currentSchedule.today.schedule.filter(
        item => item.time !== programData.airTime
      );
      
      // 添加新節目
      currentSchedule.today.schedule.push(scheduleItem);
      
      // 按時間排序
      currentSchedule.today.schedule.sort((a, b) => a.time.localeCompare(b.time));
      
      // 儲存到 localStorage
      localStorage.setItem('currentSchedule', JSON.stringify(currentSchedule));
      
      console.log('已更新今日節目表，新增節目:', scheduleItem);
    }

    // 獲取星期幾的輔助函數
    function getDayOfWeek(date) {
      const days = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
      return days[date.getDay()];
    }

    // === 月排程系統 ===
    
    // 定義四個時段
    const TIME_SLOTS = {
      AFTERNOON: {
        name: '下午場',
        startTime: '12:00',
        endTime: '17:30',
        slots: [
          '12:00', '12:30', '13:00', '13:30', '14:00', '14:30',
          '15:00', '15:30', '16:00', '16:30', '17:00', '17:30'
        ]
      },
      EVENING: {
        name: '晚場',
        startTime: '18:00',
        endTime: '23:30',
        slots: [
          '18:00', '18:30', '19:00', '19:30', '20:00', '20:30',
          '21:00', '21:30', '22:00', '22:30', '23:00', '23:30'
        ]
      },
      MIDNIGHT: {
        name: '午夜場',
        startTime: '00:00',
        endTime: '05:30',
        slots: [
          '00:00', '00:30', '01:00', '01:30', '02:00', '02:30',
          '03:00', '03:30', '04:00', '04:30', '05:00', '05:30'
        ]
      },
      MORNING: {
        name: '早場',
        startTime: '06:00',
        endTime: '11:30',
        slots: [
          '06:00', '06:30', '07:00', '07:30', '08:00', '08:30',
          '09:00', '09:30', '10:00', '10:30', '11:00', '11:30'
        ]
      }
    };

    // 判斷時間屬於哪個時段
    function getTimeSlot(time) {
      for (const [key, slot] of Object.entries(TIME_SLOTS)) {
        if (slot.slots.includes(time)) {
          return { key, slot };
        }
      }
      return null;
    }

    // 獲取相同時段的其他時間槽
    function getSameTimeSlotInOtherPeriods(time) {
      const currentSlot = getTimeSlot(time);
      if (!currentSlot) return [];

      const slotIndex = currentSlot.slot.slots.indexOf(time);
      const otherSlots = [];

      for (const [key, slot] of Object.entries(TIME_SLOTS)) {
        if (key !== currentSlot.key && slot.slots[slotIndex]) {
          otherSlots.push({
            period: key,
            periodName: slot.name,
            time: slot.slots[slotIndex]
          });
        }
      }

      return otherSlots;
    }

    // 生成整個月的日期
    function generateMonthDates(startDate) {
      const dates = [];
      const start = new Date(startDate);
      const year = start.getFullYear();
      const month = start.getMonth();
      
      // 獲取當月天數
      const daysInMonth = new Date(year, month + 1, 0).getDate();
      
      for (let day = 1; day <= daysInMonth; day++) {
        const date = new Date(year, month, day);
        dates.push(date.toISOString().split('T')[0]);
      }
      
      return dates;
    }

    // 生成跨月日期（從開始日期到指定天數）
    function generateCrossMonthDates(startDate, days) {
      const dates = [];
      const start = new Date(startDate);
      
      for (let i = 0; i < days; i++) {
        const date = new Date(start);
        date.setDate(start.getDate() + i);
        dates.push(date.toISOString().split('T')[0]);
      }
      
      return dates;
    }

    // 生成指定日期範圍（從開始日期到結束日期）
    function generateDateRange(startDate, endDate) {
      const dates = [];
      const start = new Date(startDate);
      const end = new Date(endDate);
      
      // 確保結束日期不早於開始日期
      if (end < start) {
        console.warn('⚠️ 結束日期早於開始日期，使用開始日期作為結束日期');
        return [startDate];
      }
      
      const current = new Date(start);
      while (current <= end) {
        dates.push(current.toISOString().split('T')[0]);
        current.setDate(current.getDate() + 1);
      }
      
      return dates;
    }

    // 檢查是否需要定期清理提醒
    function checkCleanupReminder() {
      const lastCleanupKey = 'last_contentful_cleanup';
      const reminderInterval = 60; // 60天
      
      const lastCleanup = localStorage.getItem(lastCleanupKey);
      const now = new Date();
      
      if (!lastCleanup) {
        // 第一次使用，設置提醒
        localStorage.setItem(lastCleanupKey, now.toISOString());
        return;
      }
      
      const lastCleanupDate = new Date(lastCleanup);
      const daysSinceLastCleanup = Math.floor((now - lastCleanupDate) / (1000 * 60 * 60 * 24));
      
      if (daysSinceLastCleanup >= reminderInterval) {
        showCleanupReminder(daysSinceLastCleanup);
      }
    }
    
    // 檢查重複時間槽
    function checkDuplicateTimeSlots() {
      const duplicateSlots = [];
      
      Object.keys(events).forEach(date => {
        const dayEvents = events[date];
        const timeGroups = {};
        
        dayEvents.forEach(event => {
          if (!timeGroups[event.time]) {
            timeGroups[event.time] = [];
          }
          timeGroups[event.time].push(event);
        });
        
        Object.keys(timeGroups).forEach(time => {
          if (timeGroups[time].length > 1) {
            duplicateSlots.push({
              date: date,
              time: time,
              programs: timeGroups[time]
            });
          }
        });
      });
      
      if (duplicateSlots.length > 0) {
        console.log('⚠️ 發現重複時間槽:', duplicateSlots);
        showDuplicateTimeSlotsDialog(duplicateSlots);
      }
    }
    
    
    // 清理重複時間槽（使用本地數據檢測，Contentful 清理）
    async function cleanupDuplicateTimeSlots() {
      try {
        showStatus('🔄 開始清理重複節目...', 'info');
        
        // 1. 使用本地 events 數據檢測重複（與 checkDuplicateTimeSlots 一致）
        const duplicateSlots = [];
        
        Object.keys(events).forEach(date => {
          const dayEvents = events[date];
          const timeGroups = {};
          
          dayEvents.forEach(event => {
            if (!timeGroups[event.time]) {
              timeGroups[event.time] = [];
            }
            timeGroups[event.time].push(event);
          });
          
          Object.keys(timeGroups).forEach(time => {
            if (timeGroups[time].length > 1) {
              duplicateSlots.push({
                date: date,
                time: time,
                programs: timeGroups[time]
              });
            }
          });
        });
        
        console.log('🔍 使用本地數據發現重複時間槽數量:', duplicateSlots.length);
        
        if (duplicateSlots.length === 0) {
          showStatus('✅ 沒有發現重複時間槽', 'success');
          return;
        }
        
        // 2. 顯示確認對話框
        showDuplicateTimeSlotsDialog(duplicateSlots);
        
      } catch (error) {
        console.error('❌ 清理重複節目失敗:', error);
        showStatus(`❌ 清理失敗: ${error.message}`, 'error');
      }
    }
    
    // 顯示重複時間槽確認對話框
    function showDuplicateTimeSlotsDialog(duplicateSlots) {
      const dialog = document.createElement('div');
      dialog.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); z-index: 10000;
        display: flex; align-items: center; justify-content: center;
      `;
      
      const totalDuplicates = duplicateSlots.reduce((sum, slot) => sum + slot.programs.length - 1, 0);
      
      dialog.innerHTML = `
        <div style="background: white; padding: 30px; border-radius: 10px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto;">
          <h3>🧹 清理重複節目</h3>
          <p>發現 <strong>${duplicateSlots.length}</strong> 個重複時間槽，共 <strong>${totalDuplicates}</strong> 個重複節目需要清理。</p>
          
          <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 5px;">
            <h4>清理策略：</h4>
            <ul style="margin: 10px 0; padding-left: 20px;">
              <li>保留每個時間槽最後一次上傳的節目（最新的）</li>
              <li>刪除其他重複的節目</li>
              <li>同時從 Contentful 和本地數據中清理</li>
            </ul>
          </div>
          
          <div style="margin: 20px 0;">
            <h4>重複時間槽預覽：</h4>
            <div style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 5px;">
              ${duplicateSlots.slice(0, 10).map(slot => `
                <div style="margin: 5px 0; padding: 5px; background: #fff3cd; border-radius: 3px;">
                  <strong>${slot.date} ${slot.time}</strong> (${slot.programs.length} 個節目)
                  <div style="font-size: 0.9em; color: #666;">
                    ${slot.programs.slice(0, 3).map((p, index) => {
                      const isLast = index === slot.programs.length - 1;
                      const isKeep = index === slot.programs.length - 1;
                      return `• ${p.title}${isKeep ? ' <span style="color: #28a745; font-weight: bold;">(保留)</span>' : ' <span style="color: #dc3545;">(刪除)</span>'}`;
                    }).join('<br>')}
                    ${slot.programs.length > 3 ? `<br>• ... 還有 ${slot.programs.length - 3} 個` : ''}
                  </div>
                </div>
              `).join('')}
              ${duplicateSlots.length > 10 ? `<div style="text-align: center; color: #666; margin-top: 10px;">... 還有 ${duplicateSlots.length - 10} 個時間槽</div>` : ''}
            </div>
          </div>
          
          <div style="margin-top: 20px; display: flex; justify-content: flex-end; gap: 10px;">
            <button onclick="this.closest('div').parentElement.remove()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
              取消
            </button>
            <button onclick="startCleanupProcess(); this.closest('div').parentElement.remove()" style="background: #dc3545; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
              開始清理 (${totalDuplicates} 個)
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(dialog);
      
      // 點擊背景關閉
      dialog.addEventListener('click', function(e) {
        if (e.target === dialog) {
          dialog.remove();
        }
      });
    }
    
    // 開始清理過程
    async function startCleanupProcess() {
      try {
        console.log('🚀 startCleanupProcess 開始執行');
        showStatus('🔄 開始清理重複節目...', 'info');
        
        // 檢查 events 是否存在
        if (!events || Object.keys(events).length === 0) {
          console.error('❌ events 數據不存在或為空');
          showStatus('❌ 沒有找到節目數據', 'error');
          return;
        }
        
        console.log('📊 events 數據檢查通過，共有', Object.keys(events).length, '個日期的數據');
        
        // 使用本地 events 數據檢測重複（與 checkDuplicateTimeSlots 一致）
        const duplicateSlots = [];
        
        Object.keys(events).forEach(date => {
          const dayEvents = events[date];
          if (!dayEvents || !Array.isArray(dayEvents)) {
            console.warn(`⚠️ 日期 ${date} 的數據格式不正確:`, dayEvents);
            return;
          }
          
          const timeGroups = {};
          
          dayEvents.forEach(event => {
            if (!event.time) {
              console.warn('⚠️ 節目缺少時間信息:', event);
              return;
            }
            
            if (!timeGroups[event.time]) {
              timeGroups[event.time] = [];
            }
            timeGroups[event.time].push(event);
          });
          
          Object.keys(timeGroups).forEach(time => {
            if (timeGroups[time].length > 1) {
              duplicateSlots.push({
                date: date,
                time: time,
                programs: timeGroups[time]
              });
            }
          });
        });
        
        console.log('🔍 開始清理，發現重複時間槽數量:', duplicateSlots.length);
        
        if (duplicateSlots.length === 0) {
          console.log('✅ 沒有發現重複時間槽');
          showStatus('✅ 沒有發現重複時間槽', 'success');
          return;
        }
        
        let cleanedCount = 0;
        let errorCount = 0;
        let totalToDelete = 0;
        
        // 計算總共需要刪除的節目數量
        duplicateSlots.forEach(slot => {
          totalToDelete += slot.programs.length - 1; // 減去保留的最後一個
        });
        
        // 顯示進度對話框
        console.log('📊 顯示進度對話框');
        const progressDialog = showCleanupProgressDialog();
        
        let processedCount = 0;
        
        // 清理每個重複時間槽
        for (let i = 0; i < duplicateSlots.length; i++) {
          const slot = duplicateSlots[i];
          const programs = slot.programs;
          
          console.log(`🔄 處理重複時間槽 ${i + 1}/${duplicateSlots.length}: ${slot.date} ${slot.time}`);
          
          // 保留最後一個節目（最新的），刪除其他
          for (let j = 0; j < programs.length - 1; j++) {
            const programToDelete = programs[j];
            
            try {
              processedCount++;
              updateCleanupProgress(progressDialog, processedCount, totalToDelete, 
                `正在刪除: ${programToDelete.title} (${slot.date} ${slot.time})`);
              
              // 從 Contentful 刪除（如果有 contentfulId）
              if (programToDelete.contentfulId) {
                console.log(`🗑️ 從 Contentful 刪除: ${programToDelete.contentfulId}`);
                await deleteProgramFromContentful(programToDelete.contentfulId);
              }
              
              // 從本地事件中刪除
              const eventIndex = events[slot.date]?.findIndex(e => 
                e.time === programToDelete.time && 
                e.title === programToDelete.title &&
                e.contentfulId === programToDelete.contentfulId
              );
              
              if (eventIndex !== -1) {
                events[slot.date].splice(eventIndex, 1);
                console.log(`🗑️ 從本地數據刪除: ${programToDelete.title}`);
              }
              
              cleanedCount++;
              console.log(`✅ 已刪除重複節目: ${programToDelete.title} (${slot.date} ${slot.time})`);
              
            } catch (error) {
              console.error(`❌ 刪除節目失敗: ${programToDelete.title}`, error);
              errorCount++;
            }
            
            // 添加小延遲避免 API 限制
            await new Promise(resolve => setTimeout(resolve, 200));
          }
        }
        
        console.log('💾 保存本地數據');
        // 保存本地數據
        saveEvents();
        renderCurrentView();
        
        console.log('✅ 清理完成，顯示結果');
        // 完成進度
        updateCleanupProgressComplete(progressDialog, cleanedCount, errorCount);
        
        showStatus(`✅ 清理完成！刪除 ${cleanedCount} 個重複節目${errorCount > 0 ? `，${errorCount} 個失敗` : ''}`, 'success');
        
      } catch (error) {
        console.error('❌ 清理過程失敗:', error);
        console.error('錯誤詳情:', error.stack);
        showStatus(`❌ 清理失敗: ${error.message}`, 'error');
        
        // 確保在錯誤情況下也關閉對話框
        clearAllDialogs();
      }
    }

    // 顯示清理進度對話框
    function showCleanupProgressDialog() {
      const dialog = document.createElement('div');
      dialog.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); z-index: 10000;
        display: flex; align-items: center; justify-content: center;
      `;
      
      dialog.innerHTML = `
        <div style="background: white; padding: 30px; border-radius: 10px; max-width: 500px; width: 90%;">
          <h3>🧹 清理重複節目中...</h3>
          <div style="margin: 20px 0;">
            <div style="background: #f0f0f0; border-radius: 10px; height: 20px; overflow: hidden;">
              <div id="cleanup-progress-bar" style="background: #28a745; height: 100%; width: 0%; transition: width 0.3s ease;"></div>
            </div>
            <div id="cleanup-progress-text" style="text-align: center; margin-top: 10px; color: #666;">
              準備中...
            </div>
          </div>
        </div>
      `;
      
      document.body.appendChild(dialog);
      return dialog;
    }
    
    // 從 Contentful 刪除節目
    async function deleteProgramFromContentful(contentfulId) {
      try {
        const managementToken = window.CONTENTFUL_CONFIG?.MANAGEMENT_TOKEN || window.CONTENTFUL_MANAGEMENT_TOKEN;
        if (!managementToken) {
          throw new Error('Management Token 未設定');
        }
        
        const managementClient = contentfulManagement.createClient({
          accessToken: managementToken
        });
        
        const spaceId = window.CONTENTFUL_CONFIG?.SPACE_ID || 'os5wf90ljenp';
        const space = await managementClient.getSpace(spaceId);
        const environment = await space.getEnvironment('master');
        
        const entry = await environment.getEntry(contentfulId);
        
        // 先取消發布
        if (entry.isPublished()) {
          await entry.unpublish();
        }
        
        // 刪除條目
        await entry.delete();
        
        console.log(`✅ 已從 Contentful 刪除節目: ${contentfulId}`);
        
      } catch (error) {
        console.error(`❌ 從 Contentful 刪除節目失敗: ${contentfulId}`, error);
        throw error;
      }
    }
    
    
    // 更新清理進度
    function updateCleanupProgress(dialog, current, total, message) {
      const progressBar = dialog.querySelector('#cleanup-progress-bar');
      const progressText = dialog.querySelector('#cleanup-progress-text');
      
      if (progressBar && progressText) {
        const percentage = total === 0 ? 100 : (current / total) * 100;
        progressBar.style.width = `${percentage}%`;
        progressText.textContent = `${current}/${total} - ${message}`;
      }
    }
    
    // 完成清理進度
    function updateCleanupProgressComplete(dialog, cleanedCount, errorCount) {
      const progressBar = dialog.querySelector('#cleanup-progress-bar');
      const progressText = dialog.querySelector('#cleanup-progress-text');
      
      if (progressBar && progressText) {
        progressBar.style.width = '100%';
        progressBar.style.backgroundColor = errorCount > 0 ? '#dc3545' : '#28a745';
        progressText.innerHTML = `
          <div style="color: #28a745; font-weight: bold;">
            ✅ 清理完成！
          </div>
          <div style="margin-top: 10px;">
            成功刪除: ${cleanedCount} 個節目<br>
            ${errorCount > 0 ? `失敗: ${errorCount} 個節目` : ''}
          </div>
        `;
      }
      
      // 3秒後自動關閉
      setTimeout(() => {
        try {
          // 先移除特定對話框
          if (dialog && dialog.parentElement) {
            dialog.remove();
            console.log('✅ 已移除清理進度對話框');
          }
          
          // 使用通用清理函數確保所有對話框都被移除
          clearAllDialogs();
          
          // 額外確保沒有殘留的遮罩層
          setTimeout(() => {
            clearAllDialogs();
            console.log('✅ 二次清理完成');
          }, 100);
          
        } catch (error) {
          console.error('關閉對話框時發生錯誤:', error);
          // 即使出錯也要嘗試清理
          clearAllDialogs();
        }
      }, 3000);
    }

    // 強制重新載入 Contentful 數據
    async function forceReloadFromContentful() {
      try {
        console.log('🔄 強制重新載入 Contentful 數據...');
        showStatus('🔄 正在強制重新載入 Contentful 數據...', 'info');
        
        // 清空所有本地數據
        events = {};
        localStorage.removeItem('calendar_events');
        localStorage.removeItem('published_programs');
        
        console.log('✅ 已清空所有本地數據');
        
        // 重新載入 Contentful 數據
        await loadEventsFromContentful();
        
        // 重新渲染視圖
        renderCurrentView();
        
        showStatus('✅ 強制重新載入完成！所有數據現在完全來自 Contentful', 'success');
        
        // 顯示統計信息
        const totalPrograms = Object.values(events).flat().length;
        const totalDates = Object.keys(events).length;
        console.log(`📊 重新載入後統計: ${totalPrograms} 個節目，${totalDates} 個日期`);
        
      } catch (error) {
        console.error('❌ 強制重新載入失敗:', error);
        showStatus('❌ 強制重新載入失敗: ' + error.message, 'error');
      }
    }

    // 恢復消失的節目
    async function recoverMissingPrograms() {
      try {
        console.log('🔄 開始恢復消失的節目...');
        showStatus('🔄 正在從 Contentful 重新載入節目數據...', 'info');
        
        // 重新載入事件數據
        await loadEventsFromContentful();
        
        // 重新渲染視圖
        renderCurrentView();
        
        showStatus('✅ 節目數據已恢復！如果節目仍然不見，請檢查 Contentful 中的數據。', 'success');
        
        // 顯示統計信息
        const totalPrograms = Object.values(events).flat().length;
        const totalDates = Object.keys(events).length;
        console.log(`📊 恢復後統計: ${totalPrograms} 個節目，${totalDates} 個日期`);
        
        // 診斷特定日期的節目
        const today = new Date();
        const todayString = today.getFullYear() + '-' +
                           String(today.getMonth() + 1).padStart(2, '0') + '-' +
                           String(today.getDate()).padStart(2, '0');
        
        console.log(`🔍 診斷今日 (${todayString}) 的節目:`);
        if (events[todayString]) {
          console.log(`📅 今日有 ${events[todayString].length} 個節目:`);
          events[todayString].forEach((event, index) => {
            console.log(`  ${index + 1}. ${event.time} - ${event.title} (ID: ${event.contentfulId})`);
          });
        } else {
          console.log('❌ 今日沒有任何節目');
        }
        
      } catch (error) {
        console.error('❌ 恢復節目失敗:', error);
        showStatus('❌ 恢復節目失敗: ' + error.message, 'error');
      }
    }

    // 恢復特定節目
    async function recoverSpecificProgram(date, time, title) {
      try {
        console.log(`🔄 嘗試恢復特定節目: ${date} ${time} - ${title}`);
        showStatus(`🔄 正在恢復節目「${title}」...`, 'info');
        
        // 檢查 Contentful 中是否有該節目
        if (typeof contentful !== 'undefined') {
          const client = contentful.createClient({
            space: 'os5wf90ljenp',
            accessToken: 'lODH-WLwHwVZv7O4rFdBWjSnrzaQWGD4koeOZ1Dypj0'
          });
          
          // 搜索該日期的所有節目
          const response = await client.getEntries({
            content_type: 'scheduleItem',
            'fields.airDate': date,
            limit: 100
          });
          
          console.log(`🔍 在 ${date} 找到 ${response.items.length} 個節目`);
          
          // 尋找匹配的節目（按標題或時間）
          let foundProgram = null;
          
          // 首先按時間匹配
          for (const item of response.items) {
            const notes = String(item.fields.notes || '');
            const timeMatch = notes.match(/\[時間:(\d{2}:\d{2})\]/);
            let airTime;
            
            if (timeMatch) {
              airTime = timeMatch[1];
            } else {
              airTime = convertBlockToTime(item.fields.block || '12-18');
            }
            
            console.log(`🔍 檢查節目: ${item.fields.title}, 時間標記: ${timeMatch ? timeMatch[0] : '無'}, 計算時間: ${airTime}, 目標時間: ${time}`);
            
            if (airTime === time) {
              foundProgram = item;
              console.log(`✅ 按時間找到節目: ${item.fields.title} (${airTime})`);
              break;
            }
          }
          
          // 如果按時間沒找到，按標題匹配
          if (!foundProgram) {
            for (const item of response.items) {
              if (item.fields.title && item.fields.title.includes(title)) {
                foundProgram = item;
                console.log(`✅ 按標題找到節目: ${item.fields.title}`);
                break;
              }
            }
          }
          
          if (foundProgram) {
            // 重建節目數據並添加到本地
            const notes = String(foundProgram.fields.notes || '');
            const timeMatch = notes.match(/\[時間:(\d{2}:\d{2})\]/);
            let airTime;
            
            if (timeMatch) {
              airTime = timeMatch[1];
            } else {
              airTime = convertBlockToTime(foundProgram.fields.block || '12-18');
            }
            
            const programData = {
              title: foundProgram.fields.title,
              time: airTime,
              date: date,
              contentfulId: foundProgram.sys.id,
              description: notes,
              category: extractCategoryFromNotes(notes),
              topics: extractTopicsFromNotes(notes),
              duration: 30, // 預設值
              status: '重播', // 預設值
              published: true,
              publishedAt: new Date().toISOString()
            };
            
            // 添加到本地事件
            if (!events[date]) {
              events[date] = [];
            }
            
            // 檢查是否已存在
            const existingIndex = events[date].findIndex(e => e.time === airTime);
            if (existingIndex >= 0) {
              events[date][existingIndex] = programData;
              console.log(`🔄 更新現有節目: ${airTime} - ${programData.title}`);
            } else {
              events[date].push(programData);
              console.log(`✅ 添加恢復的節目: ${airTime} - ${programData.title}`);
            }
            
            // 重新渲染視圖
            renderCurrentView();
            showStatus(`✅ 成功恢復節目「${title}」！`, 'success');
            
          } else {
            console.log(`❌ 在 Contentful 中找不到節目: ${date} ${time} - ${title}`);
            showStatus(`❌ 無法找到節目「${title}」，可能已被刪除`, 'error');
          }
        }
        
      } catch (error) {
        console.error('❌ 恢復特定節目失敗:', error);
        showStatus('❌ 恢復節目失敗: ' + error.message, 'error');
      }
    }

    // 診斷特定時間的節目
    async function diagnoseSpecificProgram(date, time) {
      try {
        console.log(`🔍 診斷 ${date} ${time} 的節目...`);
        
        // 檢查本地數據
        const localEvent = getEvent(date, time);
        console.log('📱 本地數據:', localEvent);
        
        // 檢查 Contentful 中的數據
        if (typeof contentful !== 'undefined') {
          const client = contentful.createClient({
            space: 'os5wf90ljenp',
            accessToken: 'lODH-WLwHwVZv7O4rFdBWjSnrzaQWGD4koeOZ1Dypj0'
          });
          
          const response = await client.getEntries({
            content_type: 'scheduleItem',
            'fields.airDate': date,
            limit: 100
          });
          
          console.log(`📊 Contentful 中 ${date} 的節目數量:`, response.items.length);
          
          // 檢查是否有匹配時間的節目
          const matchingPrograms = response.items.filter(item => {
            const notes = String(item.fields.notes || '');
            const timeMatch = notes.match(/\[時間:(\d{2}:\d{2})\]/);
            let airTime;
            
            if (timeMatch) {
              airTime = timeMatch[1];
            } else {
              airTime = convertBlockToTime(item.fields.block || '12-18');
            }
            
            console.log(`🔍 檢查節目: ${item.fields.title}, 時間標記: ${timeMatch ? timeMatch[0] : '無'}, 計算時間: ${airTime}, 目標時間: ${time}`);
            return airTime === time;
          });
          
          console.log(`🎯 匹配 ${time} 時間的節目:`, matchingPrograms.length);
          matchingPrograms.forEach((item, index) => {
            console.log(`  ${index + 1}. ${item.fields.title} (ID: ${item.sys.id})`);
            console.log(`     備註: ${String(item.fields.notes || '').substring(0, 200)}...`);
          });
          
          // 如果沒有找到匹配的節目，顯示所有節目的時間信息
          if (matchingPrograms.length === 0) {
            console.log(`🔍 沒有找到 ${time} 的節目，顯示所有節目的時間信息:`);
            response.items.forEach((item, index) => {
              const notes = String(item.fields.notes || '');
              const timeMatch = notes.match(/\[時間:(\d{2}:\d{2})\]/);
              const airTime = timeMatch ? timeMatch[1] : convertBlockToTime(item.fields.block || '12-18');
              const block = item.fields.block || '12-18';
              
              console.log(`  ${index + 1}. ${item.fields.title}`);
              console.log(`     時間標記: ${timeMatch ? timeMatch[0] : '無'}`);
              console.log(`     計算時間: ${airTime}`);
              console.log(`     時段: ${block}`);
              console.log(`     備註預覽: ${notes.substring(0, 100)}...`);
              console.log('---');
            });
          }
        }
        
      } catch (error) {
        console.error('❌ 診斷失敗:', error);
      }
    }

    // 診斷今日 17:30 的節目
    async function diagnoseToday1730() {
      const today = new Date();
      const todayString = today.getFullYear() + '-' +
                         String(today.getMonth() + 1).padStart(2, '0') + '-' +
                         String(today.getDate()).padStart(2, '0');
      
      console.log(`🔍 開始診斷今日 (${todayString}) 17:30 的節目...`);
      showStatus('🔍 正在診斷 17:30 的節目...', 'info');
      
      await diagnoseSpecificProgram(todayString, '17:30');
      
      // 顯示診斷結果
      const localEvent = getEvent(todayString, '17:30');
      if (localEvent) {
        showStatus(`✅ 找到本地節目: ${localEvent.title}`, 'success');
      } else {
        showStatus('❌ 本地沒有找到 17:30 的節目', 'error');
        
        // 如果本地沒有找到，嘗試搜索可能的節目標題
        console.log('🔍 嘗試搜索可能的節目標題...');
        await searchProgramByTitle(todayString, '加拿大尼加拉瀑布');
      }
    }

    // 診斷今日 16:30 的節目
    async function diagnoseToday1630() {
      const today = new Date();
      const todayString = today.getFullYear() + '-' +
                         String(today.getMonth() + 1).padStart(2, '0') + '-' +
                         String(today.getDate()).padStart(2, '0');
      
      console.log(`🔍 開始診斷今日 (${todayString}) 16:30 的節目...`);
      showStatus('🔍 正在診斷 16:30 的節目...', 'info');
      
      // 直接查詢 Contentful 中的原始數據
      await directQueryContentfulFor1630(todayString);
      
      await diagnoseSpecificProgram(todayString, '16:30');
      
      // 顯示診斷結果
      const localEvent = getEvent(todayString, '16:30');
      if (localEvent) {
        showStatus(`✅ 找到本地節目: ${localEvent.title}`, 'success');
      } else {
        showStatus('❌ 本地沒有找到 16:30 的節目', 'error');
        
        // 如果本地沒有找到，嘗試搜索可能的節目標題
        console.log('🔍 嘗試搜索可能的節目標題...');
        await searchProgramByTitle(todayString, '加拿大賞楓');
      }
    }

    // 直接查詢 Contentful 中的 16:30 節目
    async function directQueryContentfulFor1630(date) {
      try {
        console.log(`🔍 直接查詢 Contentful 中 ${date} 的所有節目...`);
        
        if (typeof contentful === 'undefined') {
          throw new Error('Contentful SDK 未載入');
        }

        const client = contentful.createClient({
          space: 'os5wf90ljenp',
          accessToken: 'lODH-WLwHwVZv7O4rFdBWjSnrzaQWGD4koeOZ1Dypj0'
        });

        // 查詢該日期的所有節目
        const response = await client.getEntries({
          content_type: 'scheduleItem',
          'fields.airDate': date,
          limit: 100
        });

        console.log(`📊 Contentful 中 ${date} 的原始節目數量:`, response.items.length);
        
        // 詳細檢查每個節目
        response.items.forEach((item, index) => {
          const notes = String(item.fields.notes || '');
          const timeMatch = notes.match(/\[時間:(\d{2}:\d{2})\]/);
          const block = item.fields.block || '12-18';
          const airTime = timeMatch ? timeMatch[1] : convertBlockToTime(block);
          
          console.log(`📺 節目 ${index + 1}:`);
          console.log(`  標題: ${item.fields.title}`);
          console.log(`  ID: ${item.sys.id}`);
          console.log(`  日期: ${item.fields.airDate}`);
          console.log(`  時段: ${block}`);
          console.log(`  時間標記: ${timeMatch ? timeMatch[0] : '無'}`);
          console.log(`  計算時間: ${airTime}`);
          console.log(`  備註長度: ${notes.length}`);
          console.log(`  備註預覽: ${notes.substring(0, 200)}...`);
          
          // 特別檢查是否包含 16:30
          if (airTime === '16:30' || notes.includes('16:30')) {
            console.log(`🎯 找到 16:30 相關節目: ${item.fields.title}`);
          }
          
          console.log('---');
        });

        // 特別搜索包含 16:30 的節目
        const programsWith1630 = response.items.filter(item => {
          const notes = String(item.fields.notes || '');
          return notes.includes('16:30') || notes.includes('[時間:16:30]');
        });

        console.log(`🎯 包含 16:30 的節目數量:`, programsWith1630.length);
        programsWith1630.forEach((item, index) => {
          console.log(`  ${index + 1}. ${item.fields.title} (ID: ${item.sys.id})`);
          console.log(`     備註: ${String(item.fields.notes || '').substring(0, 300)}...`);
        });

      } catch (error) {
        console.error('❌ 直接查詢 Contentful 失敗:', error);
      }
    }

    // 創建缺失的 16:30 節目
    async function createMissing1630Program() {
      try {
        const today = new Date();
        const todayString = today.getFullYear() + '-' +
                           String(today.getMonth() + 1).padStart(2, '0') + '-' +
                           String(today.getDate()).padStart(2, '0');
        
        console.log(`➕ 嘗試創建 ${todayString} 16:30 的節目...`);
        showStatus('➕ 正在創建 16:30 節目...', 'info');
        
        // 檢查是否已經存在
        const existingEvent = getEvent(todayString, '16:30');
        if (existingEvent) {
          showStatus('⚠️ 16:30 節目已存在: ' + existingEvent.title, 'warning');
          return;
        }
        
        // 創建新的節目數據
        const programData = {
          title: '加拿大賞楓 划船',
          airDate: todayString,
          airTime: '16:30',
          duration: 30,
          category: '自然秘境',
          description: '加拿大賞楓 每年九月底到十月，加拿大大地被楓紅點燃。安大略省的阿岡昆公園（Algonquin Park）、魁北克的勞倫琴山（Laurentians）、以及新斯科細亞省的楓葉大道（Cabot Trail），都是觀賞楓紅的著名景點。滿山遍野的紅、橙、金黃交織成絕美畫布，吸引無數遊客前來朝聖。',
          status: '重播',
          youtubeId: 'III8KxwNGwI',
          topics: ['加拿大賞楓 划船']
        };
        
        // 上架到 Contentful
        const result = await uploadProgramSimple(programData);
        
        if (result.success) {
          showStatus('✅ 成功創建 16:30 節目！', 'success');
          
          // 重新載入數據
          await loadEventsFromContentful();
          renderCurrentView();
        } else {
          showStatus('❌ 創建節目失敗: ' + result.error, 'error');
        }
        
      } catch (error) {
        console.error('❌ 創建 16:30 節目失敗:', error);
        showStatus('❌ 創建節目失敗: ' + error.message, 'error');
      }
    }

    // 根據標題搜索節目
    async function searchProgramByTitle(date, searchTitle) {
      try {
        if (typeof contentful !== 'undefined') {
          const client = contentful.createClient({
            space: 'os5wf90ljenp',
            accessToken: 'lODH-WLwHwVZv7O4rFdBWjSnrzaQWGD4koeOZ1Dypj0'
          });
          
          const response = await client.getEntries({
            content_type: 'scheduleItem',
            'fields.airDate': date,
            'fields.title[match]': searchTitle,
            limit: 10
          });
          
          console.log(`🔍 搜索標題包含 "${searchTitle}" 的節目:`, response.items.length);
          response.items.forEach((item, index) => {
            const notes = String(item.fields.notes || '');
            const timeMatch = notes.match(/\[時間:(\d{2}:\d{2})\]/);
            const airTime = timeMatch ? timeMatch[1] : convertBlockToTime(item.fields.block || '12-18');
            
            console.log(`  ${index + 1}. ${item.fields.title} (ID: ${item.sys.id})`);
            console.log(`     時間: ${airTime}`);
            console.log(`     時段: ${item.fields.block || '12-18'}`);
            console.log(`     備註預覽: ${notes.substring(0, 150)}...`);
            console.log('---');
          });
        }
      } catch (error) {
        console.error('❌ 搜索失敗:', error);
      }
    }

    // 清理所有對話框和遮罩層
    function clearAllDialogs() {
      try {
        console.log('🧹 開始清理所有對話框和遮罩層...');
        
        // 移除所有可能的對話框（多種選擇器確保完整清理）
        const selectors = [
          'div[style*="position: fixed"][style*="z-index: 10000"]',
          'div[style*="position: fixed"][style*="background: rgba(0,0,0"]',
          'div[style*="position: fixed"][style*="z-index: 9999"]',
          'div[style*="position: fixed"][style*="z-index: 10001"]'
        ];
        
        selectors.forEach(selector => {
          const elements = document.querySelectorAll(selector);
          elements.forEach(element => {
            if (element && element.parentElement) {
              element.remove();
              console.log('✅ 已移除對話框元素:', selector);
            }
          });
        });
        
        // 移除任何可能殘留的遮罩層（更廣泛的選擇器）
        const overlaySelectors = [
          'div[style*="background: rgba(0,0,0"]',
          'div[style*="background:rgba(0,0,0"]',
          'div[style*="background-color: rgba(0,0,0"]',
          'div[style*="background-color:rgba(0,0,0"]'
        ];
        
        overlaySelectors.forEach(selector => {
          const overlays = document.querySelectorAll(selector);
          overlays.forEach(overlay => {
            if (overlay && overlay.parentElement) {
              overlay.remove();
              console.log('✅ 已移除遮罩層元素:', selector);
            }
          });
        });
        
        // 額外檢查：移除任何包含特定類名或ID的對話框
        const additionalSelectors = [
          '.modal',
          '.dialog',
          '.overlay',
          '#cleanup-progress-dialog',
          '#batch-progress-dialog'
        ];
        
        additionalSelectors.forEach(selector => {
          const elements = document.querySelectorAll(selector);
          elements.forEach(element => {
            if (element && element.parentElement) {
              element.remove();
              console.log('✅ 已移除額外對話框元素:', selector);
            }
          });
        });
        
        // 移除任何可能影響頁面顯示的樣式
        const body = document.body;
        if (body) {
          // 移除可能添加的樣式
          body.style.overflow = '';
          body.style.pointerEvents = '';
          body.style.filter = '';
          body.style.opacity = '';
        }
        
        // 移除任何可能添加的全局樣式
        const styleElements = document.querySelectorAll('style[data-dialog-style]');
        styleElements.forEach(style => {
          if (style && style.parentElement) {
            style.remove();
            console.log('✅ 已移除對話框樣式元素');
          }
        });
        
        console.log('✅ 已清理所有對話框和遮罩層');
        
        // 顯示成功訊息
        showStatus('✅ 緊急清理完成！所有對話框和遮罩層已移除', 'success');
        
      } catch (error) {
        console.error('清理對話框時發生錯誤:', error);
        showStatus('❌ 清理過程中發生錯誤，請重新載入頁面', 'error');
      }
    }
    
    // 顯示清理提醒
    function showCleanupReminder(daysSinceLastCleanup) {
      const reminderDialog = document.createElement('div');
      reminderDialog.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
      `;
      
      reminderDialog.innerHTML = `
        <div style="
          background: white;
          padding: 30px;
          border-radius: 12px;
          max-width: 500px;
          width: 90%;
          box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        ">
          <div style="text-align: center; margin-bottom: 20px;">
            <div style="font-size: 3rem; margin-bottom: 15px;">🧹</div>
            <h3 style="color: #ffc107; margin-bottom: 15px;">定期清理提醒</h3>
          </div>
          
          <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
            <strong>清理提醒：</strong><br>
            距離上次清理已經過了 <strong>${daysSinceLastCleanup} 天</strong><br>
            建議清理 30 天前的舊節目數據以優化存儲空間
          </div>
          
          <div style="background: #d1ecf1; border: 1px solid #bee5eb; padding: 15px; border-radius: 8px; margin-bottom: 25px;">
            <strong>清理好處：</strong><br>
            • 減少 Contentful 存儲成本<br>
            • 提升查詢性能<br>
            • 保持數據整潔<br>
            • 避免 API 限制
          </div>
          
          <div style="text-align: center;">
            <button id="remindLater" style="
              background: #6c757d;
              color: white;
              border: none;
              padding: 12px 24px;
              border-radius: 6px;
              margin-right: 15px;
              cursor: pointer;
              font-size: 1rem;
            ">稍後提醒</button>
            <button id="startCleanup" style="
              background: #dc3545;
              color: white;
              border: none;
              padding: 12px 24px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 1rem;
            ">立即清理</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(reminderDialog);
      
      // 稍後提醒按鈕
      document.getElementById('remindLater').onclick = () => {
        // 設置 7 天後再次提醒
        const nextReminder = new Date();
        nextReminder.setDate(nextReminder.getDate() + 7);
        localStorage.setItem('last_contentful_cleanup', nextReminder.toISOString());
        document.body.removeChild(reminderDialog);
        showStatus('已設置 7 天後再次提醒', 'info');
      };
      
      // 立即清理按鈕
      document.getElementById('startCleanup').onclick = () => {
        document.body.removeChild(reminderDialog);
        cleanupOldContentfulData();
      };
    }

    // 清理 Contentful 中的舊數據
    async function cleanupOldContentfulData() {
      try {
        // 確認對話框
        const confirmed = confirm(
          '⚠️ 清理舊數據警告\n\n' +
          '此操作將刪除 Contentful 中 30 天前的節目數據。\n\n' +
          '• 只會刪除已過期的節目\n' +
          '• 不會影響當前和未來的節目\n' +
          '• 此操作無法復原\n\n' +
          '確定要繼續嗎？'
        );
        
        if (!confirmed) {
          showStatus('已取消清理操作', 'info');
          return;
        }
        
        showStatus('開始清理舊數據...', 'info');
        
        // 檢查 Management SDK
        if (typeof contentfulManagement === 'undefined') {
          throw new Error('Management SDK 未載入');
        }
        
        // 檢查 API Token
        const managementToken = window.CONTENTFUL_CONFIG?.MANAGEMENT_TOKEN || window.CONTENTFUL_MANAGEMENT_TOKEN;
        if (!managementToken) {
          throw new Error('Management Token 未設定');
        }
        
        // 創建 Management 客戶端
        const managementClient = contentfulManagement.createClient({
          accessToken: managementToken
        });
        
        // 獲取 Space 和 Environment
        const spaceId = window.CONTENTFUL_CONFIG?.SPACE_ID || 'os5wf90ljenp';
        const space = await managementClient.getSpace(spaceId);
        const environment = await space.getEnvironment('master');
        
        // 計算 30 天前的日期
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        const cutoffDate = thirtyDaysAgo.toISOString().split('T')[0];
        
        console.log('🗑️ 清理日期閾值:', cutoffDate);
        
        // 獲取所有節目數據
        const entries = await environment.getEntries({
          content_type: 'scheduleItem',
          limit: 1000
        });
        
        console.log('📊 總共找到', entries.items.length, '個節目');
        
        let deletedCount = 0;
        let errorCount = 0;
        
        // 創建進度對話框
        const progressDialog = document.createElement('div');
        progressDialog.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.5);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 10000;
        `;
        
        progressDialog.innerHTML = `
          <div style="
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
          ">
            <h3 style="margin-bottom: 20px; color: #dc3545;">🗑️ 清理舊數據</h3>
            <div style="margin-bottom: 20px;">
              <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                <strong>清理條件：</strong>刪除 ${cutoffDate} 之前的節目<br>
                <strong>總節目數：</strong>${entries.items.length} 個
              </div>
              <div style="background: #e3f2fd; padding: 15px; border-radius: 8px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                  <span>進度：</span>
                  <span id="progressText">0 / ${entries.items.length}</span>
                </div>
                <div style="background: #ddd; height: 20px; border-radius: 10px; overflow: hidden;">
                  <div id="progressBar" style="background: #dc3545; height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                </div>
              </div>
            </div>
            <div id="statusText" style="color: #666; font-size: 0.9rem;">準備開始清理...</div>
          </div>
        `;
        
        document.body.appendChild(progressDialog);
        
        // 更新進度
        function updateProgress(current, total, status) {
          const progressBar = document.getElementById('progressBar');
          const progressText = document.getElementById('progressText');
          const statusText = document.getElementById('statusText');
          
          const percentage = (current / total) * 100;
          progressBar.style.width = percentage + '%';
          progressText.textContent = `${current} / ${total}`;
          statusText.textContent = status;
        }
        
        // 檢查並刪除舊節目
        for (let i = 0; i < entries.items.length; i++) {
          const entry = entries.items[i];
          const airDate = entry.fields.airDate || '';
          
          updateProgress(i, entries.items.length, `檢查節目: ${entry.fields.title || '未知'}`);
          
          // 如果節目日期早於截止日期，則刪除
          if (airDate && airDate < cutoffDate) {
            try {
              console.log('🗑️ 刪除舊節目:', entry.fields.title, '日期:', airDate);
              
              // 先取消發布，再刪除
              if (entry.isPublished()) {
                await entry.unpublish();
              }
              await entry.delete();
              
              deletedCount++;
              updateProgress(i + 1, entries.items.length, `已刪除: ${entry.fields.title}`);
              
            } catch (error) {
              console.error('❌ 刪除失敗:', entry.fields.title, error);
              errorCount++;
              updateProgress(i + 1, entries.items.length, `刪除失敗: ${entry.fields.title}`);
            }
          } else {
            updateProgress(i + 1, entries.items.length, `保留節目: ${entry.fields.title}`);
          }
          
          // 添加小延遲避免 API 限制
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // 完成清理
        document.body.removeChild(progressDialog);
        
        const resultMessage = `清理完成！\n\n` +
          `✅ 已刪除: ${deletedCount} 個舊節目\n` +
          `❌ 刪除失敗: ${errorCount} 個節目\n` +
          `📅 保留: ${entries.items.length - deletedCount - errorCount} 個節目`;
        
        alert(resultMessage);
        showStatus(`清理完成：刪除 ${deletedCount} 個舊節目`, 'success');
        
        // 更新最後清理時間
        localStorage.setItem('last_contentful_cleanup', new Date().toISOString());
        
      } catch (error) {
        console.error('❌ 清理舊數據失敗:', error);
        showStatus(`清理失敗: ${error.message}`, 'error');
      }
    }

    // 顯示 Contentful 數據統計
    async function showContentfulStats() {
      try {
        showStatus('正在獲取數據統計...', 'info');
        
        // 檢查 Management SDK
        if (typeof contentfulManagement === 'undefined') {
          throw new Error('Management SDK 未載入');
        }
        
        // 檢查 API Token
        const managementToken = window.CONTENTFUL_CONFIG?.MANAGEMENT_TOKEN || window.CONTENTFUL_MANAGEMENT_TOKEN;
        if (!managementToken) {
          throw new Error('Management Token 未設定');
        }
        
        // 創建 Management 客戶端
        const managementClient = contentfulManagement.createClient({
          accessToken: managementToken
        });
        
        // 獲取 Space 和 Environment
        const spaceId = window.CONTENTFUL_CONFIG?.SPACE_ID || 'os5wf90ljenp';
        const space = await managementClient.getSpace(spaceId);
        const environment = await space.getEnvironment('master');
        
        // 獲取所有節目數據
        const entries = await environment.getEntries({
          content_type: 'scheduleItem',
          limit: 1000
        });
        
        // 統計數據
        const now = new Date();
        const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        const sixtyDaysAgo = new Date(now.getTime() - 60 * 24 * 60 * 60 * 1000);
        
        let totalPrograms = entries.items.length;
        let publishedPrograms = 0;
        let draftPrograms = 0;
        let recentPrograms = 0; // 30天內
        let oldPrograms = 0; // 60天前
        let duplicatePrograms = 0;
        
        // 統計各種狀態
        const programMap = new Map();
        
        entries.items.forEach(entry => {
          // 統計發布狀態
          if (entry.isPublished()) {
            publishedPrograms++;
          } else {
            draftPrograms++;
          }
          
          // 統計時間
          const airDate = entry.fields.airDate || '';
          if (airDate) {
            const programDate = new Date(airDate);
            if (programDate >= thirtyDaysAgo) {
              recentPrograms++;
            }
            if (programDate < sixtyDaysAgo) {
              oldPrograms++;
            }
          }
          
          // 檢查重複節目
          const title = entry.fields.title || '';
          const notes = String(entry.fields.notes || '');
          const youtubeMatch = notes.match(/\[YouTube:([^\]]+)\]/);
          const youtubeId = youtubeMatch ? youtubeMatch[1] : '';
          
          const key = `${title}_${youtubeId}`;
          if (programMap.has(key)) {
            duplicatePrograms++;
          } else {
            programMap.set(key, 1);
          }
        });
        
        // 計算存儲成本估算（Contentful 按 entry 收費）
        const estimatedCost = Math.ceil(totalPrograms / 1000) * 5; // 假設每1000個entry約5美元
        
        // 顯示統計對話框
        const statsDialog = document.createElement('div');
        statsDialog.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.5);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 10000;
        `;
        
        statsDialog.innerHTML = `
          <div style="
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
          ">
            <div style="text-align: center; margin-bottom: 25px;">
              <div style="font-size: 3rem; margin-bottom: 15px;">📊</div>
              <h3 style="color: #17a2b8; margin-bottom: 10px;">Contentful 數據統計</h3>
              <p style="color: #666; font-size: 0.9rem;">最後更新：${new Date().toLocaleString()}</p>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 25px;">
              <div style="background: #e3f2fd; padding: 20px; border-radius: 8px; text-align: center;">
                <div style="font-size: 2rem; font-weight: bold; color: #1976d2;">${totalPrograms}</div>
                <div style="color: #666; font-size: 0.9rem;">總節目數</div>
              </div>
              <div style="background: #e8f5e8; padding: 20px; border-radius: 8px; text-align: center;">
                <div style="font-size: 2rem; font-weight: bold; color: #2e7d32;">${publishedPrograms}</div>
                <div style="color: #666; font-size: 0.9rem;">已發布</div>
              </div>
              <div style="background: #fff3e0; padding: 20px; border-radius: 8px; text-align: center;">
                <div style="font-size: 2rem; font-weight: bold; color: #f57c00;">${draftPrograms}</div>
                <div style="color: #666; font-size: 0.9rem;">草稿</div>
              </div>
              <div style="background: #fce4ec; padding: 20px; border-radius: 8px; text-align: center;">
                <div style="font-size: 2rem; font-weight: bold; color: #c2185b;">${duplicatePrograms}</div>
                <div style="color: #666; font-size: 0.9rem;">重複節目</div>
              </div>
            </div>
            
            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
              <h4 style="margin-bottom: 15px; color: #495057;">📅 時間分布</h4>
              <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                <span>最近 30 天：</span>
                <strong style="color: #28a745;">${recentPrograms} 個</strong>
              </div>
              <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                <span>60 天前：</span>
                <strong style="color: #dc3545;">${oldPrograms} 個</strong>
              </div>
              <div style="display: flex; justify-content: space-between;">
                <span>其他時間：</span>
                <strong style="color: #6c757d;">${totalPrograms - recentPrograms - oldPrograms} 個</strong>
              </div>
            </div>
            
            <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
              <h4 style="margin-bottom: 15px; color: #856404;">💰 成本估算</h4>
              <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                <span>Entry 數量：</span>
                <strong>${totalPrograms} 個</strong>
              </div>
              <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                <span>估算月成本：</span>
                <strong style="color: #dc3545;">約 $${estimatedCost}</strong>
              </div>
              <div style="font-size: 0.85rem; color: #856404; margin-top: 10px;">
                * 此為估算值，實際費用請參考 Contentful 定價
              </div>
            </div>
            
            <div style="background: #d1ecf1; border: 1px solid #bee5eb; padding: 20px; border-radius: 8px; margin-bottom: 25px;">
              <h4 style="margin-bottom: 15px; color: #0c5460;">💡 優化建議</h4>
              ${oldPrograms > 0 ? `<div style="margin-bottom: 8px;">• 建議清理 ${oldPrograms} 個 60 天前的舊節目</div>` : ''}
              ${duplicatePrograms > 0 ? `<div style="margin-bottom: 8px;">• 發現 ${duplicatePrograms} 個重複節目，建議檢查</div>` : ''}
              ${totalPrograms > 500 ? `<div style="margin-bottom: 8px;">• 節目數量較多，建議定期清理舊數據</div>` : ''}
              ${totalPrograms <= 500 ? `<div style="margin-bottom: 8px;">• 數據量適中，建議每 60 天清理一次</div>` : ''}
            </div>
            
            <div style="text-align: center;">
              <button id="closeStatsDialog" style="
                background: #6c757d;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 1rem;
                margin-right: 15px;
              ">關閉</button>
              ${oldPrograms > 0 ? `
                <button id="cleanupFromStats" style="
                  background: #dc3545;
                  color: white;
                  border: none;
                  padding: 12px 24px;
                  border-radius: 6px;
                  cursor: pointer;
                  font-size: 1rem;
                ">立即清理</button>
              ` : ''}
            </div>
          </div>
        `;
        
        document.body.appendChild(statsDialog);
        
        // 添加關閉按鈕事件處理器
        document.getElementById('closeStatsDialog').onclick = () => {
          document.body.removeChild(statsDialog);
        };
        
        // 添加清理按鈕事件處理器（如果存在）
        const cleanupBtn = document.getElementById('cleanupFromStats');
        if (cleanupBtn) {
          cleanupBtn.onclick = () => {
            document.body.removeChild(statsDialog);
            cleanupOldContentfulData();
          };
        }
        
        // 添加點擊背景關閉功能
        statsDialog.onclick = (e) => {
          if (e.target === statsDialog) {
            document.body.removeChild(statsDialog);
          }
        };
        
        // 添加 ESC 鍵關閉功能
        const handleKeyPress = (e) => {
          if (e.key === 'Escape') {
            document.body.removeChild(statsDialog);
            document.removeEventListener('keydown', handleKeyPress);
          }
        };
        document.addEventListener('keydown', handleKeyPress);
        
        showStatus('數據統計載入完成', 'success');
        
      } catch (error) {
        console.error('❌ 獲取數據統計失敗:', error);
        showStatus(`獲取統計失敗: ${error.message}`, 'error');
      }
    }

    // 顯示從歷史複製對話框
    async function showCopyFromHistoryDialog() {
      try {
        showStatus('正在載入歷史節目...', 'info');
        
        // 檢查 Management SDK
        if (typeof contentfulManagement === 'undefined') {
          throw new Error('Management SDK 未載入');
        }
        
        // 檢查 API Token
        const managementToken = window.CONTENTFUL_CONFIG?.MANAGEMENT_TOKEN || window.CONTENTFUL_MANAGEMENT_TOKEN;
        if (!managementToken) {
          throw new Error('Management Token 未設定');
        }
        
        // 創建 Management 客戶端
        const managementClient = contentfulManagement.createClient({
          accessToken: managementToken
        });
        
        // 獲取 Space 和 Environment
        const spaceId = window.CONTENTFUL_CONFIG?.SPACE_ID || 'os5wf90ljenp';
        const space = await managementClient.getSpace(spaceId);
        const environment = await space.getEnvironment('master');
        
        // 獲取最近 2 個月的節目數據
        const twoMonthsAgo = new Date();
        twoMonthsAgo.setMonth(twoMonthsAgo.getMonth() - 2);
        const cutoffDate = twoMonthsAgo.toISOString().split('T')[0];
        
        const entries = await environment.getEntries({
          content_type: 'scheduleItem',
          'fields.airDate[gte]': cutoffDate,
          limit: 500,
          order: '-fields.airDate'
        });
        
        console.log('📚 載入歷史節目:', entries.items.length, '個');
        console.log('📚 載入的節目詳情:', entries.items.map(entry => ({
          id: entry.sys.id,
          title: entry.fields.title,
          airDate: entry.fields.airDate,
          notes: entry.fields.notes
        })));
        
        // 按日期分組節目
        const programsByDate = {};
        entries.items.forEach(entry => {
          const airDate = entry.fields.airDate || '';
          const notes = String(entry.fields.notes || '');
          const timeMatch = notes.match(/\[時間:(\d{2}:\d{2})\]/);
          const airTime = timeMatch ? timeMatch[1] : '';
          
          console.log('📚 處理節目:', {
            title: entry.fields.title,
            airDate: airDate,
            airTime: airTime,
            notes: notes
          });
          
          if (airDate && airTime) {
            if (!programsByDate[airDate]) {
              programsByDate[airDate] = [];
            }
            programsByDate[airDate].push({
              id: entry.sys.id,
              title: entry.fields.title || '',
              time: airTime,
              status: entry.fields.status || '',
              notes: notes
            });
          }
        });
        
        console.log('📚 按日期分組的節目:', programsByDate);
        
        // 創建歷史複製對話框
        const historyDialog = document.createElement('div');
        historyDialog.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.5);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 10000;
        `;
        
        const sortedDates = Object.keys(programsByDate).sort().reverse();
        
        // 檢查是否有歷史數據
        if (sortedDates.length === 0) {
          alert('⚠️ 沒有找到歷史節目數據\n\n可能原因：\n• 最近 2 個月內沒有節目\n• Contentful 連接問題\n• 節目數據格式問題\n\n請檢查控制台日誌獲取詳細信息。');
          showStatus('沒有找到歷史節目數據', 'warning');
          return;
        }
        
        const dateOptions = sortedDates.map(date => {
          const programs = programsByDate[date];
          const dateStr = new Date(date).toLocaleDateString('zh-TW');
          return `<option value="${date}">${dateStr} (${programs.length} 個節目)</option>`;
        }).join('');
        
        historyDialog.innerHTML = `
          <div style="
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
          ">
            <div style="text-align: center; margin-bottom: 25px;">
              <div style="font-size: 3rem; margin-bottom: 15px;">📚</div>
              <h3 style="color: #6f42c1; margin-bottom: 10px;">從歷史節目複製</h3>
              <p style="color: #666; font-size: 0.9rem;">選擇歷史日期和時間槽，批量複製到當前節目</p>
            </div>
            
            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
              <h4 style="margin-bottom: 15px; color: #495057;">📅 選擇歷史日期</h4>
              <select id="historyDateSelect" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px;">
                <option value="">-- 選擇日期 --</option>
                ${dateOptions}
              </select>
            </div>
            
            <div id="timeSlotsContainer" style="display: none;">
              <h4 style="margin-bottom: 15px; color: #495057;">⏰ 選擇時間槽</h4>
              <div id="timeSlotsGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 20px;">
                <!-- 時間槽將在這裡動態生成 -->
              </div>
            </div>
            
            <div id="copyOptionsContainer" style="display: none; background: #e3f2fd; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
              <h4 style="margin-bottom: 15px; color: #1976d2;">📋 複製選項</h4>
              <div style="margin-bottom: 15px;">
                <label style="display: flex; align-items: center; margin-bottom: 10px;">
                  <input type="radio" name="copyMode" value="sameDay" checked style="margin-right: 8px;">
                  <span>複製到當天相同時間槽</span>
                </label>
                <label style="display: flex; align-items: center; margin-bottom: 10px;">
                  <input type="radio" name="copyMode" value="batchDays" style="margin-right: 8px;">
                  <span>批量複製到多天</span>
                </label>
              </div>
              
              <div id="batchOptions" style="display: none;">
                <div style="margin-bottom: 15px;">
                  <label style="display: block; margin-bottom: 5px; font-weight: 600;">複製天數：</label>
                  <div style="display: flex; gap: 10px; align-items: center;">
                    <label style="display: flex; align-items: center;">
                      <input type="radio" name="copyDays" value="30" checked style="margin-right: 5px;">
                      <span>30 天</span>
                    </label>
                    <label style="display: flex; align-items: center;">
                      <input type="radio" name="copyDays" value="31" style="margin-right: 5px;">
                      <span>31 天</span>
                    </label>
                    <label style="display: flex; align-items: center;">
                      <input type="radio" name="copyDays" value="custom" style="margin-right: 5px;">
                      <span>自訂：</span>
                    </label>
                    <input type="number" id="customDays" min="1" max="365" value="30" style="width: 80px; padding: 5px; border: 1px solid #ddd; border-radius: 3px;" disabled>
                  </div>
                </div>
              </div>
            </div>
            
            <div style="text-align: center;">
              <button id="closeHistoryDialog" style="
                background: #6c757d;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 1rem;
                margin-right: 15px;
              ">取消</button>
              <button id="confirmHistoryCopy" style="
                background: #6f42c1;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 1rem;
                display: none;
              ">確認複製</button>
            </div>
          </div>
        `;
        
        document.body.appendChild(historyDialog);
        
        // 添加事件處理器
        document.getElementById('closeHistoryDialog').onclick = () => {
          document.body.removeChild(historyDialog);
        };
        
        // 日期選擇事件
        document.getElementById('historyDateSelect').onchange = (e) => {
          const selectedDate = e.target.value;
          if (selectedDate) {
            showTimeSlotsForDate(selectedDate, programsByDate[selectedDate]);
            document.getElementById('timeSlotsContainer').style.display = 'block';
            document.getElementById('copyOptionsContainer').style.display = 'block';
          } else {
            document.getElementById('timeSlotsContainer').style.display = 'none';
            document.getElementById('copyOptionsContainer').style.display = 'none';
          }
        };
        
        // 複製模式選擇事件
        document.querySelectorAll('input[name="copyMode"]').forEach(radio => {
          radio.onchange = (e) => {
            const batchOptions = document.getElementById('batchOptions');
            if (e.target.value === 'batchDays') {
              batchOptions.style.display = 'block';
            } else {
              batchOptions.style.display = 'none';
            }
          };
        });
        
        // 自訂天數選項
        document.querySelectorAll('input[name="copyDays"]').forEach(radio => {
          radio.onchange = (e) => {
            const customDaysInput = document.getElementById('customDays');
            if (e.target.value === 'custom') {
              customDaysInput.disabled = false;
            } else {
              customDaysInput.disabled = true;
            }
          };
        });
        
        // 確認複製事件
        document.getElementById('confirmHistoryCopy').onclick = () => {
          const selectedDate = document.getElementById('historyDateSelect').value;
          const selectedTimeSlots = Array.from(document.querySelectorAll('input[name="timeSlot"]:checked')).map(cb => cb.value);
          const copyMode = document.querySelector('input[name="copyMode"]:checked').value;
          
          if (selectedTimeSlots.length === 0) {
            alert('請至少選擇一個時間槽');
            return;
          }
          
          document.body.removeChild(historyDialog);
          executeHistoryCopy(selectedDate, selectedTimeSlots, copyMode, programsByDate);
        };
        
        showStatus('歷史節目載入完成', 'success');
        
      } catch (error) {
        console.error('❌ 載入歷史節目失敗:', error);
        showStatus(`載入歷史節目失敗: ${error.message}`, 'error');
      }
    }
    
    // 顯示指定日期的時間槽
    function showTimeSlotsForDate(date, programs) {
      const timeSlotsGrid = document.getElementById('timeSlotsGrid');
      const confirmButton = document.getElementById('confirmHistoryCopy');
      
      timeSlotsGrid.innerHTML = '';
      
      // 按時間排序
      programs.sort((a, b) => a.time.localeCompare(b.time));
      
      programs.forEach(program => {
        const timeSlotDiv = document.createElement('div');
        timeSlotDiv.style.cssText = `
          background: #f8f9fa;
          border: 2px solid #e9ecef;
          border-radius: 8px;
          padding: 15px;
          cursor: pointer;
          transition: all 0.3s ease;
        `;
        
        timeSlotDiv.innerHTML = `
          <label style="display: flex; align-items: center; cursor: pointer; margin: 0;">
            <input type="checkbox" name="timeSlot" value="${program.time}" style="margin-right: 10px; transform: scale(1.2);">
            <div>
              <div style="font-weight: 600; color: #333; margin-bottom: 5px;">${program.time}</div>
              <div style="font-size: 0.9rem; color: #666; margin-bottom: 3px;">${program.title}</div>
              <div style="font-size: 0.8rem; color: #999;">${program.status}</div>
            </div>
          </label>
        `;
        
        timeSlotsGrid.appendChild(timeSlotDiv);
      });
      
      // 添加全選/取消全選
      const selectAllDiv = document.createElement('div');
      selectAllDiv.style.cssText = `
        grid-column: 1 / -1;
        background: #e3f2fd;
        border: 2px solid #2196f3;
        border-radius: 8px;
        padding: 15px;
        text-align: center;
        margin-bottom: 10px;
      `;
      
      selectAllDiv.innerHTML = `
        <label style="display: flex; align-items: center; justify-content: center; cursor: pointer; margin: 0;">
          <input type="checkbox" id="selectAllTimeSlots" style="margin-right: 10px; transform: scale(1.2);">
          <span style="font-weight: 600; color: #1976d2;">全選/取消全選</span>
        </label>
      `;
      
      timeSlotsGrid.insertBefore(selectAllDiv, timeSlotsGrid.firstChild);
      
      // 全選功能
      document.getElementById('selectAllTimeSlots').onchange = (e) => {
        const checkboxes = document.querySelectorAll('input[name="timeSlot"]');
        checkboxes.forEach(cb => cb.checked = e.target.checked);
        updateConfirmButton();
      };
      
      // 個別選擇事件
      document.querySelectorAll('input[name="timeSlot"]').forEach(cb => {
        cb.onchange = updateConfirmButton;
      });
      
      function updateConfirmButton() {
        const selectedCount = document.querySelectorAll('input[name="timeSlot"]:checked').length;
        if (selectedCount > 0) {
          confirmButton.style.display = 'inline-block';
          confirmButton.textContent = `確認複製 (${selectedCount} 個時間槽)`;
        } else {
          confirmButton.style.display = 'none';
        }
      }
    }
    
    // 執行歷史複製
    async function executeHistoryCopy(selectedDate, selectedTimeSlots, copyMode, programsByDate) {
      try {
        showStatus('開始從歷史複製節目...', 'info');
        
        const programs = programsByDate[selectedDate];
        const selectedPrograms = programs.filter(p => selectedTimeSlots.includes(p.time));
        
        console.log('📚 選擇的歷史節目:', selectedPrograms);
        
        // 獲取當前模態框的數據
        const currentProgramData = {
          title: document.getElementById('title').value,
          category: document.getElementById('category').value,
          topics: Array.from(document.querySelectorAll('input[name="topic"]:checked')).map(cb => cb.value),
          description: document.getElementById('description').value,
          youtubeId: document.getElementById('youtubeId').value,
          duration: document.getElementById('duration').value,
          status: document.getElementById('status').value
        };
        
        if (!currentProgramData.title) {
          alert('請先填寫節目標題');
          return;
        }
        
        let programsToUpload = [];
        
        if (copyMode === 'sameDay') {
          // 複製到當天相同時間槽
          const currentDate = document.getElementById('editDate').value;
          selectedTimeSlots.forEach(time => {
            programsToUpload.push({
              ...currentProgramData,
              airDate: currentDate,
              airTime: time
            });
          });
        } else {
          // 批量複製到多天
          const currentDate = document.getElementById('editDate').value;
          const copyDays = document.querySelector('input[name="copyDays"]:checked').value;
          const customDays = document.getElementById('customDays').value;
          
          let daysToCopy = copyDays === 'custom' ? parseInt(customDays) : parseInt(copyDays);
          const dates = generateCrossMonthDates(currentDate, daysToCopy);
          
          dates.forEach(date => {
            selectedTimeSlots.forEach(time => {
              programsToUpload.push({
                ...currentProgramData,
                airDate: date,
                airTime: time
              });
            });
          });
        }
        
        console.log('📚 準備上架節目:', programsToUpload.length, '個');
        
        // 創建進度對話框
        const progressDialog = createBatchProgressDialog(programsToUpload.length, '從歷史複製節目');
        document.body.appendChild(progressDialog);
        
        let successCount = 0;
        let errorCount = 0;
        let skippedCount = 0;
        
        for (let i = 0; i < programsToUpload.length; i++) {
          const programData = programsToUpload[i];
          
          updateBatchProgress(progressDialog, i + 1, programsToUpload.length, 
            `正在上架: ${programData.airDate} ${programData.airTime} - ${programData.title}`);
          
          try {
            const result = await uploadProgramSimple(programData);
            if (result.success) {
              if (result.skipped) {
                skippedCount++;
              } else {
                successCount++;
              }
            } else {
              errorCount++;
            }
          } catch (error) {
            console.error(`❌ 上架失敗 ${i + 1}/${programsToUpload.length}:`, error);
            errorCount++;
          }
          
          // 添加小延遲
          await new Promise(resolve => setTimeout(resolve, 200));
        }
        
        // 完成進度
        updateBatchProgressComplete(progressDialog, successCount, errorCount, skippedCount);
        
        showStatus(`從歷史複製完成：成功 ${successCount}，失敗 ${errorCount}，跳過 ${skippedCount}`, 'success');
        
      } catch (error) {
        console.error('❌ 從歷史複製失敗:', error);
        showStatus(`從歷史複製失敗: ${error.message}`, 'error');
      }
    }

    // 顯示覆蓋確認對話框
    function showOverwriteConfirmation(existingTitle, time, date, isBatchCopy = false, originalDate = null) {
      return new Promise((resolve) => {
        const dialog = document.createElement('div');
        dialog.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.5);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 10000;
        `;
        
        dialog.innerHTML = `
          <div style="
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
          ">
            <div style="text-align: center; margin-bottom: 20px;">
              <div style="font-size: 3rem; margin-bottom: 15px;">⚠️</div>
              <h3 style="color: #dc3545; margin-bottom: 15px;">時間衝突警告</h3>
            </div>
            
            <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
              <strong>發現時間衝突：</strong><br>
              <strong>日期：</strong>${date}<br>
              <strong>時間：</strong>${time}<br>
              <strong>現有節目：</strong>${existingTitle}
            </div>
            
            <div style="background: #d1ecf1; border: 1px solid #bee5eb; padding: 15px; border-radius: 8px; margin-bottom: 25px;">
              <strong>覆蓋說明：</strong><br>
              • 選擇「是」將刪除現有節目並上架新節目<br>
              ${isBatchCopy ? 
                `• 這是批量複製的一部分（原始日期：${originalDate}）<br>
                 • 批量複製只會影響 ${originalDate} 及之後的日期<br>
                 • ${originalDate} 之前的節目不會受到影響` :
                `• 只會影響 ${date} 這一天的節目`
              }<br>
              • 此操作無法復原，請謹慎選擇
            </div>
            
            <div style="text-align: center;">
              <button id="cancelOverwrite" style="
                background: #6c757d;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 6px;
                margin-right: 15px;
                cursor: pointer;
                font-size: 1rem;
              ">取消</button>
              <button id="confirmOverwrite" style="
                background: #dc3545;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 1rem;
              ">是，覆蓋現有節目</button>
            </div>
          </div>
        `;
        
        document.body.appendChild(dialog);
        
        // 取消按鈕
        document.getElementById('cancelOverwrite').onclick = () => {
          document.body.removeChild(dialog);
          resolve(false);
        };
        
        // 確認按鈕
        document.getElementById('confirmOverwrite').onclick = () => {
          document.body.removeChild(dialog);
          resolve(true);
        };
        
        // 點擊背景關閉
        dialog.onclick = (e) => {
          if (e.target === dialog) {
            document.body.removeChild(dialog);
            resolve(false);
          }
        };
        
        // ESC 鍵關閉
        const handleEsc = (e) => {
          if (e.key === 'Escape') {
            document.body.removeChild(dialog);
            document.removeEventListener('keydown', handleEsc);
            resolve(false);
          }
        };
        document.addEventListener('keydown', handleEsc);
      });
    }

    // 批量複製節目到整個月
    async function batchCopyToMonth(programData, targetDate, targetTime) {
      const monthDates = generateMonthDates(targetDate);
      const currentSlot = getTimeSlot(targetTime);
      const slotIndex = currentSlot.slot.slots.indexOf(targetTime);
      
      const programsToCreate = [];
      
      // 檢查是否為新節目（新 YouTube ID + 新主題）
      const isNewProgram = checkIfNewProgram(programData);
      
      for (let i = 0; i < monthDates.length; i++) {
        const date = monthDates[i];
        const isFirstDay = i === 0;
        
        // 當天其他時段的相同時間槽
        if (isFirstDay) {
          const otherSlots = getSameTimeSlotInOtherPeriods(targetTime);
          for (const slot of otherSlots) {
            // 新節目且晚場才為首播，否則重播
            const isEveningFirstTime = slot.period === 'EVENING' && isNewProgram;
            programsToCreate.push({
              ...programData,
              airDate: date,
              airTime: slot.time,
              status: isEveningFirstTime ? '首播' : '重播',
              isFirstBroadcast: isEveningFirstTime
            });
          }
        }
        
        // 隔天開始的相同時段
        const nextDayTime = currentSlot.slot.slots[slotIndex];
        // 新節目且晚場第一次上架才為首播，其餘重播
        const isEveningFirstTime = currentSlot.key === 'EVENING' && isFirstDay && isNewProgram;
        programsToCreate.push({
          ...programData,
          airDate: date,
          airTime: nextDayTime,
          status: isEveningFirstTime ? '首播' : '重播',
          isFirstBroadcast: isEveningFirstTime
        });
      }
      
      return programsToCreate;
    }

    // 檢查是否為新節目
    function checkIfNewProgram(programData) {
      // 檢查是否已存在相同 YouTube ID 和主題的節目
      const existingPrograms = Object.values(events).flat();
      const isNewYouTubeId = !existingPrograms.some(program => 
        program.youtubeId === programData.youtubeId
      );
      const isNewTitle = !existingPrograms.some(program => 
        program.title === programData.title
      );
      
      console.log('🔍 檢查是否為新節目:', {
        youtubeId: programData.youtubeId,
        title: programData.title,
        isNewYouTubeId,
        isNewTitle,
        isNewProgram: isNewYouTubeId && isNewTitle
      });
      
      return isNewYouTubeId && isNewTitle;
    }

    // 顯示批量複製確認對話框
    function showBatchCopyDialog(programData, targetDate, targetTime) {
      const currentSlot = getTimeSlot(targetTime);
      const otherSlots = getSameTimeSlotInOtherPeriods(targetTime);
      const monthDates = generateMonthDates(targetDate);
      const isNewProgram = checkIfNewProgram(programData);
      
      // 檢查首播時段警告
      const isAfternoonSlot = currentSlot.key === 'AFTERNOON';
      const showWarning = isNewProgram && isAfternoonSlot;
      
      const dialog = document.createElement('div');
      dialog.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.5); z-index: 10000;
        display: flex; align-items: center; justify-content: center;
      `;
      
      dialog.innerHTML = `
        <div style="background: white; padding: 30px; border-radius: 10px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto;">
          <h3>📅 批量排程選項</h3>
          <p><strong>節目：</strong>${programData.title}</p>
          <p><strong>時段：</strong>${currentSlot.slot.name} (${targetTime})</p>
          <p><strong>節目狀態：</strong>${isNewProgram ? '新節目' : '重複節目'}</p>
          
          ${showWarning ? `
            <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; margin: 15px 0;">
              <strong>⚠️ 首播時段警告：</strong><br>
              這是新節目，建議首播安排在晚場時段。下午場首播可能影響收視效果。
            </div>
          ` : ''}
          
          <div style="margin: 20px 0;">
            <h4>🎯 複製選項：</h4>
            
            <div style="margin: 15px 0;">
              <label style="display: flex; align-items: center; margin: 10px 0;">
                <input type="checkbox" id="copySameDay" checked style="margin-right: 10px;">
                <span>複製到當天其他時段的相同時間槽</span>
              </label>
              ${otherSlots.map(slot => {
                const isEveningFirstTime = slot.period === 'EVENING' && isNewProgram;
                return `
                  <div style="margin-left: 30px; color: #666;">
                    • ${slot.periodName}: ${slot.time} (${isEveningFirstTime ? '首播' : '重播'})
                  </div>
                `;
              }).join('')}
            </div>
            
            <div style="margin: 15px 0;">
              <label style="display: flex; align-items: center; margin: 10px 0;">
                <input type="checkbox" id="copyByDays" checked style="margin-right: 10px;">
                <span>按天數複製 (從 ${targetDate} 開始)</span>
              </label>
              <div style="margin-left: 30px; color: #666;">
                <div style="margin: 10px 0;">
                  <label style="margin-right: 15px;">
                    <input type="radio" name="copyDays" value="30" checked style="margin-right: 5px;">30天
                  </label>
                  <label style="margin-right: 15px;">
                    <input type="radio" name="copyDays" value="31" style="margin-right: 5px;">31天
                  </label>
                  <label style="margin-right: 15px;">
                    <input type="radio" name="copyDays" value="custom" style="margin-right: 5px;">自定義
                    <input type="number" id="customDays" value="30" min="1" max="90" style="width: 60px; margin-left: 5px;" disabled>天
                  </label>
                  <label>
                    <input type="radio" name="copyDays" value="toDate" style="margin-right: 5px;">到指定日期
                    <input type="date" id="endDate" style="margin-left: 5px; padding: 4px; border: 1px solid #ddd; border-radius: 4px;" disabled>
                  </label>
                </div>
                <div style="font-size: 0.9rem; margin-top: 5px;">
                  • 每天 ${currentSlot.slot.name}: ${targetTime}<br>
                  • 複製到所有時段的相同時間槽<br>
                  • ${isNewProgram && currentSlot.key === 'EVENING' ? '第1天: 首播，第2天起: 重播' : '全部為重播'}<br>
                  • 避免覆蓋月初節目，更靈活控制<br>
                  • 指定日期：精確控制結束時間（如 9/25 到 10/31）
                </div>
              </div>
            </div>
          </div>
          
          <div style="text-align: right; margin-top: 30px;">
            <button id="cancelBatch" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; margin-right: 10px; cursor: pointer;">取消</button>
            <button id="confirmBatch" style="background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">確認批量上架</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(dialog);

      // 處理自定義天數和日期選擇器的啟用/禁用
      const customDaysInput = document.getElementById('customDays');
      const endDateInput = document.getElementById('endDate');
      const copyDaysRadios = document.querySelectorAll('input[name="copyDays"]');
      
      // 設置預設結束日期（從開始日期算起30天）
      const startDate = new Date(targetDate);
      const defaultEndDate = new Date(startDate);
      defaultEndDate.setDate(startDate.getDate() + 30);
      endDateInput.value = defaultEndDate.toISOString().split('T')[0];
      
      copyDaysRadios.forEach(radio => {
        radio.addEventListener('change', function() {
          if (this.value === 'custom') {
            customDaysInput.disabled = false;
            endDateInput.disabled = true;
            customDaysInput.focus();
          } else if (this.value === 'toDate') {
            customDaysInput.disabled = true;
            endDateInput.disabled = false;
            endDateInput.focus();
          } else {
            customDaysInput.disabled = true;
            endDateInput.disabled = true;
          }
        });
      });
      
      return new Promise((resolve) => {
        // 取消按鈕
        const cancelBtn = document.getElementById('cancelBatch');
        if (cancelBtn) {
          cancelBtn.onclick = () => {
            console.log('📋 用戶點擊取消按鈕');
            document.body.removeChild(dialog);
            resolve(null);
          };
        }
        
        // 確認按鈕
        const confirmBtn = document.getElementById('confirmBatch');
        if (confirmBtn) {
          confirmBtn.onclick = () => {
            console.log('📋 用戶點擊確認按鈕');
            const copySameDay = document.getElementById('copySameDay')?.checked || false;
            const copyByDays = document.getElementById('copyByDays')?.checked || false;
            
            // 獲取天數選項
            let copyDays = 30; // 預設值
            let endDate = null;
            
            if (copyByDays) {
              const selectedDays = document.querySelector('input[name="copyDays"]:checked')?.value;
              if (selectedDays === 'custom') {
                copyDays = parseInt(document.getElementById('customDays')?.value) || 30;
              } else if (selectedDays === 'toDate') {
                endDate = document.getElementById('endDate')?.value;
                // 計算從開始日期到結束日期的天數
                if (endDate) {
                  const start = new Date(targetDate);
                  const end = new Date(endDate);
                  const diffTime = end - start;
                  copyDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // +1 包含開始日期
                }
              } else {
                copyDays = parseInt(selectedDays) || 30;
              }
            }
            
            console.log('📋 複製選項:', { copySameDay, copyByDays, copyDays, endDate });
            document.body.removeChild(dialog);
            resolve({ copySameDay, copyByDays, copyDays, endDate });
          };
        }
        
        // 點擊背景關閉
        dialog.onclick = (e) => {
          if (e.target === dialog) {
            console.log('📋 用戶點擊背景關閉');
            document.body.removeChild(dialog);
            resolve(null);
          }
        };
        
        // ESC 鍵關閉
        const handleEsc = (e) => {
          if (e.key === 'Escape') {
            console.log('📋 用戶按 ESC 關閉');
            document.body.removeChild(dialog);
            document.removeEventListener('keydown', handleEsc);
            resolve(null);
          }
        };
        document.addEventListener('keydown', handleEsc);
      });
    }

    // 創建批量上架進度條對話框
    function createBatchProgressDialog(totalCount) {
      const dialog = document.createElement('div');
      dialog.id = 'batchProgressDialog';
      dialog.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10001;
        font-family: Arial, sans-serif;
      `;
      
      dialog.innerHTML = `
        <div style="
          background: white;
          padding: 30px;
          border-radius: 10px;
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
          max-width: 500px;
          width: 90%;
          text-align: center;
        ">
          <h3 style="margin: 0 0 20px 0; color: #333;">📺 批量上架進行中</h3>
          <div style="margin: 20px 0;">
            <div style="
              background: #f0f0f0;
              border-radius: 10px;
              height: 20px;
              overflow: hidden;
              margin-bottom: 10px;
            ">
              <div id="batchProgressBar" style="
                background: linear-gradient(90deg, #007bff, #28a745);
                height: 100%;
                width: 0%;
                transition: width 0.3s ease;
                border-radius: 10px;
              "></div>
            </div>
            <div id="batchProgressText" style="color: #666; font-size: 14px;">
              準備中... (0/${totalCount})
            </div>
          </div>
          <div id="batchProgressList" style="
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            max-height: 200px;
            overflow-y: auto;
            text-align: left;
            font-size: 12px;
          "></div>
          <div style="margin-top: 20px; font-size: 12px; color: #666;">
            ⏳ 請稍候，正在批量上架節目到 Contentful...
          </div>
        </div>
      `;
      
      return dialog;
    }

    // 更新批量上架進度
    function updateBatchProgress(dialog, current, total, program) {
      const progressBar = dialog.querySelector('#batchProgressBar');
      const progressText = dialog.querySelector('#batchProgressText');
      const progressList = dialog.querySelector('#batchProgressList');
      
      const percentage = (current / total) * 100;
      
      if (progressBar) {
        progressBar.style.width = percentage + '%';
      }
      
      if (progressText) {
        progressText.textContent = `上架中... (${current}/${total})`;
      }
      
      if (progressList && program) {
        const status = program.status || '重播';
        const timeSlot = getTimeSlot(program.airTime);
        const slotName = timeSlot ? timeSlot.slot.name : '未知時段';
        
        progressList.innerHTML += `
          <div style="margin: 5px 0; padding: 5px; background: white; border-radius: 3px;">
            📺 ${program.title}<br>
            <small style="color: #666;">
              ${program.airDate} ${program.airTime} (${slotName}) - ${status}
            </small>
          </div>
        `;
        
        // 自動滾動到底部
        progressList.scrollTop = progressList.scrollHeight;
      }
    }

    // 更新批量上架完成狀態
    function updateBatchProgressComplete(dialog, successCount, failCount) {
      const progressText = dialog.querySelector('#batchProgressText');
      const progressBar = dialog.querySelector('#batchProgressBar');
      
      if (progressText) {
        if (failCount === 0) {
          progressText.innerHTML = `✅ 完成！成功上架 ${successCount} 個節目`;
          progressText.style.color = '#28a745';
        } else {
          progressText.innerHTML = `⚠️ 完成！成功 ${successCount} 個，失敗 ${failCount} 個`;
          progressText.style.color = '#ffc107';
        }
      }
      
      if (progressBar) {
        progressBar.style.background = failCount === 0 ? 
          'linear-gradient(90deg, #28a745, #20c997)' : 
          'linear-gradient(90deg, #ffc107, #fd7e14)';
      }
    }

    // 從描述中提取 YouTube ID
    function extractYouTubeId(description) {
      if (!description) return '';
      
      // 嘗試多種 YouTube ID 格式
      const patterns = [
        /\[YouTube:([^\]]+)\]/g,  // [YouTube:ID]
        /youtube\.com\/watch\?v=([a-zA-Z0-9_-]+)/g,  // youtube.com/watch?v=ID
        /youtu\.be\/([a-zA-Z0-9_-]+)/g,  // youtu.be/ID
        /youtube\.com\/embed\/([a-zA-Z0-9_-]+)/g,  // youtube.com/embed/ID
        /v=([a-zA-Z0-9_-]{11})/g  // v=ID (11 characters)
      ];
      
      for (const pattern of patterns) {
        const match = description.match(pattern);
        if (match) {
          // 提取 ID 部分
          const idMatch = match[0].match(/([a-zA-Z0-9_-]{11})/);
          if (idMatch) {
            return idMatch[1];
          }
        }
      }
      
      return '';
    }

    // 複製上架功能
    async function copyAndPublish() {
      const date = document.getElementById('editDate').value;
      const time = document.getElementById('airTime').value;
      const title = document.getElementById('title').value;
      const duration = document.getElementById('duration').value;
      const category = document.getElementById('category').value;
      const description = document.getElementById('description').value;
      const status = document.getElementById('status').value;

      if (!title || !date || !time) {
        showStatus('請先填寫完整的節目資訊', 'warning');
        return;
      }

      showStatus('正在準備複製上架...', 'info');

      try {
        // 獲取縮圖資料
        const thumbnailPreview = document.getElementById('thumbnailPreview');
        const currentThumbnail = thumbnailPreview.src;
        const isDefaultThumbnail = currentThumbnail.includes('placeholder') || currentThumbnail.includes('via.placeholder');
        
        // 獲取選中的主題探索分類
        const selectedTopics = [];
        document.querySelectorAll('input[name="topics"]:checked').forEach(checkbox => {
          selectedTopics.push(checkbox.value);
        });

        // 優先從 youtubeId 欄位獲取，如果沒有則從描述中提取
        const youtubeIdField = document.getElementById('youtubeId').value.trim();
        const extractedYouTubeId = youtubeIdField || extractYouTubeId(description);
        
        console.log('🔍 提取 YouTube ID 調試:', {
          youtubeIdField: youtubeIdField,
          description: description,
          extractedYouTubeId: extractedYouTubeId,
          category: category,
          topics: selectedTopics
        });

        // 檢查是否有 YouTube ID
        if (!extractedYouTubeId) {
          showStatus('❌ 無法找到 YouTube ID，請在 YouTube ID 欄位輸入或確保描述中包含 YouTube 連結或 [YouTube:ID] 格式', 'error');
          return;
        }

        const programData = {
          title: title,
          airDate: date,
          airTime: time,
          duration: parseInt(duration) || 30,
          category: category,
          description: description,
          status: status,
          thumbnail: isDefaultThumbnail ? '' : currentThumbnail,
          topics: selectedTopics,
          youtubeId: extractedYouTubeId,
          videoType: 'YouTube'
        };

        // 檢查時間槽並顯示批量複製選項
        const timeSlot = getTimeSlot(time);
        if (timeSlot) {
          console.log('🎯 檢測到時間槽:', timeSlot);
          
          // 顯示批量複製對話框
          const batchOptions = await showBatchCopyDialog(programData, date, time);
          
          if (!batchOptions) {
            showStatus('已取消複製上架', 'info');
            return;
          }

          // 準備要上架的節目列表
          const programsToUpload = [programData];
          
          if (batchOptions.copySameDay) {
            // 複製到當天其他時段的相同時間槽
            const otherSlots = getSameTimeSlotInOtherPeriods(time);
            const isNewProgram = checkIfNewProgram(programData);
            
            for (const slot of otherSlots) {
              // 新節目且晚場才為首播，否則重播
              const isEveningFirstTime = slot.period === 'EVENING' && isNewProgram;
              programsToUpload.push({
                ...programData,
                airTime: slot.time,
                status: isEveningFirstTime ? '首播' : '重播',
                isFirstBroadcast: isEveningFirstTime,
                youtubeId: programData.youtubeId
              });
            }
          }
          
          if (batchOptions.copyByDays) {
            // 按天數複製到所有時段相同時間槽
            const copyDays = batchOptions.copyDays;
            const endDate = batchOptions.endDate;
            let crossMonthDates;
            
            if (endDate) {
              // 使用指定結束日期生成日期範圍
              crossMonthDates = generateDateRange(date, endDate);
              console.log('📅 指定日期複製調試:', {
                startDate: date,
                endDate: endDate,
                copyDays: copyDays,
                crossMonthDates: crossMonthDates,
                crossMonthDatesLength: crossMonthDates.length
              });
            } else {
              // 使用天數生成日期範圍
              crossMonthDates = generateCrossMonthDates(date, copyDays);
              console.log('📅 按天數複製調試:', {
                startDate: date,
                copyDays: copyDays,
                crossMonthDates: crossMonthDates,
                crossMonthDatesLength: crossMonthDates.length
              });
            }
            
            const slotIndex = timeSlot.slot.slots.indexOf(time);
            const isNewProgram = checkIfNewProgram(programData);
            
            // 從第2天開始複製（第1天已經在 programsToUpload 中）
            for (let i = 1; i < crossMonthDates.length; i++) {
              const nextDate = crossMonthDates[i];
              
              // 複製到所有時段的相同時間槽
              Object.keys(TIME_SLOTS).forEach(periodKey => {
                const period = TIME_SLOTS[periodKey];
                const targetTime = period.slots[slotIndex];
                
                // 新節目且晚場第一次上架才為首播，其餘重播
                const isEveningFirstTime = periodKey === 'EVENING' && i === 1 && isNewProgram;
                
                programsToUpload.push({
                  ...programData,
                  airDate: nextDate,
                  airTime: targetTime,
                  status: isEveningFirstTime ? '首播' : '重播',
                  isFirstBroadcast: isEveningFirstTime,
                  youtubeId: programData.youtubeId,
                  // 標記為批量複製，用於覆蓋檢查
                  isBatchCopy: true,
                  originalDate: date
                });
              });
            }
          }

          // 創建進度條對話框
          const progressDialog = createBatchProgressDialog(programsToUpload.length);
          document.body.appendChild(progressDialog);
          
          // 批量上架節目
          const results = [];
          let successCount = 0;
          let failCount = 0;

          for (let i = 0; i < programsToUpload.length; i++) {
            const program = programsToUpload[i];
            
            // 更新進度條
            updateBatchProgress(progressDialog, i + 1, programsToUpload.length, program);
            
            try {
              console.log(`🚀 開始上架節目 ${i + 1}/${programsToUpload.length}:`, program);
              const result = await uploadProgramSimple(program);
              results.push({ program, result });
              
              if (result.success) {
                successCount++;
                console.log(`✅ 上架成功 ${i + 1}/${programsToUpload.length}: ${program.title}`);
              } else {
                failCount++;
                console.error(`❌ 上架失敗 ${i + 1}/${programsToUpload.length}: ${program.title}`, result.error);
              }
            } catch (error) {
              console.error(`❌ 上架節目異常 ${i + 1}/${programsToUpload.length}:`, program.title, error);
              console.error('錯誤詳情:', {
                message: error.message,
                stack: error.stack,
                program: program
              });
              results.push({ program, result: { success: false, error: error.message } });
              failCount++;
            }
            
            // 添加小延遲，讓用戶看到進度
            await new Promise(resolve => setTimeout(resolve, 200));
          }
          
          // 完成後更新進度條
          updateBatchProgressComplete(progressDialog, successCount, failCount);
          
          // 等待 3 秒後關閉進度條
          setTimeout(() => {
            if (document.body.contains(progressDialog)) {
              document.body.removeChild(progressDialog);
            }
          }, 3000);

          // 處理批量上架結果
          const publishedPrograms = JSON.parse(localStorage.getItem('published_programs') || '[]');
          
          for (const { program, result } of results) {
            if (result.success) {
              publishedPrograms.push({
                ...program,
                publishedAt: new Date().toISOString(),
                contentfulId: result.entryId,
                simulated: result.simulated || false
              });
              
              // 同步到今日節目表顯示系統
              updateCurrentScheduleForToday(program);
              
              // 更新日曆事件
              const event = getEvent(program.airDate, program.airTime);
              if (event) {
                event.published = true;
                event.publishedAt = new Date().toISOString();
                event.contentfulId = result.entryId;
              }
            }
          }
          
          localStorage.setItem('published_programs', JSON.stringify(publishedPrograms));
          saveEvents();
          renderCurrentView();

          // 顯示批量上架結果
          const totalPrograms = programsToUpload.length;
          const statusMessage = successCount === totalPrograms ? 
            `✅ 成功複製上架 ${successCount} 個節目到 Contentful！` :
            `⚠️ 複製上架完成：成功 ${successCount} 個，失敗 ${failCount} 個`;
          
          showStatus(statusMessage, successCount === totalPrograms ? 'success' : 'warning');

          // 關閉模態框
          closeModal();

        } else {
          showStatus('❌ 無法識別時間槽，請使用標準時間格式', 'error');
        }

      } catch (error) {
        console.error('複製上架失敗:', error);
        showStatus('❌ 複製上架失敗：' + error.message, 'error');
      }
    }

    // 創建新節目到 Contentful
    async function createNewProgram() {
      console.log('📅 開始創建新節目到 Contentful');

      const date = document.getElementById('editDate').value;
      const time = document.getElementById('airTime').value;
      const title = document.getElementById('title').value;
      const duration = document.getElementById('duration').value;
      const category = document.getElementById('category').value;
      const description = document.getElementById('description').value;
      const status = document.getElementById('status').value;

      if (!title || !date || !time) {
        showStatus('請先填寫完整的節目資訊', 'warning');
        return;
      }

      const today = new Date();
      const currentHour = today.getHours();
      const currentMinute = today.getMinutes();
      const todayString = today.getFullYear() + '-' +
                         String(today.getMonth() + 1).padStart(2, '0') + '-' +
                         String(today.getDate()).padStart(2, '0');
      const isPastDate = date < todayString;
      const isPastTime = date === todayString &&
                        (parseInt(time.split(':')[0]) < currentHour ||
                         (parseInt(time.split(':')[0]) === currentHour && parseInt(time.split(':')[1]) <= currentMinute));

      // 如果是過去的時間，顯示警語但允許繼續
      if (isPastDate || isPastTime) {
        const confirmMessage = isPastDate 
          ? `⚠️ 警告：您正在上架過去的日期 (${date})，這可能會影響節目排程。是否繼續？`
          : `⚠️ 警告：您正在上架過去的時間 (${date} ${time})，這可能會影響節目排程。是否繼續？`;
        
        if (!confirm(confirmMessage)) {
          showStatus('已取消上架', 'info');
        return;
        }
        showStatus('⚠️ 正在上架過去的時間，請注意節目排程影響', 'warning');
      }

      showStatus('正在上架節目到 Contentful...', 'info');

      try {
        // 獲取縮圖資料
        const thumbnailPreview = document.getElementById('thumbnailPreview');
        const currentThumbnail = thumbnailPreview.src;
        const isDefaultThumbnail = currentThumbnail.includes('placeholder') || currentThumbnail.includes('via.placeholder');
        
        // 獲取選中的主題探索分類
        const selectedTopics = [];
        document.querySelectorAll('input[name="topics"]:checked').forEach(checkbox => {
          selectedTopics.push(checkbox.value);
        });
        
        console.log('🔍 獲取選中的主題探索分類:', {
          selectedTopics: selectedTopics,
          topicsLength: selectedTopics.length,
          allCheckboxes: document.querySelectorAll('input[name="topics"]').length,
          checkedCheckboxes: document.querySelectorAll('input[name="topics"]:checked').length
        });
        
        const programData = {
          title: title,
          airDate: date,
          airTime: time,
          duration: parseInt(duration),
          category: category,
          description: description,
          status: status,
          videoType: document.getElementById('videoType').value,
          youtubeId: document.getElementById('videoType').value === 'YouTube' ? document.getElementById('youtubeId').value : null,
          mp4File: document.getElementById('videoType').value === 'MP4' ? (document.getElementById('mp4File').files[0] ? document.getElementById('mp4File').files[0].name : null) : null,
          thumbnail: isDefaultThumbnail ? null : currentThumbnail,
          topics: selectedTopics
        };

        // 上架新節目
        const result = await uploadProgramSimple(programData);

        if (result.success) {
          console.log('✅ 上架成功，準備關閉視窗...', { title });
          
          // 處理上架結果
          const publishedPrograms = JSON.parse(localStorage.getItem('published_programs') || '[]');
          publishedPrograms.push({
            ...programData,
            publishedAt: new Date().toISOString(),
            contentfulId: result.entryId,
            simulated: result.simulated || false
          });
            
          localStorage.setItem('published_programs', JSON.stringify(publishedPrograms));

          // 同步到今日節目表顯示系統
          updateCurrentScheduleForToday(programData);

          // 更新日曆事件
          const event = getEvent(programData.airDate, programData.airTime);
          if (event) {
            event.published = true;
            event.publishedAt = new Date().toISOString();
            event.contentfulId = result.entryId;
          }
            
          saveEvents();
          renderCurrentView();

          showStatus(`✅ 成功上架節目「${title}」到 Contentful！`, 'success');
          console.log('🚪 準備關閉視窗...');
          closeModal();
          console.log('✅ 視窗已關閉');
        } else {
          console.error('❌ 上架失敗:', result);
          showStatus('❌ 上架失敗：' + (result.error || '未知錯誤'), 'error');
        }

      } catch (error) {
        console.error('上架失敗:', error);
        showStatus('❌ 上架失敗：' + error.message, 'error');
      }
    }

    window.addEventListener('click', function(e) {
      const eventModal = document.getElementById('eventModal');
      const timeSlotModal = document.getElementById('timeSlotModal');

      if (e.target === eventModal) {
        closeModal();
      }

      if (e.target === timeSlotModal) {
        closeTimeSlotModal();
      }
    });

    // 測試上架功能
    async function testUploadFunction() {
      try {
        showStatus('🧪 開始測試上架功能...', 'info');
        
        // 創建測試節目數據
        const testProgram = {
          title: '測試節目 - ' + new Date().toLocaleTimeString(),
          airDate: new Date().toISOString().split('T')[0],
          airTime: '22:00',
          description: '這是一個測試節目',
          category: '測試',
          duration: 30,
          contentType: 'scheduleItem'
        };
        
        console.log('🧪 測試節目數據:', testProgram);
        
        // 執行上架
        const result = await uploadProgramSimple(testProgram);
        
        if (result.success) {
          showStatus(`✅ 測試上架成功！Entry ID: ${result.entryId}`, 'success');
          console.log('✅ 測試上架成功:', result);
        } else {
          showStatus(`❌ 測試上架失敗: ${result.error}`, 'error');
          console.error('❌ 測試上架失敗:', result);
        }
        
        return result;
        
      } catch (error) {
        showStatus(`❌ 測試上架異常: ${error.message}`, 'error');
        console.error('❌ 測試上架異常:', error);
        return { success: false, error: error.message };
      }
    }

    // 顯示測試日誌
    function showTestLogs() {
      const uploadHistory = window.contentfulRealIntegration.getUploadHistory();
      const publishedPrograms = JSON.parse(localStorage.getItem('published_programs') || '[]');
      
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.display = 'block';
      
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 800px; max-height: 80vh;">
          <div class="modal-header">
            <h3>📋 測試日誌和上架記錄</h3>
            <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
          </div>
          <div style="max-height: 60vh; overflow-y: auto;">
            <div style="margin-bottom: 20px;">
              <h4>🧪 上架測試記錄 (${uploadHistory.length} 筆)</h4>
              ${uploadHistory.length > 0 ? uploadHistory.map((item, index) => `
                <div style="border: 1px solid #eee; border-radius: 8px; padding: 15px; margin-bottom: 10px; background: white;">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <span style="font-weight: 600; color: #2b71d2;">測試 #${index + 1}</span>
                    <span style="background: ${item.simulated ? '#ffc107' : '#28a745'}; color: white; padding: 2px 8px; border-radius: 12px; font-size: 0.8rem;">
                      ${item.simulated ? '模擬模式' : '真實模式'}
                    </span>
                  </div>
                  <div style="font-weight: 600; margin-bottom: 5px;">${item.title}</div>
                  <div style="color: #666; font-size: 0.9rem; margin-bottom: 5px;">
                    <span>${item.airDate} ${item.airTime}</span> • 
                    <span>${item.category}</span> • 
                    <span>${item.duration}分鐘</span>
                  </div>
                  <div style="color: #666; font-size: 0.8rem;">
                    上架時間: ${new Date(item.uploadedAt).toLocaleString()}
                  </div>
                  ${item.contentfulId ? `<div style="color: #666; font-size: 0.8rem;">Contentful ID: ${item.contentfulId}</div>` : ''}
                </div>
              `).join('') : '<p style="color: #666; font-style: italic;">尚無測試記錄</p>'}
            </div>
            
            <div style="margin-bottom: 20px;">
              <h4>📺 已發布節目記錄 (${publishedPrograms.length} 筆)</h4>
              ${publishedPrograms.length > 0 ? publishedPrograms.map((item, index) => `
                <div style="border: 1px solid #eee; border-radius: 8px; padding: 15px; margin-bottom: 10px; background: white;">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <span style="font-weight: 600; color: #2b71d2;">節目 #${index + 1}</span>
                    <span style="background: ${item.simulated ? '#ffc107' : '#28a745'}; color: white; padding: 2px 8px; border-radius: 12px; font-size: 0.8rem;">
                      ${item.simulated ? '模擬發布' : '真實發布'}
                    </span>
                  </div>
                  <div style="font-weight: 600; margin-bottom: 5px;">${item.title}</div>
                  <div style="color: #666; font-size: 0.9rem; margin-bottom: 5px;">
                    <span>${item.airDate} ${item.airTime}</span> • 
                    <span>${item.category}</span> • 
                    <span>${item.duration}分鐘</span>
                  </div>
                  <div style="color: #666; font-size: 0.8rem;">
                    發布時間: ${new Date(item.publishedAt).toLocaleString()}
                  </div>
                  ${item.contentfulId ? `<div style="color: #666; font-size: 0.8rem;">Contentful ID: ${item.contentfulId}</div>` : ''}
                </div>
              `).join('') : '<p style="color: #666; font-style: italic;">尚無發布記錄</p>'}
            </div>
            
            <div style="margin-bottom: 20px;">
              <h4>🔧 系統狀態</h4>
              <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                <div style="margin-bottom: 10px;">
                  <strong>Contentful 配置:</strong>
                  <div style="font-family: monospace; font-size: 0.8rem; color: #666; margin-top: 5px;">
                    Space ID: ${window.contentfulUploadFix.config.space}<br>
                    Environment: ${window.contentfulUploadFix.config.environment}<br>
                    Management Token: ${window.contentfulUploadFix.config.managementToken ? '已設置' : '未設置'}
                  </div>
                </div>
                <div>
                  <strong>瀏覽器支援:</strong>
                  <div style="font-family: monospace; font-size: 0.8rem; color: #666; margin-top: 5px;">
                    Contentful SDK: ${typeof contentful !== 'undefined' ? '✅ 已載入' : '❌ 未載入'}<br>
                    Management SDK: ${typeof contentfulManagement !== 'undefined' ? '✅ 已載入' : '❌ 未載入'}<br>
                    Local Storage: ${typeof Storage !== 'undefined' ? '✅ 支援' : '❌ 不支援'}
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div style="text-align: center; margin-top: 20px;">
            <button class="btn btn-secondary" onclick="clearTestLogs()">🗑️ 清除測試記錄</button>
            <button class="btn" onclick="this.closest('.modal').remove()">關閉</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      modal.addEventListener('click', function(e) {
        if (e.target === modal) {
          modal.remove();
        }
      });
    }

    // 清除測試日誌
    function clearTestLogs() {
      if (confirm('確定要清除所有測試記錄嗎？')) {
        window.contentfulRealIntegration.clearAllLogs();
        localStorage.removeItem('published_programs');
        showStatus('測試記錄已清除', 'success');
        // 關閉模態框
        document.querySelector('.modal').remove();
      }
    }

    // 重新初始化 Contentful
    async function reinitializeContentful() {
      try {
        showStatus('正在重新初始化 Contentful...', 'info');
        console.log('🔄 開始重新初始化 Contentful...');
        
        // 檢查 SDK 狀態
        console.log('📊 當前 SDK 狀態:');
        console.log('- Contentful SDK:', typeof contentful !== 'undefined' ? '✅ 已載入' : '❌ 未載入');
        console.log('- Management SDK:', typeof contentfulManagement !== 'undefined' ? '✅ 已載入' : '❌ 未載入');
        
        // 如果 Management SDK 未載入，嘗試載入
        if (typeof contentfulManagement === 'undefined') {
          console.log('📥 嘗試載入 Management SDK...');
          // Management SDK 應該已經載入，如果沒有則重新初始化
          await window.contentfulRealIntegration.init();
        }
        
        // 重新初始化
        const initResult = await window.contentfulRealIntegration.init();
        
        if (initResult) {
          showStatus('✅ Contentful 重新初始化成功！', 'success');
          console.log('✅ 重新初始化完成');
          
        // 測試連接
        const connectionTest = await window.contentfulRealIntegration.testConnection();
          console.log('🔗 連接測試結果:', connectionTest);
          
          if (connectionTest.success) {
            showStatus('✅ Contentful 連接正常，可以進行真實上架！', 'success');
          } else {
            showStatus('⚠️ Contentful 連接有問題：' + connectionTest.error, 'warning');
          }
        } else {
          showStatus('❌ Contentful 重新初始化失敗', 'error');
        }
        
      } catch (error) {
        console.error('❌ 重新初始化失敗:', error);
        showStatus('❌ 重新初始化失敗：' + error.message, 'error');
      }
    }

    // 強制載入 Management SDK
    async function forceLoadManagementSDK() {
      try {
        showStatus('正在強制修復載入 Management SDK...', 'info');
        console.log('🔧 開始強制修復載入 Management SDK...');
        
        if (!window.contentfulManagementFix) {
          showStatus('❌ Management 修復載入器不可用', 'error');
          return;
        }
        
        // 檢查當前狀態
        const status = window.contentfulManagementFix.checkStatus();
        console.log('📊 當前狀態:', status);
        
        // 強制重新載入
        await window.contentfulManagementFix.forceReload();
        
        // 檢查載入結果
        const newStatus = window.contentfulManagementFix.checkStatus();
        console.log('📊 載入後狀態:', newStatus);
        
        if (newStatus.sdkAvailable) {
          showStatus('✅ Management SDK 修復載入成功！', 'success');
          
          // 重新初始化 Contentful
          const initResult = await window.contentfulRealIntegration.init();
          if (initResult) {
            showStatus('✅ Contentful 重新初始化成功，現在可以真實上架！', 'success');
          } else {
            showStatus('⚠️ Management SDK 載入成功但初始化失敗', 'warning');
          }
        } else {
          showStatus('❌ Management SDK 修復載入失敗', 'error');
        }
        
      } catch (error) {
        console.error('❌ 強制修復載入 Management SDK 失敗:', error);
        showStatus('❌ 強制修復載入失敗：' + error.message, 'error');
        
        // 嘗試重試
        if (window.contentfulManagementFix && window.contentfulManagementFix.retryCount < 5) {
          console.log('🔄 嘗試重試載入...');
          try {
            await window.contentfulManagementFix.retryLoad();
            showStatus('✅ 重試載入成功！', 'success');
          } catch (retryError) {
            showStatus('❌ 重試載入也失敗：' + retryError.message, 'error');
          }
        }
      }
    }

    // 開啟統一測試與日誌查看器
    // 開啟 Contentful 主控台
    function openMainConsole() {
      window.open('contentful-main-console.html', '_blank', 'width=1400,height=900,scrollbars=yes,resizable=yes');
    }

    // 前往主控台
    function goToDashboard() {
      window.location.href = 'admin-dashboard.html';
    }

    // 從 Contentful 重新載入節目
    async function reloadFromContentful() {
      try {
        showStatus('正在從 Contentful 重新載入節目...', 'info');
        
        // 先測試連線
        await testContentfulConnection();
        
        await loadEventsFromContentful();
        renderCurrentView();
        showStatus('✅ 已從 Contentful 重新載入節目', 'success');
        
        // 顯示載入的節目數量
        const totalEvents = Object.values(events).reduce((sum, dayEvents) => sum + dayEvents.length, 0);
        console.log(`✅ 共載入 ${totalEvents} 個節目`);
      } catch (error) {
        console.error('重新載入失敗:', error);
        showStatus('❌ 重新載入失敗：' + error.message, 'error');
      }
    }

    // 測試 Contentful 連線
    async function testContentfulConnection() {
      try {
        console.log('🔍 測試 Contentful 連線...');
        
        if (typeof contentful === 'undefined') {
          throw new Error('Contentful SDK 未載入');
        }

        const client = contentful.createClient({
          space: window.CONTENTFUL_CONFIG?.SPACE_ID || 'os5wf90ljenp',
          accessToken: window.CONTENTFUL_CONFIG?.DELIVERY_TOKEN
        });

        // 測試獲取空間資訊
        const space = await client.getSpace();
        console.log('✅ Contentful 連線成功，空間:', space.name);
        
        // 測試獲取內容類型
        const contentTypes = await client.getContentTypes();
        console.log('✅ 內容類型數量:', contentTypes.items.length);
        
        // 檢查是否有 scheduleItem 內容類型
        const scheduleItemType = contentTypes.items.find(ct => ct.sys.id === 'scheduleItem');
        if (scheduleItemType) {
          console.log('✅ 找到 scheduleItem 內容類型');
        } else {
          console.log('⚠️ 未找到 scheduleItem 內容類型');
        }
        
        return true;
      } catch (error) {
        console.error('❌ Contentful 連線測試失敗:', error);
        throw error;
      }
    }


    // 上架選中的節目到 Contentful
    async function uploadSelectedPrograms() {
      try {
        // 先檢查系統狀態
        if (typeof contentfulManagement === 'undefined') {
          alert('❌ Management SDK 未載入\n請重新載入頁面');
          return;
        }
        
        // 檢查是否有選中的節目
        const selectedPrograms = getSelectedPrograms();
        if (selectedPrograms.length === 0) {
          alert('請先選擇要上架的節目！\n\n選擇方式：\n1. 在日曆中點擊節目\n2. 或使用「調試節目」功能查看所有節目');
          return;
        }

        // 確認上架
        const confirmMessage = `確定要上架以下 ${selectedPrograms.length} 個節目到 Contentful 嗎？\n\n${selectedPrograms.map(p => `• ${p.title} (${p.airDate} ${p.airTime})`).join('\n')}`;
        if (!confirm(confirmMessage)) {
          return;
        }

        // 顯示進度
        const progressDiv = document.createElement('div');
        progressDiv.id = 'uploadProgress';
        progressDiv.style.cssText = `
          position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
          background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
          z-index: 10000; max-width: 500px; width: 90%;
        `;
        progressDiv.innerHTML = `
          <h3>📺 節目上架中...</h3>
          <div id="progressList" style="max-height: 300px; overflow-y: auto; margin: 10px 0;"></div>
          <button onclick="document.getElementById('uploadProgress').remove()" style="background: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer;">關閉</button>
        `;
        document.body.appendChild(progressDiv);

        const progressList = document.getElementById('progressList');
        
        // 等待 Management SDK 載入
        let retryCount = 0;
        const maxRetries = 10;
        
        while (typeof contentfulManagement === 'undefined' && retryCount < maxRetries) {
          progressList.innerHTML += `<div>⏳ 等待 Management SDK 載入... (${retryCount + 1}/${maxRetries})</div>`;
          await new Promise(resolve => setTimeout(resolve, 1000));
          retryCount++;
        }
        
        if (typeof contentfulManagement === 'undefined') {
          throw new Error('Management SDK 載入失敗，請重新載入頁面');
        }
        
        progressList.innerHTML += '<div>✅ Management SDK 已載入</div>';

        let successCount = 0;
        let failCount = 0;

        // 逐個上架節目
        for (let i = 0; i < selectedPrograms.length; i++) {
          const program = selectedPrograms[i];
          progressList.innerHTML += `<div>📺 上架節目 ${i + 1}/${selectedPrograms.length}: ${program.title}</div>`;
          
          try {
            // 準備節目數據
            const programData = {
              contentType: 'scheduleItem',
              title: program.title,
              airDate: program.airDate,
              airTime: program.airTime,
              slotNumber: program.slotNumber || 0,
              isFirstBroadcast: program.isFirstBroadcast || false,
              notes: program.notes || '',
              videoReference: program.videoReference || '',
              category: program.category || '旅遊節目',
              duration: program.duration || 30
            };

            // 上架到 Contentful（使用簡化功能）
            const result = await uploadProgramSimple(programData);
            
            if (result.success) {
              progressList.innerHTML += `<div style="color: green;">✅ ${program.title} 上架成功 (ID: ${result.entryId})</div>`;
              successCount++;
            } else {
              progressList.innerHTML += `<div style="color: red;">❌ ${program.title} 上架失敗</div>`;
              failCount++;
            }
          } catch (error) {
            progressList.innerHTML += `<div style="color: red;">❌ ${program.title} 上架錯誤: ${error.message}</div>`;
            failCount++;
          }
        }

        // 顯示結果
        progressList.innerHTML += `<div style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
          <strong>上架完成！</strong><br>
          ✅ 成功: ${successCount} 個<br>
          ❌ 失敗: ${failCount} 個<br>
          📊 總計: ${selectedPrograms.length} 個節目
        </div>`;

        // 更新本地節目狀態
        if (successCount > 0) {
          updateLocalProgramStatus(selectedPrograms.slice(0, successCount), 'uploaded');
        }

      } catch (error) {
        alert(`節目上架失敗: ${error.message}\n\n請檢查：\n1. Contentful 系統是否已初始化\n2. 網路連線是否正常\n3. API Token 是否正確`);
        console.error('節目上架錯誤:', error);
      }
    }

    // 獲取選中的節目
    function getSelectedPrograms() {
      const selectedPrograms = [];
      
      // 從 localStorage 中獲取節目資料
      const calendarEvents = JSON.parse(localStorage.getItem('calendar_events') || '{}');
      
      // 從日曆事件中獲取節目
      Object.keys(calendarEvents).forEach(date => {
        calendarEvents[date].forEach(event => {
          if (event.selected) {
            selectedPrograms.push({
              title: event.title,
              airDate: date,
              airTime: event.time,
              slotNumber: event.slotNumber || 0,
              isFirstBroadcast: event.isFirstBroadcast || false,
              notes: event.notes || '',
              videoReference: event.videoReference || '',
              category: event.category || '旅遊節目',
              duration: event.duration || 30
            });
          }
        });
      });

      // 如果沒有選中的節目，返回今日所有節目
      if (selectedPrograms.length === 0) {
        const today = new Date().toISOString().split('T')[0];
        if (calendarEvents[today]) {
          calendarEvents[today].forEach(event => {
            selectedPrograms.push({
              title: event.title,
              airDate: today,
              airTime: event.time,
              slotNumber: event.slotNumber || 0,
              isFirstBroadcast: event.isFirstBroadcast || false,
              notes: event.notes || '',
              videoReference: event.videoReference || '',
              category: event.category || '旅遊節目',
              duration: event.duration || 30
            });
          });
        }
      }

      return selectedPrograms;
    }

    // 更新本地節目狀態
    function updateLocalProgramStatus(programs, status) {
      programs.forEach(program => {
        const eventKey = `${program.airDate}_${program.airTime}`;
        if (window.calendarEvents && window.calendarEvents[program.airDate]) {
          const event = window.calendarEvents[program.airDate].find(e => e.time === program.airTime);
          if (event) {
            event.uploadStatus = status;
            event.uploadedAt = new Date().toISOString();
          }
        }
      });
      
      // 保存到本地存儲
      if (window.calendarEvents) {
        localStorage.setItem('calendarEvents', JSON.stringify(window.calendarEvents));
      }
    }

    // 檢查系統狀態
    function checkSystemStatus() {
      const status = {
        contentful: typeof contentful !== 'undefined',
        contentfulManagement: typeof contentfulManagement !== 'undefined',
        windowContentfulManagement: typeof window.contentfulManagement !== 'undefined',
        uploadProgramSimple: typeof uploadProgramSimple === 'function'
      };
      
      console.log('系統狀態檢查:', status);
      
      let message = '系統狀態檢查結果:\n\n';
      message += status.contentful ? '✅ Contentful SDK 已載入\n' : '❌ Contentful SDK 未載入\n';
      message += status.contentfulManagement ? '✅ Management SDK 已載入\n' : '❌ Management SDK 未載入\n';
      message += status.windowContentfulManagement ? '✅ window.contentfulManagement 可用\n' : '❌ window.contentfulManagement 不可用\n';
      message += status.uploadProgramSimple ? '✅ 上架功能可用\n' : '❌ 上架功能不可用\n';
      
      // 診斷資訊
      message += '\n診斷資訊:\n';
      message += `- contentful: ${typeof contentful}\n`;
      message += `- contentfulManagement: ${typeof contentfulManagement}\n`;
      message += `- window.contentfulManagement: ${typeof window.contentfulManagement}\n`;
      message += `- uploadProgramSimple: ${typeof uploadProgramSimple}\n`;
      
      if (status.contentful && status.contentfulManagement && status.uploadProgramSimple) {
        message += '\n🎉 系統狀態正常，可以進行真實節目上架！';
        alert(message);
        return true;
      } else {
        message += '\n⚠️ 系統狀態異常，Management SDK 未載入';
        alert(message);
        return false;
      }
    }

    // 將時間轉換為時段範圍
    // 圖片壓縮函數
    function compressImage(base64String, quality = 0.7) {
      return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        
        img.onload = function() {
          // 計算新尺寸（最大寬度 400px，更小的尺寸以減少 base64 長度）
          const maxWidth = 400;
          const maxHeight = 300;
          let { width, height } = img;
          
          // 計算縮放比例
          const widthRatio = maxWidth / width;
          const heightRatio = maxHeight / height;
          const ratio = Math.min(widthRatio, heightRatio, 1); // 不放大圖片
          
          if (ratio < 1) {
            width = Math.floor(width * ratio);
            height = Math.floor(height * ratio);
          }
          
          canvas.width = width;
          canvas.height = height;
          
          // 繪製壓縮後的圖片
          ctx.drawImage(img, 0, 0, width, height);
          
          // 轉換為 base64，使用更低的品質
          let compressedBase64 = canvas.toDataURL('image/jpeg', quality);
          
          // 檢查 base64 長度，如果還是太長，進一步降低品質
          let currentQuality = quality;
          while (compressedBase64.length > 30000 && currentQuality > 0.1) { // 限制在 30KB 以內
            currentQuality -= 0.1;
            compressedBase64 = canvas.toDataURL('image/jpeg', currentQuality);
            console.log(`🔄 進一步壓縮圖片，品質: ${currentQuality.toFixed(1)}, 大小: ${compressedBase64.length} 字符`);
          }
          
          console.log(`📊 最終壓縮結果: 品質 ${currentQuality.toFixed(1)}, 大小 ${compressedBase64.length} 字符`);
          resolve(compressedBase64);
        };
        
        img.onerror = function() {
          console.error('❌ 圖片載入失敗');
          resolve(base64String); // 如果載入失敗，返回原始數據
        };
        
        img.src = base64String;
      });
    }

    // 檢查並調整 notes 欄位長度
    function validateAndAdjustNotesLength(notes, maxLength = 45000) {
      if (notes.length <= maxLength) {
        return notes;
      }
      
      console.warn(`⚠️ Notes 欄位過長 (${notes.length} 字符)，開始調整...`);
      
      // 嘗試移除縮圖數據
      const thumbnailMatch = notes.match(/\[縮圖:data:image\/[^]]+\]/);
      if (thumbnailMatch) {
        const withoutThumbnail = notes.replace(thumbnailMatch[0], '[縮圖:已移除-過長]');
        console.log(`📊 移除縮圖後長度: ${withoutThumbnail.length} 字符`);
        
        if (withoutThumbnail.length <= maxLength) {
          return withoutThumbnail;
        }
      }
      
      // 如果還是太長，截斷描述文字
      const descriptionMatch = notes.match(/^(\[分類:[^\]]+\])(.*?)(\[時長:[^\]]+\])(.*)$/s);
      if (descriptionMatch) {
        const [, category, description, duration, rest] = descriptionMatch;
        const maxDescriptionLength = maxLength - category.length - duration.length - rest.length - 100; // 預留 100 字符緩衝
        
        if (maxDescriptionLength > 0) {
          const truncatedDescription = description.length > maxDescriptionLength 
            ? description.substring(0, maxDescriptionLength - 3) + '...'
            : description;
          
          const adjustedNotes = category + truncatedDescription + duration + rest;
          console.log(`📊 截斷描述後長度: ${adjustedNotes.length} 字符`);
          return adjustedNotes;
        }
      }
      
      // 最後手段：直接截斷
      const truncated = notes.substring(0, maxLength - 3) + '...';
      console.warn(`⚠️ 直接截斷 notes 到 ${truncated.length} 字符`);
      return truncated;
    }

    function getTimeBlock(timeString) {
      if (!timeString) return '12-18';
      
      const hour = parseInt(timeString.split(':')[0]);
      
      if (hour >= 0 && hour < 6) return '00-06';
      if (hour >= 6 && hour < 12) return '06-12';
      if (hour >= 12 && hour < 18) return '12-18';
      if (hour >= 18 && hour < 24) return '18-24';
      
      return '12-18'; // 預設值
    }

    // 清理舊的測試資料
    function clearOldTestData() {
      try {
        const calendarEvents = JSON.parse(localStorage.getItem('calendar_events') || '{}');
        let removedCount = 0;
        
        Object.keys(calendarEvents).forEach(date => {
          calendarEvents[date] = calendarEvents[date].filter(event => {
            // 檢查是否為測試資料
            const isTestData = 
              event.title.includes('加拿大') || 
              event.title.includes('極光') || 
              event.title.includes('寒冰') || 
              event.title.includes('捕魚') ||
              event.title.includes('測試') ||
              event.title.includes('demo') ||
              event.title.includes('Demo');
            
            if (isTestData) {
              removedCount++;
              console.log('移除測試資料:', event.title);
              return false;
            }
            return true;
          });
        });
        
        // 儲存清理後的資料
        localStorage.setItem('calendar_events', JSON.stringify(calendarEvents));
        
        if (removedCount > 0) {
          showStatus(`已清理 ${removedCount} 個測試節目資料`, 'success');
          console.log(`已清理 ${removedCount} 個測試節目資料`);
        } else {
          showStatus('沒有找到需要清理的測試資料', 'info');
        }
        
        return removedCount;
      } catch (error) {
        console.error('清理測試資料失敗:', error);
        showStatus('清理測試資料失敗: ' + error.message, 'error');
        return 0;
      }
    }

    // 檢查 Contentful 內容類型（供按鈕調用）
    async function checkContentfulContentTypes() {
      try {
        showStatus('正在檢查 Contentful 內容類型...', 'info');
        
        // 檢查 Management SDK
        if (typeof contentfulManagement === 'undefined') {
          throw new Error('Management SDK 未載入');
        }

        // 創建 Management 客戶端
        const managementClient = contentfulManagement.createClient({
          accessToken: window.CONTENTFUL_CONFIG?.MANAGEMENT_TOKEN || window.CONTENTFUL_MANAGEMENT_TOKEN
        });

        // 獲取 Space
        const space = await managementClient.getSpace(window.CONTENTFUL_CONFIG?.SPACE_ID || 'os5wf90ljenp');
        
        // 獲取 Environment
        const environment = await space.getEnvironment('master');
        
        // 檢查內容類型
        const contentTypes = await checkAvailableContentTypes(environment);
        
        // 顯示結果在頁面上
        let message = `找到 ${contentTypes.length} 個內容類型：\n\n`;
        contentTypes.forEach(ct => {
          message += `📋 ${ct.name} (${ct.sys.id})\n`;
          message += `   欄位: ${ct.fields.map(f => `${f.name}(${f.id}:${f.type})`).join(', ')}\n\n`;
        });
        
        console.log('Contentful 內容類型:', contentTypes);
        console.log('=== 內容類型詳細資訊 ===');
        console.log(message);
        
        // 在狀態欄顯示結果
        showStatus(`✅ 找到 ${contentTypes.length} 個內容類型，詳情請查看控制台`, 'success');
        
        // 在頁面上創建一個顯示區域
        let displayDiv = document.getElementById('contentTypesDisplay');
        if (!displayDiv) {
          displayDiv = document.createElement('div');
          displayDiv.id = 'contentTypesDisplay';
          displayDiv.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 2px solid #007bff;
            border-radius: 8px;
            padding: 20px;
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
            z-index: 10000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            font-family: monospace;
            white-space: pre-line;
          `;
          document.body.appendChild(displayDiv);
        }
        
        displayDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3 style="margin: 0; color: #007bff;">Contentful 內容類型</h3>
            <button onclick="document.getElementById('contentTypesDisplay').remove()" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">關閉</button>
          </div>
          <div style="max-height: 400px; overflow-y: auto;">${message}</div>
        `;
        
      } catch (error) {
        console.error('檢查內容類型失敗:', error);
        showStatus('❌ 檢查內容類型失敗: ' + error.message, 'error');
        alert('檢查內容類型失敗: ' + error.message);
      }
    }

    // 檢查 Contentful 中可用的內容類型
    async function checkAvailableContentTypes(environment) {
      try {
        const contentTypes = await environment.getContentTypes();
        console.log('可用的內容類型:', contentTypes.items.map(ct => ({
          id: ct.sys.id,
          name: ct.name,
          fields: ct.fields.map(f => ({ id: f.id, name: f.name, type: f.type }))
        })));
        return contentTypes.items;
      } catch (error) {
        console.error('獲取內容類型失敗:', error);
        return [];
      }
    }

    // 創建或獲取預設影片 Entry
    async function createOrGetDefaultVideoEntry(managementClient, space, environment) {
      try {
        // 先檢查可用的內容類型
        const contentTypes = await checkAvailableContentTypes(environment);
        
        // 尋找影片相關的內容類型
        const videoContentType = contentTypes.find(ct => 
          ct.sys.id === 'video' || 
          ct.sys.id === 'videoAsset' || 
          ct.name.toLowerCase().includes('video') ||
          ct.name.toLowerCase().includes('影片')
        );
        
        if (!videoContentType) {
          console.log('沒有找到影片內容類型，跳過 video 欄位');
          return null;
        }
        
        console.log('找到影片內容類型:', videoContentType.sys.id, videoContentType.name);
        
        // 嘗試獲取現有的影片 Entry
        const existingVideos = await environment.getEntries({
          content_type: videoContentType.sys.id,
          limit: 1
        });
        
        if (existingVideos.items.length > 0) {
          console.log('找到現有影片 Entry:', existingVideos.items[0].sys.id);
          return existingVideos.items[0].sys.id;
        }
        
        // 如果沒有現有的，創建一個預設的影片 Entry
        console.log('創建預設影片 Entry...');
        const videoEntryData = {
          fields: {
            'title': { 'en-US': '預設影片' },
            'videoType': { 'en-US': 'MP4' },
            'youTubeId': { 'en-US': '' },
            'mp4Url': { 'en-US': '' },
            'isHero': { 'en-US': false },
            'heroTitle': { 'en-US': '' },
            'heroText': { 'en-US': '' },
            'isFeatured': { 'en-US': false },
            'featuredText': { 'en-US': '' },
            'comingSoon': { 'en-US': false },
            'releaseDate': { 'en-US': new Date().toISOString() },
            'description': { 'en-US': '預設影片描述' }
          }
        };
        
        // 根據內容類型添加必要的欄位
        videoContentType.fields.forEach(field => {
          if (field.required && !videoEntryData.fields[field.id]) {
            if (field.type === 'Text' || field.type === 'ShortText') {
              videoEntryData.fields[field.id] = { 'en-US': '預設值' };
            } else if (field.type === 'Number') {
              videoEntryData.fields[field.id] = { 'en-US': 0 };
            } else if (field.type === 'Boolean') {
              videoEntryData.fields[field.id] = { 'en-US': false };
            }
          }
        });
        
        const videoEntry = await environment.createEntry(videoContentType.sys.id, videoEntryData);
        await videoEntry.publish();
        
        console.log('創建預設影片 Entry 成功:', videoEntry.sys.id);
        return videoEntry.sys.id;
        
      } catch (error) {
        console.error('創建或獲取影片 Entry 失敗:', error);
        // 如果創建失敗，返回 null，讓上架函數決定如何處理
        return null;
      }
    }

    // 簡化的上架功能（不依賴 contentful-real-only.js）
    // 創建或獲取 video entry
    async function createOrGetVideoEntry(youtubeId, title, environment) {
      try {
        // 先檢查是否已存在相同的 video entry
        const existingVideos = await environment.getEntries({
          content_type: 'video',
          'fields.youTubeId': youtubeId
        });
        
        if (existingVideos.items.length > 0) {
          console.log('找到現有的 video entry:', existingVideos.items[0].sys.id);
          return existingVideos.items[0];
        }
        
        // 創建新的 video entry
        const videoEntry = await environment.createEntry('video', {
          fields: {
            'title': { 'en-US': title || 'YouTube 影片' },
            'youTubeId': { 'en-US': youtubeId },
            'thumbnail': { 'en-US': `https://img.youtube.com/vi/${youtubeId}/maxresdefault.jpg` }
          }
        });
        
        // 發布 video entry
        await videoEntry.publish();
        console.log('創建新的 video entry:', videoEntry.sys.id);
        return videoEntry;
        
      } catch (error) {
        console.error('創建 video entry 失敗:', error);
        throw error;
      }
    }

    // 更新現有節目到 Contentful
    async function updateProgramInContentful(contentfulId, programData) {
      try {
        console.log('🔄 開始更新節目到 Contentful:', contentfulId, programData);
        
        // 檢查 API Token
        const managementToken = window.CONTENTFUL_CONFIG?.MANAGEMENT_TOKEN || window.CONTENTFUL_MANAGEMENT_TOKEN;
        if (!managementToken) {
          throw new Error('Management Token 未設定');
        }

        // 創建 Contentful Management API 客戶端
        const managementClient = contentfulManagement.createClient({
          accessToken: managementToken
        });

        // 獲取 Space 和 Environment
        const spaceId = window.CONTENTFUL_CONFIG?.SPACE_ID || 'os5wf90ljenp';
        const space = await managementClient.getSpace(spaceId);
        const environment = await space.getEnvironment('master');

        // 獲取現有條目
        const entry = await environment.getEntry(contentfulId);
        
        // 準備更新資料
        console.log('🔍 處理主題探索分類:', {
          programDataTopics: programData.topics,
          topicsLength: programData.topics ? programData.topics.length : 0,
          topicsType: typeof programData.topics
        });
        
        const topicsText = programData.topics && programData.topics.length > 0 
          ? programData.topics.map(topicId => {
              const topicData = TOPICS_DATA.find(t => t.id === topicId);
              console.log('🔍 主題映射:', { topicId, topicData: topicData ? topicData.title : '未找到' });
              return topicData ? topicData.title : topicId;
            }).join(',')
          : '';
        
        console.log('🔍 最終主題文字:', topicsText);
        
        // 構建備註內容，包含分類和主題標記
        let notes = programData.description || '';
        
        // 添加分類標記
        if (programData.category) {
          const categoryPattern = /\[分類:.*?\]/g;
          notes = notes.replace(categoryPattern, '');
          notes = `[分類:${programData.category}] ${notes}`;
        }
        
        // 添加主題標記
        if (topicsText) {
          const topicPattern = /\[主題:.*?\]/g;
          notes = notes.replace(topicPattern, '');
          notes = `${notes} [主題:${topicsText}]`;
          console.log('🔍 添加主題標記後的備註:', notes.substring(0, 200) + '...');
        } else {
          console.log('⚠️ 沒有主題文字，跳過主題標記');
        }
        
        // 添加時長標記
        if (programData.duration) {
          const durationPattern = /\[時長:.*?\]/g;
          notes = notes.replace(durationPattern, '');
          notes = `${notes} [時長:${programData.duration}分鐘]`;
        }
        
        // 添加狀態標記
        if (programData.status) {
          const statusPattern = /\[狀態:.*?\]/g;
          notes = notes.replace(statusPattern, '');
          notes = `${notes} [狀態:${programData.status}]`;
        }
        
        // 添加縮圖標記（檢查大小）
        if (programData.thumbnail) {
          const thumbnailPattern = /\[縮圖:.*?\]/g;
          notes = notes.replace(thumbnailPattern, '');
          
          // 檢查縮圖大小
          let thumbnail = programData.thumbnail;
          if (thumbnail.startsWith('data:image/')) {
            const sizeInBytes = (thumbnail.length * 3) / 4; // base64 大小估算
            const maxSize = 500000; // 500KB 限制
            
            if (sizeInBytes > maxSize) {
              console.warn('⚠️ 縮圖太大，嘗試壓縮...', { sizeInBytes, maxSize });
              thumbnail = await compressImage(thumbnail, 0.7); // 壓縮到 70% 品質
              const newSize = (thumbnail.length * 3) / 4;
              console.log('📊 壓縮後大小:', { newSize, originalSize: sizeInBytes });
            }
          }
          
          notes = `${notes} [縮圖:${thumbnail}]`;
        }

        // 驗證並調整 notes 欄位長度
        notes = validateAndAdjustNotesLength(notes);

        // 計算 block 和 slotIndex
        const block = getTimeBlock(programData.airTime);
        const slotIndex = 0; // 預設值，可以根據需要調整
        
        // 更新條目（只更新 Contentful 中實際存在的欄位）
        entry.fields.title = { 'en-US': programData.title };
        entry.fields.airDate = { 'en-US': programData.airDate };
        entry.fields.block = { 'en-US': block };
        entry.fields.slotIndex = { 'en-US': slotIndex };
        entry.fields.notes = { 'en-US': notes };
        
        // 注意：duration、status、youtubeId、thumbnail 等資訊都存儲在 notes 欄位中
        // 不需要單獨更新這些欄位，因為它們在 Contentful 中不存在

        // 保存更新
        const updatedEntry = await entry.update();
        
        // 發布更新
        await updatedEntry.publish();
        
        console.log('✅ 成功更新節目到 Contentful:', updatedEntry.sys.id);
        
        // 更新本地事件資料
        const event = getEvent(programData.airDate, programData.airTime);
        if (event) {
          event.title = programData.title;
          event.duration = programData.duration;
          event.category = programData.category;
          event.description = notes;
          event.status = programData.status;
          event.youtubeId = programData.youtubeId;
          event.thumbnail = programData.thumbnail;
          event.topics = programData.topics;
          event.publishedAt = new Date().toISOString();
          event.contentfulId = updatedEntry.sys.id;
        }
        
        saveEvents();
        renderCurrentView();
        
        return {
          success: true,
          entryId: updatedEntry.sys.id,
          message: '節目更新成功'
        };
        
      } catch (error) {
        console.error('❌ 更新節目失敗:', error);
        console.error('錯誤詳情:', {
          message: error.message,
          status: error.status,
          statusText: error.statusText,
          details: error.details,
          contentfulId: contentfulId,
          programData: programData
        });
        
        // 如果是 Contentful 驗證錯誤，提供更詳細的錯誤訊息
        let errorMessage = error.message || '更新失敗';
        if (error.status === 422) {
          errorMessage = 'Contentful 驗證錯誤：' + (error.details?.errors?.[0]?.details || error.message);
        } else if (error.status === 404) {
          errorMessage = '找不到指定的節目，可能已被刪除';
        } else if (error.status === 401) {
          errorMessage = 'API 權限錯誤，請檢查 Management Token';
        }
        
        return {
          success: false,
          error: errorMessage,
          details: error.details || error.message
        };
      }
    }

    async function uploadProgramSimple(programData) {
      try {
        console.log('🚀 開始上架節目:', programData);
        
        // 檢查 Management SDK
        if (typeof contentfulManagement === 'undefined') {
          throw new Error('Management SDK 未載入');
        }
        console.log('✅ Management SDK 已載入');

        // 檢查 API Token
        const managementToken = window.CONTENTFUL_CONFIG?.MANAGEMENT_TOKEN || window.CONTENTFUL_MANAGEMENT_TOKEN;
        if (!managementToken) {
          throw new Error('Management Token 未設定');
        }
        console.log('✅ Management Token 已設定');

        // 創建 Management 客戶端
        const managementClient = contentfulManagement.createClient({
          accessToken: managementToken
        });
        console.log('✅ Management 客戶端已創建');

        // 獲取 Space
        const spaceId = window.CONTENTFUL_CONFIG?.SPACE_ID || 'os5wf90ljenp';
        const space = await managementClient.getSpace(spaceId);
        console.log('✅ Space 已獲取:', spaceId);
        
        // 獲取 Environment
        const environment = await space.getEnvironment('master');
        console.log('✅ Environment 已獲取: master');
        
        // 檢查是否已存在相同的節目
        const airDate = programData.airDate || new Date().toISOString().split('T')[0];
        const block = getTimeBlock(programData.airTime);
        const slotIndex = programData.slotNumber || 0;
        const airTime = programData.airTime; // 具體時間，如 "23:00"
        
        console.log('檢查重複節目:', { title: programData.title, airDate, airTime, block, slotIndex });
        
        // 查詢是否已存在相同日期、具體時間的節目
        const existingEntries = await environment.getEntries({
          content_type: 'scheduleItem',
          'fields.airDate': airDate,
          limit: 100
        });
        console.log('✅ 查詢現有節目完成，找到', existingEntries.items.length, '個節目');
        
        // 詳細記錄現有節目
        existingEntries.items.forEach((entry, index) => {
          const entryNotes = String(entry.fields.notes || '');
          const timeMatch = entryNotes.match(/\[時間:(\d{2}:\d{2})\]/);
          const entryAirTime = timeMatch ? timeMatch[1] : null;
          console.log(`現有節目 ${index + 1}:`, {
            id: entry.sys.id,
            title: entry.fields.title,
            notes: entryNotes,
            extractedTime: entryAirTime,
            targetTime: airTime,
            isMatch: entryAirTime === airTime
          });
        });
        
        // 檢查是否有相同具體時間的節目
        const duplicateProgram = existingEntries.items.find(entry => {
          const entryNotes = String(entry.fields.notes || '');
          const timeMatch = entryNotes.match(/\[時間:(\d{2}:\d{2})\]/);
          const entryAirTime = timeMatch ? timeMatch[1] : null;
          
          // 檢查時間是否相同
          if (entryAirTime !== airTime) {
            return false;
          }
          
          // 檢查是否是完全相同的節目（標題和 YouTube ID 都相同）
          const entryTitle = entry.fields.title || '';
          const entryYouTubeMatch = entryNotes.match(/\[YouTube:([^\]]+)\]/);
          const entryYouTubeId = entryYouTubeMatch ? entryYouTubeMatch[1] : '';
          
          const isSameTitle = entryTitle === (programData.title || '');
          const isSameYouTubeId = entryYouTubeId === (programData.youtubeId || '');
          
          // 如果是完全相同的節目，則視為重複
          if (isSameTitle && isSameYouTubeId) {
            console.log('發現完全相同節目:', {
              title: entryTitle,
              youtubeId: entryYouTubeId,
              time: entryAirTime
            });
            return true;
          }
          
          return false;
        });
        
        // 檢查是否有相同節目（標題和 YouTube ID 都相同）
        const sameProgram = existingEntries.items.find(entry => {
          const entryNotes = String(entry.fields.notes || '');
          const timeMatch = entryNotes.match(/\[時間:(\d{2}:\d{2})\]/);
          const entryAirTime = timeMatch ? timeMatch[1] : null;
          
          // 檢查時間是否相同
          if (entryAirTime !== airTime) {
            return false;
          }
          
          // 檢查是否是完全相同的節目
          const entryTitle = entry.fields.title || '';
          const entryYouTubeMatch = entryNotes.match(/\[YouTube:([^\]]+)\]/);
          const entryYouTubeId = entryYouTubeMatch ? entryYouTubeMatch[1] : '';
          
          const isSameTitle = entryTitle === (programData.title || '');
          const isSameYouTubeId = entryYouTubeId === (programData.youtubeId || '');
          
          // 如果是完全相同的節目，則視為可更新
          if (isSameTitle && isSameYouTubeId) {
            console.log('發現相同節目，將更新而非創建新 entry:', {
              existingTitle: entryTitle,
              existingYouTubeId: entryYouTubeId,
              existingTime: entryAirTime,
              entryId: entry.sys.id
            });
            return true;
          }
          
          return false;
        });
        
        // 檢查是否有時間衝突的節目（不同節目但相同時間）
        const timeConflictProgram = existingEntries.items.find(entry => {
          const entryNotes = String(entry.fields.notes || '');
          const timeMatch = entryNotes.match(/\[時間:(\d{2}:\d{2})\]/);
          const entryAirTime = timeMatch ? timeMatch[1] : null;
          
          // 檢查時間是否相同
          if (entryAirTime !== airTime) {
            return false;
          }
          
          // 檢查是否是不同的節目（標題或 YouTube ID 不同）
          const entryTitle = entry.fields.title || '';
          const entryYouTubeMatch = entryNotes.match(/\[YouTube:([^\]]+)\]/);
          const entryYouTubeId = entryYouTubeMatch ? entryYouTubeMatch[1] : '';
          
          const isSameTitle = entryTitle === (programData.title || '');
          const isSameYouTubeId = entryYouTubeId === (programData.youtubeId || '');
          
          // 如果是不同節目但相同時間，則視為時間衝突
          if (!isSameTitle || !isSameYouTubeId) {
            console.log('發現時間衝突節目:', {
              existingTitle: entryTitle,
              existingYouTubeId: entryYouTubeId,
              existingTime: entryAirTime,
              newTitle: programData.title,
              newYouTubeId: programData.youtubeId,
              newTime: airTime,
              isBatchCopy: programData.isBatchCopy,
              originalDate: programData.originalDate
            });
            return true;
          }
          
          return false;
        });
        
        if (sameProgram) {
          console.log('🔄 發現相同節目，將更新現有 entry:', sameProgram.sys.id);
          
          try {
            // 更新現有節目
            const updatedEntry = await sameProgram.update();
            
            // 更新所有欄位（只更新 Contentful 中實際存在的欄位）
            updatedEntry.fields.title = { 'en-US': programData.title };
            updatedEntry.fields.airDate = { 'en-US': airDate };
            updatedEntry.fields.notes = { 'en-US': notes };
            
            // 注意：airTime、status、duration、youtubeId、thumbnail 等資訊都存儲在 notes 欄位中
            // 不需要單獨更新這些欄位，因為它們在 Contentful 中不存在
            
            // 保存更新
            await updatedEntry.update();
            
            // 如果原本已發布，重新發布
            if (sameProgram.isPublished()) {
              await updatedEntry.publish();
            }
            
            console.log('✅ 成功更新現有節目:', sameProgram.sys.id);
            return { 
              success: true, 
              message: '成功更新現有節目',
              action: 'updated',
              entryId: sameProgram.sys.id
            };
            
          } catch (error) {
            console.error('❌ 更新節目失敗:', error);
            return { 
              success: false, 
              message: `更新節目失敗: ${error.message}`,
              action: 'update_failed'
            };
          }
        }
        
        if (duplicateProgram) {
          console.log('⚠️ 發現完全相同節目，跳過上架:', duplicateProgram.sys.id);
          console.log('重複節目詳情:', {
            id: duplicateProgram.sys.id,
            title: duplicateProgram.fields.title,
            notes: duplicateProgram.fields.notes,
            targetTime: airTime
          });
          return {
            success: true,
            entryId: duplicateProgram.sys.id,
            message: `發現完全相同節目，跳過重複上架`,
            skipped: true
          };
        }
        
        if (timeConflictProgram) {
          console.log('⚠️ 發現時間衝突節目:', timeConflictProgram.sys.id);
          console.log('時間衝突節目詳情:', {
            id: timeConflictProgram.sys.id,
            title: timeConflictProgram.fields.title,
            notes: timeConflictProgram.fields.notes,
            targetTime: airTime
          });
          
          // 詢問用戶是否要覆蓋
          const shouldOverwrite = await showOverwriteConfirmation(
            timeConflictProgram.fields.title || '未知節目',
            airTime,
            airDate,
            programData.isBatchCopy,
            programData.originalDate
          );
          
          if (!shouldOverwrite) {
            return {
              success: true,
              entryId: timeConflictProgram.sys.id,
              message: `用戶取消覆蓋，跳過上架`,
              skipped: true
            };
          }
          
          // 用戶選擇覆蓋，先刪除現有節目
          console.log('🗑️ 用戶選擇覆蓋，刪除現有節目:', timeConflictProgram.sys.id);
          try {
            await timeConflictProgram.unpublish();
            await timeConflictProgram.delete();
            console.log('✅ 成功刪除現有節目');
          } catch (deleteError) {
            console.error('❌ 刪除現有節目失敗:', deleteError);
            return {
              success: false,
              error: `刪除現有節目失敗: ${deleteError.message}`
            };
          }
        }
        
        // 準備 Entry 數據（簡化版本，不包含 video 欄位）
        let notes = (programData.description || '') + ` [時間:${airTime}]`;
        
        // 如果有 YouTube ID，添加到備註中
        if (programData.youtubeId) {
          notes += ` [YouTube:${programData.youtubeId}]`;
        }
        
        // 添加分類和主題資訊到備註中
        if (programData.category) {
          notes += ` [分類:${programData.category}]`;
        }
        
        if (programData.topics && programData.topics.length > 0) {
          notes += ` [主題:${programData.topics.join(',')}]`;
        }
        
        if (programData.duration) {
          notes += ` [時長:${programData.duration}分鐘]`;
        }
        
        if (programData.status) {
          notes += ` [狀態:${programData.status}]`;
        }
        
        if (programData.thumbnail) {
          // 檢查縮圖大小
          let thumbnail = programData.thumbnail;
          if (thumbnail.startsWith('data:image/')) {
            const sizeInBytes = (thumbnail.length * 3) / 4; // base64 大小估算
            const maxSize = 500000; // 500KB 限制
            
            if (sizeInBytes > maxSize) {
              console.warn('⚠️ 縮圖太大，嘗試壓縮...', { sizeInBytes, maxSize });
              thumbnail = await compressImage(thumbnail, 0.7); // 壓縮到 70% 品質
              const newSize = (thumbnail.length * 3) / 4;
              console.log('📊 壓縮後大小:', { newSize, originalSize: sizeInBytes });
            }
          }
          
          notes += ` [縮圖:${thumbnail}]`;
        }
        
        // 驗證並調整 notes 欄位長度
        notes = validateAndAdjustNotesLength(notes);
        
        // 先創建 video entry
        let videoEntry;
        if (programData.youtubeId) {
          try {
            // 檢查是否已存在相同的 YouTube ID
            const existingVideos = await environment.getEntries({
              content_type: 'video',
              'fields.youTubeId': programData.youtubeId
            });
            
            if (existingVideos.items.length > 0) {
              videoEntry = existingVideos.items[0];
              console.log('找到現有的 video entry:', videoEntry.sys.id);
            } else {
              // 創建新的 video entry
              videoEntry = await environment.createEntry('video', {
                fields: {
                  'title': { 'en-US': programData.title || 'YouTube 影片' },
                  'videoType': { 'en-US': 'YouTube' },
                  'youTubeId': { 'en-US': programData.youtubeId }
                }
              });
              
              // 發布 video entry
              await videoEntry.publish();
              console.log('創建新的 video entry:', videoEntry.sys.id);
            }
          } catch (error) {
            console.error('創建 video entry 失敗:', error);
            throw new Error('無法創建影片資料：' + error.message);
          }
        } else {
          throw new Error('必須提供 YouTube ID 才能上架節目');
        }

        const entryData = {
          fields: {
            'title': { 'en-US': programData.title || '未命名節目' },
            'airDate': { 'en-US': airDate },
            'block': { 'en-US': block },
            'slotIndex': { 'en-US': slotIndex },
            'isPremiere': { 'en-US': programData.isFirstBroadcast || false },
            'notes': { 'en-US': notes },
            'video': { 
              'en-US': { 
                sys: { 
                  type: 'Link', 
                  linkType: 'Entry', 
                  id: videoEntry.sys.id 
                } 
              } 
            }
          }
        };
        
        
        console.log('準備上架的 Entry 資料:', entryData);

        // 創建 Entry
        const contentTypeId = programData.contentType || 'scheduleItem';
        console.log('創建 Entry，Content Type:', contentTypeId);
        const entry = await environment.createEntry(contentTypeId, entryData);
        console.log('✅ Entry 創建成功:', entry.sys.id);
        
        // 發布 Entry
        console.log('發布 Entry...');
        await entry.publish();
        console.log('✅ Entry 發布成功');
        
        return {
          success: true,
          entryId: entry.sys.id,
          message: '節目已成功上架到 Contentful'
        };
        
      } catch (error) {
        console.error('❌ 上架失敗:', error);
        console.error('錯誤詳情:', {
          message: error.message,
          stack: error.stack,
          programData: programData,
          managementSDK: typeof contentfulManagement,
          windowManagement: typeof window.contentfulManagement,
          config: window.CONTENTFUL_CONFIG
        });
        
        // 提供更詳細的錯誤訊息
        let errorMessage = error.message;
        if (error.message.includes('Management SDK')) {
          errorMessage = 'Management SDK 未載入，請重新整理頁面';
        } else if (error.message.includes('Token')) {
          errorMessage = 'API Token 設定錯誤，請檢查配置';
        } else if (error.message.includes('Space')) {
          errorMessage = 'Space ID 錯誤或無權限存取';
        } else if (error.message.includes('Content Type')) {
          errorMessage = 'Content Type 不存在，請檢查 Contentful 設定';
        }
        
        return {
          success: false,
          error: errorMessage,
          message: '節目上架失敗: ' + errorMessage
        };
      }
    }

    // ========== 簡化版批次修改功能 ==========
    
    async function showBatchEditDialog() {
      console.log('📝 開啟批次修改對話框');
      
      try {
        // 檢查必要的依賴
        if (typeof contentful === 'undefined') {
          throw new Error('Contentful SDK 未載入，請重新整理頁面');
        }
        
        // 顯示載入中的提示
        const loadingModal = document.createElement('div');
        loadingModal.className = 'modal';
        loadingModal.style.display = 'block';
        loadingModal.innerHTML = `
          <div class="modal-content" style="max-width: 600px; text-align: center;">
            <div class="modal-header">
              <h3>🔄 載入節目資料中...</h3>
            </div>
            <div style="padding: 30px;">
              <div style="font-size: 3rem; margin-bottom: 15px;">⏳</div>
              <p style="color: #666;">正在從 Contentful 載入已上架的節目...</p>
            </div>
          </div>
        `;
        document.body.appendChild(loadingModal);

        // 從 Contentful 載入所有已上架的節目
        const publishedPrograms = await loadPublishedPrograms();
        
        // 移除載入中的提示
        document.body.removeChild(loadingModal);
        
        if (publishedPrograms.length === 0) {
          alert('目前沒有已上架的節目');
          return;
        }

        // 顯示批次修改對話框
        displayBatchEditDialog(publishedPrograms);
        
      } catch (error) {
        console.error('❌ 批次修改功能錯誤:', error);
        
        // 移除載入中的提示（如果存在）
        const loadingModal = document.querySelector('.modal');
        if (loadingModal && loadingModal.innerHTML.includes('載入節目資料中')) {
          document.body.removeChild(loadingModal);
        }
        
        alert('批次修改功能錯誤：' + error.message);
      }
    }

    async function loadPublishedPrograms() {
      console.log('📥 從 Contentful 載入已上架節目...');
      
      const client = contentful.createClient({
        space: 'os5wf90ljenp',
        accessToken: 'lODH-WLwHwVZv7O4rFdBWjSnrzaQWGD4koeOZ1Dypj0'
      });

      // 載入所有 scheduleItem
      const response = await client.getEntries({
        content_type: 'scheduleItem',
        limit: 1000,
        order: '-fields.airDate'
      });

      console.log(`✅ 載入了 ${response.items.length} 個節目`);
      
      // 轉換為程式可用的格式
      return response.items.map(item => {
        const notes = String(item.fields.notes || '');
        
        // 從 notes 中提取時間
        const timeMatch = notes.match(/\[時間:(\d{2}:\d{2})\]/);
        const airTime = timeMatch ? timeMatch[1] : '';
        
        // 從 notes 中提取時長
        const durationMatch = notes.match(/\[時長:(\d+)分鐘\]/);
        const duration = durationMatch ? parseInt(durationMatch[1]) : 30;
        
        // 從 notes 中提取狀態
        const statusMatch = notes.match(/\[狀態:(.*?)\]/);
        const status = statusMatch ? statusMatch[1] : '重播';
        
        // 從 notes 中提取 YouTube ID
        const youtubeMatch = notes.match(/\[YouTube:([^\]]+)\]/);
        const youtubeId = youtubeMatch ? youtubeMatch[1] : '';
        
        // 從 notes 中提取縮圖
        const thumbnailMatch = notes.match(/\[縮圖:([^\]]+)\]/);
        const thumbnail = thumbnailMatch ? thumbnailMatch[1] : (youtubeId ? `https://img.youtube.com/vi/${youtubeId}/maxresdefault.jpg` : '');
        
        return {
          id: item.sys.id,
          title: item.fields.title || '未命名節目',
          airDate: item.fields.airDate || '',
          airTime: airTime,
          duration: duration,
          category: extractCategoryFromNotes(notes),
          topics: extractTopicsFromNotes(notes),
          description: notes,
          status: status,
          youtubeId: youtubeId,
          thumbnail: thumbnail,
          publishedAt: item.sys.publishedAt || item.sys.createdAt,
          updatedAt: item.sys.updatedAt
        };
      });
    }

    function extractCategoryFromNotes(notes) {
      if (!notes) return '';
      const match = notes.match(/\[分類:(.*?)\]/);
      return match ? match[1] : '';
    }

    function extractTopicsFromNotes(notes) {
      if (!notes) return [];
      const matches = notes.match(/\[主題:(.*?)\]/g);
      if (!matches) return [];
      
      // 提取所有主題標記的內容
      const topics = matches.map(m => m.replace(/\[主題:(.*?)\]/, '$1'));
      
      // 如果主題包含逗號分隔的多個主題，則分割它們
      const allTopics = [];
      topics.forEach(topic => {
        if (topic.includes(',')) {
          // 分割逗號分隔的主題
          const splitTopics = topic.split(',').map(t => t.trim()).filter(t => t);
          allTopics.push(...splitTopics);
        } else {
          allTopics.push(topic.trim());
        }
      });
      
      return allTopics;
    }

    function displayBatchEditDialog(programs) {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.display = 'block';
      modal.id = 'batchEditModal';

      // 按日期分組
      const programsByDate = {};
      programs.forEach(program => {
        if (!programsByDate[program.airDate]) {
          programsByDate[program.airDate] = [];
        }
        programsByDate[program.airDate].push(program);
      });

      const dates = Object.keys(programsByDate).sort();

      modal.innerHTML = `
        <div class="modal-content" style="max-width: 900px; max-height: 80vh;">
          <div class="modal-header">
            <h3>📝 批次修改節目</h3>
            <button class="modal-close" onclick="closeBatchEditDialog()">&times;</button>
          </div>
          <div style="padding: 20px;">
            <div style="margin-bottom: 20px;">
              <label style="font-weight: 600; display: block; margin-bottom: 10px;">
                選擇日期：
              </label>
              <select id="batchEditDateSelect" onchange="updateBatchEditProgramList()" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem;">
                <option value="">-- 選擇日期 --</option>
                ${dates.map(date => {
                  const dateObj = new Date(date);
                  const displayDate = `${dateObj.getFullYear()}年${dateObj.getMonth() + 1}月${dateObj.getDate()}日`;
                  const count = programsByDate[date].length;
                  return `<option value="${date}">${displayDate} (${count} 個節目)</option>`;
                }).join('')}
              </select>
            </div>

            <div id="batchEditProgramList" style="max-height: 400px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 15px; display: none;">
              <!-- 節目列表將在這裡顯示 -->
            </div>

            <div id="batchEditActions" style="display: none; margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
              <h4 style="margin-bottom: 15px;">批次修改選項：</h4>
              
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <div>
                  <label>
                    <input type="checkbox" id="batchEditCategory" onchange="toggleBatchEditField('category')">
                    修改節目分類
                  </label>
                  <select id="batchEditCategoryValue" disabled style="width: 100%; padding: 6px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;">
                    <option value="">請選擇分類</option>
                    <option value="亞洲">亞洲</option>
                    <option value="歐洲">歐洲</option>
                    <option value="北美洲">北美洲</option>
                    <option value="南美洲">南美洲</option>
                    <option value="非洲">非洲</option>
                    <option value="大洋洲">大洋洲</option>
                    <option value="南極洲">南極洲</option>
                  </select>
                </div>

                <div>
                  <label>
                    <input type="checkbox" id="batchEditTopics" onchange="toggleBatchEditField('topics')">
                    修改主題分類
                  </label>
                  <div id="batchEditTopicsValue" style="margin-top: 5px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: #f8f9fa; opacity: 0.5; pointer-events: none;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                      ${TOPICS_DATA.map(topic => `
                        <label style="font-size: 0.9rem;">
                          <input type="checkbox" name="batchTopics" value="${topic.id}">
                          ${topic.title}
                        </label>
                      `).join('')}
                    </div>
                  </div>
                </div>
              </div>

              <div style="margin-top: 20px; display: flex; justify-content: flex-end; gap: 10px;">
                <button onclick="closeBatchEditDialog()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                  取消
                </button>
                <button onclick="executeBatchEdit()" style="background: #ffc107; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: 600;">
                  確認修改
                </button>
              </div>
            </div>
          </div>
        </div>
      `;

      document.body.appendChild(modal);

      // 儲存程式資料供後續使用
      window.batchEditPrograms = programsByDate;

      // 點擊背景關閉
      modal.addEventListener('click', function(e) {
        if (e.target === modal) {
          closeBatchEditDialog();
        }
      });
    }

    function updateBatchEditProgramList() {
      const dateSelect = document.getElementById('batchEditDateSelect');
      const selectedDate = dateSelect.value;
      const programList = document.getElementById('batchEditProgramList');
      const batchEditActions = document.getElementById('batchEditActions');

      if (!selectedDate) {
        programList.style.display = 'none';
        batchEditActions.style.display = 'none';
        return;
      }

      const programs = window.batchEditPrograms[selectedDate] || [];
      
      programList.style.display = 'block';
      batchEditActions.style.display = 'block';

      programList.innerHTML = `
        <div style="margin-bottom: 10px; padding: 10px; background: #e3f2fd; border-radius: 5px;">
          <label style="font-weight: 600;">
            <input type="checkbox" id="selectAllPrograms" onchange="toggleSelectAllPrograms()" checked>
            全選 (${programs.length} 個節目)
          </label>
        </div>
        ${programs.map((program, index) => `
          <div style="border: 1px solid #eee; border-radius: 8px; padding: 12px; margin-bottom: 10px; background: white;">
            <label style="display: flex; align-items: flex-start; cursor: pointer;">
              <input type="checkbox" class="program-checkbox" data-program-id="${program.id}" checked style="margin-right: 10px; margin-top: 4px;">
              <div style="flex: 1;">
                <div style="font-weight: 600; margin-bottom: 5px;">
                  <span style="color: #2b71d2; margin-right: 10px;">${program.airTime}</span>
                  ${program.title}
                </div>
                <div style="color: #666; font-size: 0.9rem;">
                  <span>${program.category || '未分類'}</span> • 
                  <span>${program.duration}分鐘</span> • 
                  <span style="color: ${program.status === '首播' ? '#ffc107' : '#28a745'};">${program.status}</span>
                </div>
                ${program.topics && program.topics.length > 0 ? `
                  <div style="margin-top: 5px;">
                    ${program.topics.map(topic => `<span style="background: #e3f2fd; color: #2b71d2; padding: 2px 8px; border-radius: 12px; font-size: 0.8rem; margin-right: 5px;">${topic}</span>`).join('')}
                  </div>
                ` : ''}
              </div>
            </label>
          </div>
        `).join('')}
      `;
    }

    function toggleSelectAllPrograms() {
      const selectAll = document.getElementById('selectAllPrograms');
      const checkboxes = document.querySelectorAll('.program-checkbox');
      checkboxes.forEach(checkbox => {
        checkbox.checked = selectAll.checked;
      });
    }

    function toggleBatchEditField(fieldName) {
      const checkbox = document.getElementById(`batchEdit${fieldName.charAt(0).toUpperCase() + fieldName.slice(1)}`);
      const valueField = document.getElementById(`batchEdit${fieldName.charAt(0).toUpperCase() + fieldName.slice(1)}Value`);
      
      if (checkbox.checked) {
        valueField.disabled = false;
        if (fieldName === 'topics') {
          valueField.style.opacity = '1';
          valueField.style.pointerEvents = 'auto';
        }
      } else {
        valueField.disabled = true;
        if (fieldName === 'topics') {
          valueField.style.opacity = '0.5';
          valueField.style.pointerEvents = 'none';
        }
      }
    }

    async function executeBatchEdit() {
      // 獲取選中的節目
      const selectedPrograms = [];
      document.querySelectorAll('.program-checkbox:checked').forEach(checkbox => {
        selectedPrograms.push(checkbox.dataset.programId);
      });

      if (selectedPrograms.length === 0) {
        alert('請至少選擇一個節目');
        return;
      }

      // 獲取要修改的欄位
      const updates = {};
      
      if (document.getElementById('batchEditCategory').checked) {
        updates.category = document.getElementById('batchEditCategoryValue').value;
        if (!updates.category) {
          alert('請選擇節目分類');
          return;
        }
      }

      if (document.getElementById('batchEditTopics').checked) {
        const selectedTopics = [];
        document.querySelectorAll('input[name="batchTopics"]:checked').forEach(checkbox => {
          const topicId = checkbox.value;
          const topic = TOPICS_DATA.find(t => t.id === topicId);
          if (topic) {
            selectedTopics.push(topic.title);
          }
        });
        if (selectedTopics.length > 0) {
          updates.topics = selectedTopics;
        }
      }

      if (Object.keys(updates).length === 0) {
        alert('請至少選擇一個要修改的欄位');
        return;
      }

      // 確認修改
      const confirmMessage = `
確認要批次修改 ${selectedPrograms.length} 個節目嗎？

修改內容：
${updates.category ? `• 節目分類：${updates.category}\n` : ''}
${updates.topics ? `• 主題分類：${updates.topics.join('、')}\n` : ''}
      `.trim();

      if (!confirm(confirmMessage)) {
        return;
      }

      // 執行批次修改
      await performBatchEdit(selectedPrograms, updates);
    }

    async function performBatchEdit(programIds, updates) {
      // 顯示進度對話框
      const progressDialog = createBatchProgressDialog();
      document.body.appendChild(progressDialog);
      
      let successCount = 0;
      let failCount = 0;
      const total = programIds.length;

      try {
        // 載入 Management SDK
        if (typeof contentfulManagement === 'undefined' && typeof window.contentfulManagement === 'undefined') {
          throw new Error('Management SDK 未載入');
        }

        const managementClient = (window.contentfulManagement || contentfulManagement).createClient({
          accessToken: 'CFPAT-7c8b9a2d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z6'
        });

        const space = await managementClient.getSpace('os5wf90ljenp');
        const environment = await space.getEnvironment('master');

        // 逐個修改節目
        for (let i = 0; i < programIds.length; i++) {
          const programId = programIds[i];
          updateBatchProgress(i + 1, total, `正在修改節目 ${i + 1}/${total}...`);

          try {
            // 獲取 Entry
            const entry = await environment.getEntry(programId);
            
            // 更新欄位
            let notes = entry.fields.notes?.['zh-Hant'] || '';
            
            // 移除舊的標記
            notes = notes.replace(/\[分類:.*?\]/g, '');
            notes = notes.replace(/\[主題:.*?\]/g, '');
            
            // 添加新的標記
            if (updates.category) {
              notes = `[分類:${updates.category}] ${notes}`;
            }
            if (updates.topics) {
              updates.topics.forEach(topic => {
                notes = `[主題:${topic}] ${notes}`;
              });
            }
            
            entry.fields.notes = { 'zh-Hant': notes.trim() };

            // 更新並重新發布
            const updatedEntry = await entry.update();
            if (updatedEntry.isPublished()) {
              await updatedEntry.publish();
            }
            
            successCount++;
            console.log(`✅ 成功修改節目 ${i + 1}/${total}`);

          } catch (error) {
            failCount++;
            console.error(`❌ 修改節目失敗 ${i + 1}/${total}:`, error);
          }

          // 延遲以避免 API 速率限制
          if (i < programIds.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
        }

        // 顯示完成訊息
        updateBatchProgressComplete(successCount, failCount, total);
        
        // 3秒後關閉進度對話框
        setTimeout(() => {
          document.body.removeChild(progressDialog);
          closeBatchEditDialog();
          
          // 重新載入節目
          loadEvents();
          renderCurrentView();
          
          alert(`批次修改完成！\n成功：${successCount} 個\n失敗：${failCount} 個`);
        }, 3000);

      } catch (error) {
        console.error('批次修改失敗:', error);
        document.body.removeChild(progressDialog);
        alert('批次修改失敗：' + error.message);
      }
    }

    function closeBatchEditDialog() {
      const modal = document.getElementById('batchEditModal');
      if (modal) {
        document.body.removeChild(modal);
      }
      delete window.batchEditPrograms;
    }

    // 批次進度相關函數
    function createBatchProgressDialog() {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.display = 'block';
      modal.id = 'batchProgressModal';
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 500px; text-align: center;">
          <div class="modal-header">
            <h3>🔄 批次修改進行中...</h3>
          </div>
          <div style="padding: 30px;">
            <div id="batchProgressBar" style="width: 100%; height: 20px; background: #f0f0f0; border-radius: 10px; overflow: hidden; margin-bottom: 15px;">
              <div id="batchProgressFill" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ffc107, #17a2b8); transition: width 0.3s ease;"></div>
            </div>
            <div id="batchProgressText" style="font-size: 1.1rem; color: #333; margin-bottom: 10px;">
              準備中...
            </div>
            <div id="batchProgressCount" style="font-size: 0.9rem; color: #666;">
              0 / 0
            </div>
          </div>
        </div>
      `;
      return modal;
    }

    function updateBatchProgress(current, total, message) {
      const progressFill = document.getElementById('batchProgressFill');
      const progressText = document.getElementById('batchProgressText');
      const progressCount = document.getElementById('batchProgressCount');
      
      if (progressFill) {
        const percentage = (current / total) * 100;
        progressFill.style.width = percentage + '%';
      }
      
      if (progressText) {
        progressText.textContent = message;
      }
      
      if (progressCount) {
        progressCount.textContent = `${current} / ${total}`;
      }
    }

    function updateBatchProgressComplete(successCount, failCount, total) {
      const progressText = document.getElementById('batchProgressText');
      const progressCount = document.getElementById('batchProgressCount');
      
      if (progressText) {
        progressText.textContent = '✅ 批次修改完成！';
        progressText.style.color = '#28a745';
      }
      
      if (progressCount) {
        progressCount.innerHTML = `
          <div style="color: #28a745; font-weight: 600;">成功：${successCount} 個</div>
          <div style="color: #dc3545; font-weight: 600;">失敗：${failCount} 個</div>
          <div style="color: #666;">總計：${total} 個</div>
        `;
      }
    }

  </script>
</body>
</html>
